/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

/**
 * ActiveClientState enum.
 * @exports ActiveClientState
 * @enum {string}
 * @property {number} ACTIVE_CLIENT_STATE_NO_ACTIVE=0 ACTIVE_CLIENT_STATE_NO_ACTIVE value
 * @property {number} ACTIVE_CLIENT_STATE_IS_ACTIVE=1 ACTIVE_CLIENT_STATE_IS_ACTIVE value
 * @property {number} ACTIVE_CLIENT_STATE_OTHER_ACTIVE=2 ACTIVE_CLIENT_STATE_OTHER_ACTIVE value
 */
$root.ActiveClientState = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "ACTIVE_CLIENT_STATE_NO_ACTIVE"] = 0;
    values[valuesById[1] = "ACTIVE_CLIENT_STATE_IS_ACTIVE"] = 1;
    values[valuesById[2] = "ACTIVE_CLIENT_STATE_OTHER_ACTIVE"] = 2;
    return values;
})();

export const DoNotDisturbSetting = $root.DoNotDisturbSetting = (() => {

    /**
     * Properties of a DoNotDisturbSetting.
     * @exports IDoNotDisturbSetting
     * @interface IDoNotDisturbSetting
     * @property {boolean|null} [doNotDisturb] DoNotDisturbSetting doNotDisturb
     * @property {number|Long|null} [expirationTimestamp] DoNotDisturbSetting expirationTimestamp
     * @property {number|Long|null} [version] DoNotDisturbSetting version
     */

    /**
     * Constructs a new DoNotDisturbSetting.
     * @exports DoNotDisturbSetting
     * @classdesc Represents a DoNotDisturbSetting.
     * @implements IDoNotDisturbSetting
     * @constructor
     * @param {IDoNotDisturbSetting=} [properties] Properties to set
     */
    function DoNotDisturbSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DoNotDisturbSetting doNotDisturb.
     * @member {boolean} doNotDisturb
     * @memberof DoNotDisturbSetting
     * @instance
     */
    DoNotDisturbSetting.prototype.doNotDisturb = false;

    /**
     * DoNotDisturbSetting expirationTimestamp.
     * @member {number|Long} expirationTimestamp
     * @memberof DoNotDisturbSetting
     * @instance
     */
    DoNotDisturbSetting.prototype.expirationTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * DoNotDisturbSetting version.
     * @member {number|Long} version
     * @memberof DoNotDisturbSetting
     * @instance
     */
    DoNotDisturbSetting.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DoNotDisturbSetting instance using the specified properties.
     * @function create
     * @memberof DoNotDisturbSetting
     * @static
     * @param {IDoNotDisturbSetting=} [properties] Properties to set
     * @returns {DoNotDisturbSetting} DoNotDisturbSetting instance
     */
    DoNotDisturbSetting.create = function create(properties) {
        return new DoNotDisturbSetting(properties);
    };

    /**
     * Encodes the specified DoNotDisturbSetting message. Does not implicitly {@link DoNotDisturbSetting.verify|verify} messages.
     * @function encode
     * @memberof DoNotDisturbSetting
     * @static
     * @param {IDoNotDisturbSetting} message DoNotDisturbSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DoNotDisturbSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.doNotDisturb);
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.expirationTimestamp);
        if (message.version != null && message.hasOwnProperty("version"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.version);
        return writer;
    };

    /**
     * Encodes the specified DoNotDisturbSetting message, length delimited. Does not implicitly {@link DoNotDisturbSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DoNotDisturbSetting
     * @static
     * @param {IDoNotDisturbSetting} message DoNotDisturbSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DoNotDisturbSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DoNotDisturbSetting message from the specified reader or buffer.
     * @function decode
     * @memberof DoNotDisturbSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DoNotDisturbSetting} DoNotDisturbSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DoNotDisturbSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DoNotDisturbSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.doNotDisturb = reader.bool();
                break;
            case 2:
                message.expirationTimestamp = reader.uint64();
                break;
            case 3:
                message.version = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DoNotDisturbSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DoNotDisturbSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DoNotDisturbSetting} DoNotDisturbSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DoNotDisturbSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DoNotDisturbSetting message.
     * @function verify
     * @memberof DoNotDisturbSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DoNotDisturbSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            if (typeof message.doNotDisturb !== "boolean")
                return "doNotDisturb: boolean expected";
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            if (!$util.isInteger(message.expirationTimestamp) && !(message.expirationTimestamp && $util.isInteger(message.expirationTimestamp.low) && $util.isInteger(message.expirationTimestamp.high)))
                return "expirationTimestamp: integer|Long expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                return "version: integer|Long expected";
        return null;
    };

    /**
     * Creates a DoNotDisturbSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DoNotDisturbSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DoNotDisturbSetting} DoNotDisturbSetting
     */
    DoNotDisturbSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.DoNotDisturbSetting)
            return object;
        let message = new $root.DoNotDisturbSetting();
        if (object.doNotDisturb != null)
            message.doNotDisturb = Boolean(object.doNotDisturb);
        if (object.expirationTimestamp != null)
            if ($util.Long)
                (message.expirationTimestamp = $util.Long.fromValue(object.expirationTimestamp)).unsigned = true;
            else if (typeof object.expirationTimestamp === "string")
                message.expirationTimestamp = parseInt(object.expirationTimestamp, 10);
            else if (typeof object.expirationTimestamp === "number")
                message.expirationTimestamp = object.expirationTimestamp;
            else if (typeof object.expirationTimestamp === "object")
                message.expirationTimestamp = new $util.LongBits(object.expirationTimestamp.low >>> 0, object.expirationTimestamp.high >>> 0).toNumber(true);
        if (object.version != null)
            if ($util.Long)
                (message.version = $util.Long.fromValue(object.version)).unsigned = true;
            else if (typeof object.version === "string")
                message.version = parseInt(object.version, 10);
            else if (typeof object.version === "number")
                message.version = object.version;
            else if (typeof object.version === "object")
                message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DoNotDisturbSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DoNotDisturbSetting
     * @static
     * @param {DoNotDisturbSetting} message DoNotDisturbSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DoNotDisturbSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.doNotDisturb = false;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.expirationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.expirationTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.version = options.longs === String ? "0" : 0;
        }
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            object.doNotDisturb = message.doNotDisturb;
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            if (typeof message.expirationTimestamp === "number")
                object.expirationTimestamp = options.longs === String ? String(message.expirationTimestamp) : message.expirationTimestamp;
            else
                object.expirationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expirationTimestamp) : options.longs === Number ? new $util.LongBits(message.expirationTimestamp.low >>> 0, message.expirationTimestamp.high >>> 0).toNumber(true) : message.expirationTimestamp;
        if (message.version != null && message.hasOwnProperty("version"))
            if (typeof message.version === "number")
                object.version = options.longs === String ? String(message.version) : message.version;
            else
                object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
        return object;
    };

    /**
     * Converts this DoNotDisturbSetting to JSON.
     * @function toJSON
     * @memberof DoNotDisturbSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DoNotDisturbSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DoNotDisturbSetting;
})();

export const NotificationSettings = $root.NotificationSettings = (() => {

    /**
     * Properties of a NotificationSettings.
     * @exports INotificationSettings
     * @interface INotificationSettings
     * @property {IDoNotDisturbSetting|null} [dndSettings] NotificationSettings dndSettings
     */

    /**
     * Constructs a new NotificationSettings.
     * @exports NotificationSettings
     * @classdesc Represents a NotificationSettings.
     * @implements INotificationSettings
     * @constructor
     * @param {INotificationSettings=} [properties] Properties to set
     */
    function NotificationSettings(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * NotificationSettings dndSettings.
     * @member {IDoNotDisturbSetting|null|undefined} dndSettings
     * @memberof NotificationSettings
     * @instance
     */
    NotificationSettings.prototype.dndSettings = null;

    /**
     * Creates a new NotificationSettings instance using the specified properties.
     * @function create
     * @memberof NotificationSettings
     * @static
     * @param {INotificationSettings=} [properties] Properties to set
     * @returns {NotificationSettings} NotificationSettings instance
     */
    NotificationSettings.create = function create(properties) {
        return new NotificationSettings(properties);
    };

    /**
     * Encodes the specified NotificationSettings message. Does not implicitly {@link NotificationSettings.verify|verify} messages.
     * @function encode
     * @memberof NotificationSettings
     * @static
     * @param {INotificationSettings} message NotificationSettings message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NotificationSettings.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.dndSettings != null && message.hasOwnProperty("dndSettings"))
            $root.DoNotDisturbSetting.encode(message.dndSettings, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified NotificationSettings message, length delimited. Does not implicitly {@link NotificationSettings.verify|verify} messages.
     * @function encodeDelimited
     * @memberof NotificationSettings
     * @static
     * @param {INotificationSettings} message NotificationSettings message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    NotificationSettings.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a NotificationSettings message from the specified reader or buffer.
     * @function decode
     * @memberof NotificationSettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {NotificationSettings} NotificationSettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NotificationSettings.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NotificationSettings();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.dndSettings = $root.DoNotDisturbSetting.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a NotificationSettings message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof NotificationSettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {NotificationSettings} NotificationSettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    NotificationSettings.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a NotificationSettings message.
     * @function verify
     * @memberof NotificationSettings
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    NotificationSettings.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.dndSettings != null && message.hasOwnProperty("dndSettings")) {
            let error = $root.DoNotDisturbSetting.verify(message.dndSettings);
            if (error)
                return "dndSettings." + error;
        }
        return null;
    };

    /**
     * Creates a NotificationSettings message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof NotificationSettings
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {NotificationSettings} NotificationSettings
     */
    NotificationSettings.fromObject = function fromObject(object) {
        if (object instanceof $root.NotificationSettings)
            return object;
        let message = new $root.NotificationSettings();
        if (object.dndSettings != null) {
            if (typeof object.dndSettings !== "object")
                throw TypeError(".NotificationSettings.dndSettings: object expected");
            message.dndSettings = $root.DoNotDisturbSetting.fromObject(object.dndSettings);
        }
        return message;
    };

    /**
     * Creates a plain object from a NotificationSettings message. Also converts values to other types if specified.
     * @function toObject
     * @memberof NotificationSettings
     * @static
     * @param {NotificationSettings} message NotificationSettings
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    NotificationSettings.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.dndSettings = null;
        if (message.dndSettings != null && message.hasOwnProperty("dndSettings"))
            object.dndSettings = $root.DoNotDisturbSetting.toObject(message.dndSettings, options);
        return object;
    };

    /**
     * Converts this NotificationSettings to JSON.
     * @function toJSON
     * @memberof NotificationSettings
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    NotificationSettings.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return NotificationSettings;
})();

/**
 * FocusType enum.
 * @exports FocusType
 * @enum {string}
 * @property {number} FOCUS_TYPE_UNKNOWN=0 FOCUS_TYPE_UNKNOWN value
 * @property {number} FOCUS_TYPE_FOCUSED=1 FOCUS_TYPE_FOCUSED value
 * @property {number} FOCUS_TYPE_UNFOCUSED=2 FOCUS_TYPE_UNFOCUSED value
 */
$root.FocusType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "FOCUS_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "FOCUS_TYPE_FOCUSED"] = 1;
    values[valuesById[2] = "FOCUS_TYPE_UNFOCUSED"] = 2;
    return values;
})();

/**
 * FocusDevice enum.
 * @exports FocusDevice
 * @enum {string}
 * @property {number} FOCUS_DEVICE_UNSPECIFIED=0 FOCUS_DEVICE_UNSPECIFIED value
 * @property {number} FOCUS_DEVICE_DESKTOP=20 FOCUS_DEVICE_DESKTOP value
 * @property {number} FOCUS_DEVICE_MOBILE=300 FOCUS_DEVICE_MOBILE value
 */
$root.FocusDevice = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "FOCUS_DEVICE_UNSPECIFIED"] = 0;
    values[valuesById[20] = "FOCUS_DEVICE_DESKTOP"] = 20;
    values[valuesById[300] = "FOCUS_DEVICE_MOBILE"] = 300;
    return values;
})();

export const ConversationId = $root.ConversationId = (() => {

    /**
     * Properties of a ConversationId.
     * @exports IConversationId
     * @interface IConversationId
     * @property {string|null} [id] ConversationId id
     */

    /**
     * Constructs a new ConversationId.
     * @exports ConversationId
     * @classdesc Represents a ConversationId.
     * @implements IConversationId
     * @constructor
     * @param {IConversationId=} [properties] Properties to set
     */
    function ConversationId(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationId id.
     * @member {string} id
     * @memberof ConversationId
     * @instance
     */
    ConversationId.prototype.id = "";

    /**
     * Creates a new ConversationId instance using the specified properties.
     * @function create
     * @memberof ConversationId
     * @static
     * @param {IConversationId=} [properties] Properties to set
     * @returns {ConversationId} ConversationId instance
     */
    ConversationId.create = function create(properties) {
        return new ConversationId(properties);
    };

    /**
     * Encodes the specified ConversationId message. Does not implicitly {@link ConversationId.verify|verify} messages.
     * @function encode
     * @memberof ConversationId
     * @static
     * @param {IConversationId} message ConversationId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
        return writer;
    };

    /**
     * Encodes the specified ConversationId message, length delimited. Does not implicitly {@link ConversationId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationId
     * @static
     * @param {IConversationId} message ConversationId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationId message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationId} ConversationId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationId();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationId} ConversationId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationId message.
     * @function verify
     * @memberof ConversationId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        return null;
    };

    /**
     * Creates a ConversationId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationId} ConversationId
     */
    ConversationId.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationId)
            return object;
        let message = new $root.ConversationId();
        if (object.id != null)
            message.id = String(object.id);
        return message;
    };

    /**
     * Creates a plain object from a ConversationId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationId
     * @static
     * @param {ConversationId} message ConversationId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.id = "";
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        return object;
    };

    /**
     * Converts this ConversationId to JSON.
     * @function toJSON
     * @memberof ConversationId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationId;
})();

export const ParticipantId = $root.ParticipantId = (() => {

    /**
     * Properties of a ParticipantId.
     * @exports IParticipantId
     * @interface IParticipantId
     * @property {string|null} [gaiaId] ParticipantId gaiaId
     * @property {string|null} [chatId] ParticipantId chatId
     */

    /**
     * Constructs a new ParticipantId.
     * @exports ParticipantId
     * @classdesc Represents a ParticipantId.
     * @implements IParticipantId
     * @constructor
     * @param {IParticipantId=} [properties] Properties to set
     */
    function ParticipantId(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ParticipantId gaiaId.
     * @member {string} gaiaId
     * @memberof ParticipantId
     * @instance
     */
    ParticipantId.prototype.gaiaId = "";

    /**
     * ParticipantId chatId.
     * @member {string} chatId
     * @memberof ParticipantId
     * @instance
     */
    ParticipantId.prototype.chatId = "";

    /**
     * Creates a new ParticipantId instance using the specified properties.
     * @function create
     * @memberof ParticipantId
     * @static
     * @param {IParticipantId=} [properties] Properties to set
     * @returns {ParticipantId} ParticipantId instance
     */
    ParticipantId.create = function create(properties) {
        return new ParticipantId(properties);
    };

    /**
     * Encodes the specified ParticipantId message. Does not implicitly {@link ParticipantId.verify|verify} messages.
     * @function encode
     * @memberof ParticipantId
     * @static
     * @param {IParticipantId} message ParticipantId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParticipantId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.gaiaId);
        if (message.chatId != null && message.hasOwnProperty("chatId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.chatId);
        return writer;
    };

    /**
     * Encodes the specified ParticipantId message, length delimited. Does not implicitly {@link ParticipantId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ParticipantId
     * @static
     * @param {IParticipantId} message ParticipantId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ParticipantId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ParticipantId message from the specified reader or buffer.
     * @function decode
     * @memberof ParticipantId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ParticipantId} ParticipantId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParticipantId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ParticipantId();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.gaiaId = reader.string();
                break;
            case 2:
                message.chatId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ParticipantId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ParticipantId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ParticipantId} ParticipantId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ParticipantId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ParticipantId message.
     * @function verify
     * @memberof ParticipantId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ParticipantId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            if (!$util.isString(message.gaiaId))
                return "gaiaId: string expected";
        if (message.chatId != null && message.hasOwnProperty("chatId"))
            if (!$util.isString(message.chatId))
                return "chatId: string expected";
        return null;
    };

    /**
     * Creates a ParticipantId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ParticipantId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ParticipantId} ParticipantId
     */
    ParticipantId.fromObject = function fromObject(object) {
        if (object instanceof $root.ParticipantId)
            return object;
        let message = new $root.ParticipantId();
        if (object.gaiaId != null)
            message.gaiaId = String(object.gaiaId);
        if (object.chatId != null)
            message.chatId = String(object.chatId);
        return message;
    };

    /**
     * Creates a plain object from a ParticipantId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ParticipantId
     * @static
     * @param {ParticipantId} message ParticipantId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ParticipantId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.gaiaId = "";
            object.chatId = "";
        }
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            object.gaiaId = message.gaiaId;
        if (message.chatId != null && message.hasOwnProperty("chatId"))
            object.chatId = message.chatId;
        return object;
    };

    /**
     * Converts this ParticipantId to JSON.
     * @function toJSON
     * @memberof ParticipantId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ParticipantId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ParticipantId;
})();

export const DeviceStatus = $root.DeviceStatus = (() => {

    /**
     * Properties of a DeviceStatus.
     * @exports IDeviceStatus
     * @interface IDeviceStatus
     * @property {boolean|null} [mobile] DeviceStatus mobile
     * @property {boolean|null} [desktop] DeviceStatus desktop
     * @property {boolean|null} [tablet] DeviceStatus tablet
     */

    /**
     * Constructs a new DeviceStatus.
     * @exports DeviceStatus
     * @classdesc Represents a DeviceStatus.
     * @implements IDeviceStatus
     * @constructor
     * @param {IDeviceStatus=} [properties] Properties to set
     */
    function DeviceStatus(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeviceStatus mobile.
     * @member {boolean} mobile
     * @memberof DeviceStatus
     * @instance
     */
    DeviceStatus.prototype.mobile = false;

    /**
     * DeviceStatus desktop.
     * @member {boolean} desktop
     * @memberof DeviceStatus
     * @instance
     */
    DeviceStatus.prototype.desktop = false;

    /**
     * DeviceStatus tablet.
     * @member {boolean} tablet
     * @memberof DeviceStatus
     * @instance
     */
    DeviceStatus.prototype.tablet = false;

    /**
     * Creates a new DeviceStatus instance using the specified properties.
     * @function create
     * @memberof DeviceStatus
     * @static
     * @param {IDeviceStatus=} [properties] Properties to set
     * @returns {DeviceStatus} DeviceStatus instance
     */
    DeviceStatus.create = function create(properties) {
        return new DeviceStatus(properties);
    };

    /**
     * Encodes the specified DeviceStatus message. Does not implicitly {@link DeviceStatus.verify|verify} messages.
     * @function encode
     * @memberof DeviceStatus
     * @static
     * @param {IDeviceStatus} message DeviceStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceStatus.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mobile != null && message.hasOwnProperty("mobile"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.mobile);
        if (message.desktop != null && message.hasOwnProperty("desktop"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.desktop);
        if (message.tablet != null && message.hasOwnProperty("tablet"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.tablet);
        return writer;
    };

    /**
     * Encodes the specified DeviceStatus message, length delimited. Does not implicitly {@link DeviceStatus.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeviceStatus
     * @static
     * @param {IDeviceStatus} message DeviceStatus message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeviceStatus.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeviceStatus message from the specified reader or buffer.
     * @function decode
     * @memberof DeviceStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeviceStatus} DeviceStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceStatus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeviceStatus();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.mobile = reader.bool();
                break;
            case 2:
                message.desktop = reader.bool();
                break;
            case 3:
                message.tablet = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeviceStatus message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeviceStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeviceStatus} DeviceStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeviceStatus.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeviceStatus message.
     * @function verify
     * @memberof DeviceStatus
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeviceStatus.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mobile != null && message.hasOwnProperty("mobile"))
            if (typeof message.mobile !== "boolean")
                return "mobile: boolean expected";
        if (message.desktop != null && message.hasOwnProperty("desktop"))
            if (typeof message.desktop !== "boolean")
                return "desktop: boolean expected";
        if (message.tablet != null && message.hasOwnProperty("tablet"))
            if (typeof message.tablet !== "boolean")
                return "tablet: boolean expected";
        return null;
    };

    /**
     * Creates a DeviceStatus message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeviceStatus
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeviceStatus} DeviceStatus
     */
    DeviceStatus.fromObject = function fromObject(object) {
        if (object instanceof $root.DeviceStatus)
            return object;
        let message = new $root.DeviceStatus();
        if (object.mobile != null)
            message.mobile = Boolean(object.mobile);
        if (object.desktop != null)
            message.desktop = Boolean(object.desktop);
        if (object.tablet != null)
            message.tablet = Boolean(object.tablet);
        return message;
    };

    /**
     * Creates a plain object from a DeviceStatus message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeviceStatus
     * @static
     * @param {DeviceStatus} message DeviceStatus
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeviceStatus.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.mobile = false;
            object.desktop = false;
            object.tablet = false;
        }
        if (message.mobile != null && message.hasOwnProperty("mobile"))
            object.mobile = message.mobile;
        if (message.desktop != null && message.hasOwnProperty("desktop"))
            object.desktop = message.desktop;
        if (message.tablet != null && message.hasOwnProperty("tablet"))
            object.tablet = message.tablet;
        return object;
    };

    /**
     * Converts this DeviceStatus to JSON.
     * @function toJSON
     * @memberof DeviceStatus
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeviceStatus.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeviceStatus;
})();

export const LastSeen = $root.LastSeen = (() => {

    /**
     * Properties of a LastSeen.
     * @exports ILastSeen
     * @interface ILastSeen
     * @property {number|Long|null} [lastSeenTimestampUsec] LastSeen lastSeenTimestampUsec
     * @property {number|Long|null} [usecSinceLastSeen] LastSeen usecSinceLastSeen
     */

    /**
     * Constructs a new LastSeen.
     * @exports LastSeen
     * @classdesc Represents a LastSeen.
     * @implements ILastSeen
     * @constructor
     * @param {ILastSeen=} [properties] Properties to set
     */
    function LastSeen(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LastSeen lastSeenTimestampUsec.
     * @member {number|Long} lastSeenTimestampUsec
     * @memberof LastSeen
     * @instance
     */
    LastSeen.prototype.lastSeenTimestampUsec = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * LastSeen usecSinceLastSeen.
     * @member {number|Long} usecSinceLastSeen
     * @memberof LastSeen
     * @instance
     */
    LastSeen.prototype.usecSinceLastSeen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new LastSeen instance using the specified properties.
     * @function create
     * @memberof LastSeen
     * @static
     * @param {ILastSeen=} [properties] Properties to set
     * @returns {LastSeen} LastSeen instance
     */
    LastSeen.create = function create(properties) {
        return new LastSeen(properties);
    };

    /**
     * Encodes the specified LastSeen message. Does not implicitly {@link LastSeen.verify|verify} messages.
     * @function encode
     * @memberof LastSeen
     * @static
     * @param {ILastSeen} message LastSeen message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LastSeen.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.lastSeenTimestampUsec != null && message.hasOwnProperty("lastSeenTimestampUsec"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.lastSeenTimestampUsec);
        if (message.usecSinceLastSeen != null && message.hasOwnProperty("usecSinceLastSeen"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.usecSinceLastSeen);
        return writer;
    };

    /**
     * Encodes the specified LastSeen message, length delimited. Does not implicitly {@link LastSeen.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LastSeen
     * @static
     * @param {ILastSeen} message LastSeen message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LastSeen.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LastSeen message from the specified reader or buffer.
     * @function decode
     * @memberof LastSeen
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LastSeen} LastSeen
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LastSeen.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LastSeen();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.lastSeenTimestampUsec = reader.uint64();
                break;
            case 2:
                message.usecSinceLastSeen = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LastSeen message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LastSeen
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LastSeen} LastSeen
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LastSeen.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LastSeen message.
     * @function verify
     * @memberof LastSeen
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LastSeen.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.lastSeenTimestampUsec != null && message.hasOwnProperty("lastSeenTimestampUsec"))
            if (!$util.isInteger(message.lastSeenTimestampUsec) && !(message.lastSeenTimestampUsec && $util.isInteger(message.lastSeenTimestampUsec.low) && $util.isInteger(message.lastSeenTimestampUsec.high)))
                return "lastSeenTimestampUsec: integer|Long expected";
        if (message.usecSinceLastSeen != null && message.hasOwnProperty("usecSinceLastSeen"))
            if (!$util.isInteger(message.usecSinceLastSeen) && !(message.usecSinceLastSeen && $util.isInteger(message.usecSinceLastSeen.low) && $util.isInteger(message.usecSinceLastSeen.high)))
                return "usecSinceLastSeen: integer|Long expected";
        return null;
    };

    /**
     * Creates a LastSeen message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LastSeen
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LastSeen} LastSeen
     */
    LastSeen.fromObject = function fromObject(object) {
        if (object instanceof $root.LastSeen)
            return object;
        let message = new $root.LastSeen();
        if (object.lastSeenTimestampUsec != null)
            if ($util.Long)
                (message.lastSeenTimestampUsec = $util.Long.fromValue(object.lastSeenTimestampUsec)).unsigned = true;
            else if (typeof object.lastSeenTimestampUsec === "string")
                message.lastSeenTimestampUsec = parseInt(object.lastSeenTimestampUsec, 10);
            else if (typeof object.lastSeenTimestampUsec === "number")
                message.lastSeenTimestampUsec = object.lastSeenTimestampUsec;
            else if (typeof object.lastSeenTimestampUsec === "object")
                message.lastSeenTimestampUsec = new $util.LongBits(object.lastSeenTimestampUsec.low >>> 0, object.lastSeenTimestampUsec.high >>> 0).toNumber(true);
        if (object.usecSinceLastSeen != null)
            if ($util.Long)
                (message.usecSinceLastSeen = $util.Long.fromValue(object.usecSinceLastSeen)).unsigned = true;
            else if (typeof object.usecSinceLastSeen === "string")
                message.usecSinceLastSeen = parseInt(object.usecSinceLastSeen, 10);
            else if (typeof object.usecSinceLastSeen === "number")
                message.usecSinceLastSeen = object.usecSinceLastSeen;
            else if (typeof object.usecSinceLastSeen === "object")
                message.usecSinceLastSeen = new $util.LongBits(object.usecSinceLastSeen.low >>> 0, object.usecSinceLastSeen.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a LastSeen message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LastSeen
     * @static
     * @param {LastSeen} message LastSeen
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LastSeen.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastSeenTimestampUsec = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastSeenTimestampUsec = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.usecSinceLastSeen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.usecSinceLastSeen = options.longs === String ? "0" : 0;
        }
        if (message.lastSeenTimestampUsec != null && message.hasOwnProperty("lastSeenTimestampUsec"))
            if (typeof message.lastSeenTimestampUsec === "number")
                object.lastSeenTimestampUsec = options.longs === String ? String(message.lastSeenTimestampUsec) : message.lastSeenTimestampUsec;
            else
                object.lastSeenTimestampUsec = options.longs === String ? $util.Long.prototype.toString.call(message.lastSeenTimestampUsec) : options.longs === Number ? new $util.LongBits(message.lastSeenTimestampUsec.low >>> 0, message.lastSeenTimestampUsec.high >>> 0).toNumber(true) : message.lastSeenTimestampUsec;
        if (message.usecSinceLastSeen != null && message.hasOwnProperty("usecSinceLastSeen"))
            if (typeof message.usecSinceLastSeen === "number")
                object.usecSinceLastSeen = options.longs === String ? String(message.usecSinceLastSeen) : message.usecSinceLastSeen;
            else
                object.usecSinceLastSeen = options.longs === String ? $util.Long.prototype.toString.call(message.usecSinceLastSeen) : options.longs === Number ? new $util.LongBits(message.usecSinceLastSeen.low >>> 0, message.usecSinceLastSeen.high >>> 0).toNumber(true) : message.usecSinceLastSeen;
        return object;
    };

    /**
     * Converts this LastSeen to JSON.
     * @function toJSON
     * @memberof LastSeen
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LastSeen.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LastSeen;
})();

export const Presence = $root.Presence = (() => {

    /**
     * Properties of a Presence.
     * @exports IPresence
     * @interface IPresence
     * @property {boolean|null} [reachable] Presence reachable
     * @property {boolean|null} [available] Presence available
     * @property {IDeviceStatus|null} [deviceStatus] Presence deviceStatus
     * @property {IMoodMessage|null} [moodMessage] Presence moodMessage
     * @property {ILastSeen|null} [lastSeen] Presence lastSeen
     */

    /**
     * Constructs a new Presence.
     * @exports Presence
     * @classdesc Represents a Presence.
     * @implements IPresence
     * @constructor
     * @param {IPresence=} [properties] Properties to set
     */
    function Presence(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Presence reachable.
     * @member {boolean} reachable
     * @memberof Presence
     * @instance
     */
    Presence.prototype.reachable = false;

    /**
     * Presence available.
     * @member {boolean} available
     * @memberof Presence
     * @instance
     */
    Presence.prototype.available = false;

    /**
     * Presence deviceStatus.
     * @member {IDeviceStatus|null|undefined} deviceStatus
     * @memberof Presence
     * @instance
     */
    Presence.prototype.deviceStatus = null;

    /**
     * Presence moodMessage.
     * @member {IMoodMessage|null|undefined} moodMessage
     * @memberof Presence
     * @instance
     */
    Presence.prototype.moodMessage = null;

    /**
     * Presence lastSeen.
     * @member {ILastSeen|null|undefined} lastSeen
     * @memberof Presence
     * @instance
     */
    Presence.prototype.lastSeen = null;

    /**
     * Creates a new Presence instance using the specified properties.
     * @function create
     * @memberof Presence
     * @static
     * @param {IPresence=} [properties] Properties to set
     * @returns {Presence} Presence instance
     */
    Presence.create = function create(properties) {
        return new Presence(properties);
    };

    /**
     * Encodes the specified Presence message. Does not implicitly {@link Presence.verify|verify} messages.
     * @function encode
     * @memberof Presence
     * @static
     * @param {IPresence} message Presence message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Presence.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.reachable != null && message.hasOwnProperty("reachable"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.reachable);
        if (message.available != null && message.hasOwnProperty("available"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.available);
        if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
            $root.DeviceStatus.encode(message.deviceStatus, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage"))
            $root.MoodMessage.encode(message.moodMessage, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
            $root.LastSeen.encode(message.lastSeen, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Presence message, length delimited. Does not implicitly {@link Presence.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Presence
     * @static
     * @param {IPresence} message Presence message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Presence.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Presence message from the specified reader or buffer.
     * @function decode
     * @memberof Presence
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Presence} Presence
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Presence.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Presence();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.reachable = reader.bool();
                break;
            case 2:
                message.available = reader.bool();
                break;
            case 6:
                message.deviceStatus = $root.DeviceStatus.decode(reader, reader.uint32());
                break;
            case 9:
                message.moodMessage = $root.MoodMessage.decode(reader, reader.uint32());
                break;
            case 10:
                message.lastSeen = $root.LastSeen.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Presence message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Presence
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Presence} Presence
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Presence.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Presence message.
     * @function verify
     * @memberof Presence
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Presence.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.reachable != null && message.hasOwnProperty("reachable"))
            if (typeof message.reachable !== "boolean")
                return "reachable: boolean expected";
        if (message.available != null && message.hasOwnProperty("available"))
            if (typeof message.available !== "boolean")
                return "available: boolean expected";
        if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus")) {
            let error = $root.DeviceStatus.verify(message.deviceStatus);
            if (error)
                return "deviceStatus." + error;
        }
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage")) {
            let error = $root.MoodMessage.verify(message.moodMessage);
            if (error)
                return "moodMessage." + error;
        }
        if (message.lastSeen != null && message.hasOwnProperty("lastSeen")) {
            let error = $root.LastSeen.verify(message.lastSeen);
            if (error)
                return "lastSeen." + error;
        }
        return null;
    };

    /**
     * Creates a Presence message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Presence
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Presence} Presence
     */
    Presence.fromObject = function fromObject(object) {
        if (object instanceof $root.Presence)
            return object;
        let message = new $root.Presence();
        if (object.reachable != null)
            message.reachable = Boolean(object.reachable);
        if (object.available != null)
            message.available = Boolean(object.available);
        if (object.deviceStatus != null) {
            if (typeof object.deviceStatus !== "object")
                throw TypeError(".Presence.deviceStatus: object expected");
            message.deviceStatus = $root.DeviceStatus.fromObject(object.deviceStatus);
        }
        if (object.moodMessage != null) {
            if (typeof object.moodMessage !== "object")
                throw TypeError(".Presence.moodMessage: object expected");
            message.moodMessage = $root.MoodMessage.fromObject(object.moodMessage);
        }
        if (object.lastSeen != null) {
            if (typeof object.lastSeen !== "object")
                throw TypeError(".Presence.lastSeen: object expected");
            message.lastSeen = $root.LastSeen.fromObject(object.lastSeen);
        }
        return message;
    };

    /**
     * Creates a plain object from a Presence message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Presence
     * @static
     * @param {Presence} message Presence
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Presence.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.reachable = false;
            object.available = false;
            object.deviceStatus = null;
            object.moodMessage = null;
            object.lastSeen = null;
        }
        if (message.reachable != null && message.hasOwnProperty("reachable"))
            object.reachable = message.reachable;
        if (message.available != null && message.hasOwnProperty("available"))
            object.available = message.available;
        if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
            object.deviceStatus = $root.DeviceStatus.toObject(message.deviceStatus, options);
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage"))
            object.moodMessage = $root.MoodMessage.toObject(message.moodMessage, options);
        if (message.lastSeen != null && message.hasOwnProperty("lastSeen"))
            object.lastSeen = $root.LastSeen.toObject(message.lastSeen, options);
        return object;
    };

    /**
     * Converts this Presence to JSON.
     * @function toJSON
     * @memberof Presence
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Presence.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Presence;
})();

export const PresenceResult = $root.PresenceResult = (() => {

    /**
     * Properties of a PresenceResult.
     * @exports IPresenceResult
     * @interface IPresenceResult
     * @property {IParticipantId|null} [userId] PresenceResult userId
     * @property {IPresence|null} [presence] PresenceResult presence
     */

    /**
     * Constructs a new PresenceResult.
     * @exports PresenceResult
     * @classdesc Represents a PresenceResult.
     * @implements IPresenceResult
     * @constructor
     * @param {IPresenceResult=} [properties] Properties to set
     */
    function PresenceResult(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PresenceResult userId.
     * @member {IParticipantId|null|undefined} userId
     * @memberof PresenceResult
     * @instance
     */
    PresenceResult.prototype.userId = null;

    /**
     * PresenceResult presence.
     * @member {IPresence|null|undefined} presence
     * @memberof PresenceResult
     * @instance
     */
    PresenceResult.prototype.presence = null;

    /**
     * Creates a new PresenceResult instance using the specified properties.
     * @function create
     * @memberof PresenceResult
     * @static
     * @param {IPresenceResult=} [properties] Properties to set
     * @returns {PresenceResult} PresenceResult instance
     */
    PresenceResult.create = function create(properties) {
        return new PresenceResult(properties);
    };

    /**
     * Encodes the specified PresenceResult message. Does not implicitly {@link PresenceResult.verify|verify} messages.
     * @function encode
     * @memberof PresenceResult
     * @static
     * @param {IPresenceResult} message PresenceResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceResult.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userId != null && message.hasOwnProperty("userId"))
            $root.ParticipantId.encode(message.userId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.presence != null && message.hasOwnProperty("presence"))
            $root.Presence.encode(message.presence, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PresenceResult message, length delimited. Does not implicitly {@link PresenceResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PresenceResult
     * @static
     * @param {IPresenceResult} message PresenceResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceResult.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PresenceResult message from the specified reader or buffer.
     * @function decode
     * @memberof PresenceResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PresenceResult} PresenceResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceResult.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PresenceResult();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.presence = $root.Presence.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PresenceResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PresenceResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PresenceResult} PresenceResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceResult.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PresenceResult message.
     * @function verify
     * @memberof PresenceResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PresenceResult.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userId != null && message.hasOwnProperty("userId")) {
            let error = $root.ParticipantId.verify(message.userId);
            if (error)
                return "userId." + error;
        }
        if (message.presence != null && message.hasOwnProperty("presence")) {
            let error = $root.Presence.verify(message.presence);
            if (error)
                return "presence." + error;
        }
        return null;
    };

    /**
     * Creates a PresenceResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PresenceResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PresenceResult} PresenceResult
     */
    PresenceResult.fromObject = function fromObject(object) {
        if (object instanceof $root.PresenceResult)
            return object;
        let message = new $root.PresenceResult();
        if (object.userId != null) {
            if (typeof object.userId !== "object")
                throw TypeError(".PresenceResult.userId: object expected");
            message.userId = $root.ParticipantId.fromObject(object.userId);
        }
        if (object.presence != null) {
            if (typeof object.presence !== "object")
                throw TypeError(".PresenceResult.presence: object expected");
            message.presence = $root.Presence.fromObject(object.presence);
        }
        return message;
    };

    /**
     * Creates a plain object from a PresenceResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PresenceResult
     * @static
     * @param {PresenceResult} message PresenceResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PresenceResult.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.userId = null;
            object.presence = null;
        }
        if (message.userId != null && message.hasOwnProperty("userId"))
            object.userId = $root.ParticipantId.toObject(message.userId, options);
        if (message.presence != null && message.hasOwnProperty("presence"))
            object.presence = $root.Presence.toObject(message.presence, options);
        return object;
    };

    /**
     * Converts this PresenceResult to JSON.
     * @function toJSON
     * @memberof PresenceResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PresenceResult.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PresenceResult;
})();

/**
 * TypingType enum.
 * @exports TypingType
 * @enum {string}
 * @property {number} TYPING_TYPE_UNKNOWN=0 TYPING_TYPE_UNKNOWN value
 * @property {number} TYPING_TYPE_STARTED=1 TYPING_TYPE_STARTED value
 * @property {number} TYPING_TYPE_PAUSED=2 TYPING_TYPE_PAUSED value
 * @property {number} TYPING_TYPE_STOPPED=3 TYPING_TYPE_STOPPED value
 */
$root.TypingType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "TYPING_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "TYPING_TYPE_STARTED"] = 1;
    values[valuesById[2] = "TYPING_TYPE_PAUSED"] = 2;
    values[valuesById[3] = "TYPING_TYPE_STOPPED"] = 3;
    return values;
})();

export const ClientIdentifier = $root.ClientIdentifier = (() => {

    /**
     * Properties of a ClientIdentifier.
     * @exports IClientIdentifier
     * @interface IClientIdentifier
     * @property {string|null} [resource] ClientIdentifier resource
     * @property {string|null} [headerId] ClientIdentifier headerId
     */

    /**
     * Constructs a new ClientIdentifier.
     * @exports ClientIdentifier
     * @classdesc Represents a ClientIdentifier.
     * @implements IClientIdentifier
     * @constructor
     * @param {IClientIdentifier=} [properties] Properties to set
     */
    function ClientIdentifier(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientIdentifier resource.
     * @member {string} resource
     * @memberof ClientIdentifier
     * @instance
     */
    ClientIdentifier.prototype.resource = "";

    /**
     * ClientIdentifier headerId.
     * @member {string} headerId
     * @memberof ClientIdentifier
     * @instance
     */
    ClientIdentifier.prototype.headerId = "";

    /**
     * Creates a new ClientIdentifier instance using the specified properties.
     * @function create
     * @memberof ClientIdentifier
     * @static
     * @param {IClientIdentifier=} [properties] Properties to set
     * @returns {ClientIdentifier} ClientIdentifier instance
     */
    ClientIdentifier.create = function create(properties) {
        return new ClientIdentifier(properties);
    };

    /**
     * Encodes the specified ClientIdentifier message. Does not implicitly {@link ClientIdentifier.verify|verify} messages.
     * @function encode
     * @memberof ClientIdentifier
     * @static
     * @param {IClientIdentifier} message ClientIdentifier message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientIdentifier.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.resource != null && message.hasOwnProperty("resource"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.resource);
        if (message.headerId != null && message.hasOwnProperty("headerId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.headerId);
        return writer;
    };

    /**
     * Encodes the specified ClientIdentifier message, length delimited. Does not implicitly {@link ClientIdentifier.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientIdentifier
     * @static
     * @param {IClientIdentifier} message ClientIdentifier message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientIdentifier message from the specified reader or buffer.
     * @function decode
     * @memberof ClientIdentifier
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientIdentifier} ClientIdentifier
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientIdentifier.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientIdentifier();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.resource = reader.string();
                break;
            case 2:
                message.headerId = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientIdentifier message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientIdentifier
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientIdentifier} ClientIdentifier
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientIdentifier.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientIdentifier message.
     * @function verify
     * @memberof ClientIdentifier
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientIdentifier.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.resource != null && message.hasOwnProperty("resource"))
            if (!$util.isString(message.resource))
                return "resource: string expected";
        if (message.headerId != null && message.hasOwnProperty("headerId"))
            if (!$util.isString(message.headerId))
                return "headerId: string expected";
        return null;
    };

    /**
     * Creates a ClientIdentifier message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientIdentifier
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientIdentifier} ClientIdentifier
     */
    ClientIdentifier.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientIdentifier)
            return object;
        let message = new $root.ClientIdentifier();
        if (object.resource != null)
            message.resource = String(object.resource);
        if (object.headerId != null)
            message.headerId = String(object.headerId);
        return message;
    };

    /**
     * Creates a plain object from a ClientIdentifier message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientIdentifier
     * @static
     * @param {ClientIdentifier} message ClientIdentifier
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientIdentifier.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.resource = "";
            object.headerId = "";
        }
        if (message.resource != null && message.hasOwnProperty("resource"))
            object.resource = message.resource;
        if (message.headerId != null && message.hasOwnProperty("headerId"))
            object.headerId = message.headerId;
        return object;
    };

    /**
     * Converts this ClientIdentifier to JSON.
     * @function toJSON
     * @memberof ClientIdentifier
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientIdentifier.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ClientIdentifier;
})();

/**
 * ClientPresenceStateType enum.
 * @exports ClientPresenceStateType
 * @enum {string}
 * @property {number} CLIENT_PRESENCE_STATE_UNKNOWN=0 CLIENT_PRESENCE_STATE_UNKNOWN value
 * @property {number} CLIENT_PRESENCE_STATE_NONE=1 CLIENT_PRESENCE_STATE_NONE value
 * @property {number} CLIENT_PRESENCE_STATE_DESKTOP_IDLE=30 CLIENT_PRESENCE_STATE_DESKTOP_IDLE value
 * @property {number} CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE=40 CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE value
 */
$root.ClientPresenceStateType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CLIENT_PRESENCE_STATE_UNKNOWN"] = 0;
    values[valuesById[1] = "CLIENT_PRESENCE_STATE_NONE"] = 1;
    values[valuesById[30] = "CLIENT_PRESENCE_STATE_DESKTOP_IDLE"] = 30;
    values[valuesById[40] = "CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE"] = 40;
    return values;
})();

export const ClientPresenceState = $root.ClientPresenceState = (() => {

    /**
     * Properties of a ClientPresenceState.
     * @exports IClientPresenceState
     * @interface IClientPresenceState
     * @property {IClientIdentifier|null} [identifier] ClientPresenceState identifier
     * @property {ClientPresenceStateType|null} [state] ClientPresenceState state
     */

    /**
     * Constructs a new ClientPresenceState.
     * @exports ClientPresenceState
     * @classdesc Represents a ClientPresenceState.
     * @implements IClientPresenceState
     * @constructor
     * @param {IClientPresenceState=} [properties] Properties to set
     */
    function ClientPresenceState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientPresenceState identifier.
     * @member {IClientIdentifier|null|undefined} identifier
     * @memberof ClientPresenceState
     * @instance
     */
    ClientPresenceState.prototype.identifier = null;

    /**
     * ClientPresenceState state.
     * @member {ClientPresenceStateType} state
     * @memberof ClientPresenceState
     * @instance
     */
    ClientPresenceState.prototype.state = 0;

    /**
     * Creates a new ClientPresenceState instance using the specified properties.
     * @function create
     * @memberof ClientPresenceState
     * @static
     * @param {IClientPresenceState=} [properties] Properties to set
     * @returns {ClientPresenceState} ClientPresenceState instance
     */
    ClientPresenceState.create = function create(properties) {
        return new ClientPresenceState(properties);
    };

    /**
     * Encodes the specified ClientPresenceState message. Does not implicitly {@link ClientPresenceState.verify|verify} messages.
     * @function encode
     * @memberof ClientPresenceState
     * @static
     * @param {IClientPresenceState} message ClientPresenceState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientPresenceState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.identifier != null && message.hasOwnProperty("identifier"))
            $root.ClientIdentifier.encode(message.identifier, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.state != null && message.hasOwnProperty("state"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
        return writer;
    };

    /**
     * Encodes the specified ClientPresenceState message, length delimited. Does not implicitly {@link ClientPresenceState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientPresenceState
     * @static
     * @param {IClientPresenceState} message ClientPresenceState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientPresenceState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientPresenceState message from the specified reader or buffer.
     * @function decode
     * @memberof ClientPresenceState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientPresenceState} ClientPresenceState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientPresenceState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientPresenceState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.identifier = $root.ClientIdentifier.decode(reader, reader.uint32());
                break;
            case 2:
                message.state = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientPresenceState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientPresenceState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientPresenceState} ClientPresenceState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientPresenceState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientPresenceState message.
     * @function verify
     * @memberof ClientPresenceState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientPresenceState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.identifier != null && message.hasOwnProperty("identifier")) {
            let error = $root.ClientIdentifier.verify(message.identifier);
            if (error)
                return "identifier." + error;
        }
        if (message.state != null && message.hasOwnProperty("state"))
            switch (message.state) {
            default:
                return "state: enum value expected";
            case 0:
            case 1:
            case 30:
            case 40:
                break;
            }
        return null;
    };

    /**
     * Creates a ClientPresenceState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientPresenceState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientPresenceState} ClientPresenceState
     */
    ClientPresenceState.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientPresenceState)
            return object;
        let message = new $root.ClientPresenceState();
        if (object.identifier != null) {
            if (typeof object.identifier !== "object")
                throw TypeError(".ClientPresenceState.identifier: object expected");
            message.identifier = $root.ClientIdentifier.fromObject(object.identifier);
        }
        switch (object.state) {
        case "CLIENT_PRESENCE_STATE_UNKNOWN":
        case 0:
            message.state = 0;
            break;
        case "CLIENT_PRESENCE_STATE_NONE":
        case 1:
            message.state = 1;
            break;
        case "CLIENT_PRESENCE_STATE_DESKTOP_IDLE":
        case 30:
            message.state = 30;
            break;
        case "CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE":
        case 40:
            message.state = 40;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ClientPresenceState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientPresenceState
     * @static
     * @param {ClientPresenceState} message ClientPresenceState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientPresenceState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.identifier = null;
            object.state = options.enums === String ? "CLIENT_PRESENCE_STATE_UNKNOWN" : 0;
        }
        if (message.identifier != null && message.hasOwnProperty("identifier"))
            object.identifier = $root.ClientIdentifier.toObject(message.identifier, options);
        if (message.state != null && message.hasOwnProperty("state"))
            object.state = options.enums === String ? $root.ClientPresenceStateType[message.state] : message.state;
        return object;
    };

    /**
     * Converts this ClientPresenceState to JSON.
     * @function toJSON
     * @memberof ClientPresenceState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientPresenceState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ClientPresenceState;
})();

/**
 * NotificationLevel enum.
 * @exports NotificationLevel
 * @enum {string}
 * @property {number} NOTIFICATION_LEVEL_UNKNOWN=0 NOTIFICATION_LEVEL_UNKNOWN value
 * @property {number} NOTIFICATION_LEVEL_QUIET=10 NOTIFICATION_LEVEL_QUIET value
 * @property {number} NOTIFICATION_LEVEL_RING=30 NOTIFICATION_LEVEL_RING value
 */
$root.NotificationLevel = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "NOTIFICATION_LEVEL_UNKNOWN"] = 0;
    values[valuesById[10] = "NOTIFICATION_LEVEL_QUIET"] = 10;
    values[valuesById[30] = "NOTIFICATION_LEVEL_RING"] = 30;
    return values;
})();

export const UserEventState = $root.UserEventState = (() => {

    /**
     * Properties of a UserEventState.
     * @exports IUserEventState
     * @interface IUserEventState
     * @property {IParticipantId|null} [userId] UserEventState userId
     * @property {string|null} [clientGeneratedId] UserEventState clientGeneratedId
     * @property {NotificationLevel|null} [notificationLevel] UserEventState notificationLevel
     */

    /**
     * Constructs a new UserEventState.
     * @exports UserEventState
     * @classdesc Represents a UserEventState.
     * @implements IUserEventState
     * @constructor
     * @param {IUserEventState=} [properties] Properties to set
     */
    function UserEventState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserEventState userId.
     * @member {IParticipantId|null|undefined} userId
     * @memberof UserEventState
     * @instance
     */
    UserEventState.prototype.userId = null;

    /**
     * UserEventState clientGeneratedId.
     * @member {string} clientGeneratedId
     * @memberof UserEventState
     * @instance
     */
    UserEventState.prototype.clientGeneratedId = "";

    /**
     * UserEventState notificationLevel.
     * @member {NotificationLevel} notificationLevel
     * @memberof UserEventState
     * @instance
     */
    UserEventState.prototype.notificationLevel = 0;

    /**
     * Creates a new UserEventState instance using the specified properties.
     * @function create
     * @memberof UserEventState
     * @static
     * @param {IUserEventState=} [properties] Properties to set
     * @returns {UserEventState} UserEventState instance
     */
    UserEventState.create = function create(properties) {
        return new UserEventState(properties);
    };

    /**
     * Encodes the specified UserEventState message. Does not implicitly {@link UserEventState.verify|verify} messages.
     * @function encode
     * @memberof UserEventState
     * @static
     * @param {IUserEventState} message UserEventState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserEventState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.userId != null && message.hasOwnProperty("userId"))
            $root.ParticipantId.encode(message.userId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientGeneratedId);
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.notificationLevel);
        return writer;
    };

    /**
     * Encodes the specified UserEventState message, length delimited. Does not implicitly {@link UserEventState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserEventState
     * @static
     * @param {IUserEventState} message UserEventState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserEventState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserEventState message from the specified reader or buffer.
     * @function decode
     * @memberof UserEventState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserEventState} UserEventState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserEventState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserEventState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.userId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.clientGeneratedId = reader.string();
                break;
            case 3:
                message.notificationLevel = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserEventState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserEventState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserEventState} UserEventState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserEventState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserEventState message.
     * @function verify
     * @memberof UserEventState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserEventState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.userId != null && message.hasOwnProperty("userId")) {
            let error = $root.ParticipantId.verify(message.userId);
            if (error)
                return "userId." + error;
        }
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (!$util.isString(message.clientGeneratedId))
                return "clientGeneratedId: string expected";
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            switch (message.notificationLevel) {
            default:
                return "notificationLevel: enum value expected";
            case 0:
            case 10:
            case 30:
                break;
            }
        return null;
    };

    /**
     * Creates a UserEventState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserEventState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserEventState} UserEventState
     */
    UserEventState.fromObject = function fromObject(object) {
        if (object instanceof $root.UserEventState)
            return object;
        let message = new $root.UserEventState();
        if (object.userId != null) {
            if (typeof object.userId !== "object")
                throw TypeError(".UserEventState.userId: object expected");
            message.userId = $root.ParticipantId.fromObject(object.userId);
        }
        if (object.clientGeneratedId != null)
            message.clientGeneratedId = String(object.clientGeneratedId);
        switch (object.notificationLevel) {
        case "NOTIFICATION_LEVEL_UNKNOWN":
        case 0:
            message.notificationLevel = 0;
            break;
        case "NOTIFICATION_LEVEL_QUIET":
        case 10:
            message.notificationLevel = 10;
            break;
        case "NOTIFICATION_LEVEL_RING":
        case 30:
            message.notificationLevel = 30;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a UserEventState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserEventState
     * @static
     * @param {UserEventState} message UserEventState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserEventState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.userId = null;
            object.clientGeneratedId = "";
            object.notificationLevel = options.enums === String ? "NOTIFICATION_LEVEL_UNKNOWN" : 0;
        }
        if (message.userId != null && message.hasOwnProperty("userId"))
            object.userId = $root.ParticipantId.toObject(message.userId, options);
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            object.clientGeneratedId = message.clientGeneratedId;
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            object.notificationLevel = options.enums === String ? $root.NotificationLevel[message.notificationLevel] : message.notificationLevel;
        return object;
    };

    /**
     * Converts this UserEventState to JSON.
     * @function toJSON
     * @memberof UserEventState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserEventState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserEventState;
})();

/**
 * SegmentType enum.
 * @exports SegmentType
 * @enum {string}
 * @property {number} SEGMENT_TYPE_TEXT=0 SEGMENT_TYPE_TEXT value
 * @property {number} SEGMENT_TYPE_LINE_BREAK=1 SEGMENT_TYPE_LINE_BREAK value
 * @property {number} SEGMENT_TYPE_LINK=2 SEGMENT_TYPE_LINK value
 */
$root.SegmentType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SEGMENT_TYPE_TEXT"] = 0;
    values[valuesById[1] = "SEGMENT_TYPE_LINE_BREAK"] = 1;
    values[valuesById[2] = "SEGMENT_TYPE_LINK"] = 2;
    return values;
})();

export const Formatting = $root.Formatting = (() => {

    /**
     * Properties of a Formatting.
     * @exports IFormatting
     * @interface IFormatting
     * @property {boolean|null} [bold] Formatting bold
     * @property {boolean|null} [italic] Formatting italic
     * @property {boolean|null} [strikethrough] Formatting strikethrough
     * @property {boolean|null} [underline] Formatting underline
     */

    /**
     * Constructs a new Formatting.
     * @exports Formatting
     * @classdesc Represents a Formatting.
     * @implements IFormatting
     * @constructor
     * @param {IFormatting=} [properties] Properties to set
     */
    function Formatting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Formatting bold.
     * @member {boolean} bold
     * @memberof Formatting
     * @instance
     */
    Formatting.prototype.bold = false;

    /**
     * Formatting italic.
     * @member {boolean} italic
     * @memberof Formatting
     * @instance
     */
    Formatting.prototype.italic = false;

    /**
     * Formatting strikethrough.
     * @member {boolean} strikethrough
     * @memberof Formatting
     * @instance
     */
    Formatting.prototype.strikethrough = false;

    /**
     * Formatting underline.
     * @member {boolean} underline
     * @memberof Formatting
     * @instance
     */
    Formatting.prototype.underline = false;

    /**
     * Creates a new Formatting instance using the specified properties.
     * @function create
     * @memberof Formatting
     * @static
     * @param {IFormatting=} [properties] Properties to set
     * @returns {Formatting} Formatting instance
     */
    Formatting.create = function create(properties) {
        return new Formatting(properties);
    };

    /**
     * Encodes the specified Formatting message. Does not implicitly {@link Formatting.verify|verify} messages.
     * @function encode
     * @memberof Formatting
     * @static
     * @param {IFormatting} message Formatting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Formatting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.bold != null && message.hasOwnProperty("bold"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bold);
        if (message.italic != null && message.hasOwnProperty("italic"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.italic);
        if (message.strikethrough != null && message.hasOwnProperty("strikethrough"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.strikethrough);
        if (message.underline != null && message.hasOwnProperty("underline"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.underline);
        return writer;
    };

    /**
     * Encodes the specified Formatting message, length delimited. Does not implicitly {@link Formatting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Formatting
     * @static
     * @param {IFormatting} message Formatting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Formatting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Formatting message from the specified reader or buffer.
     * @function decode
     * @memberof Formatting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Formatting} Formatting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Formatting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Formatting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.bold = reader.bool();
                break;
            case 2:
                message.italic = reader.bool();
                break;
            case 3:
                message.strikethrough = reader.bool();
                break;
            case 4:
                message.underline = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Formatting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Formatting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Formatting} Formatting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Formatting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Formatting message.
     * @function verify
     * @memberof Formatting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Formatting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.bold != null && message.hasOwnProperty("bold"))
            if (typeof message.bold !== "boolean")
                return "bold: boolean expected";
        if (message.italic != null && message.hasOwnProperty("italic"))
            if (typeof message.italic !== "boolean")
                return "italic: boolean expected";
        if (message.strikethrough != null && message.hasOwnProperty("strikethrough"))
            if (typeof message.strikethrough !== "boolean")
                return "strikethrough: boolean expected";
        if (message.underline != null && message.hasOwnProperty("underline"))
            if (typeof message.underline !== "boolean")
                return "underline: boolean expected";
        return null;
    };

    /**
     * Creates a Formatting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Formatting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Formatting} Formatting
     */
    Formatting.fromObject = function fromObject(object) {
        if (object instanceof $root.Formatting)
            return object;
        let message = new $root.Formatting();
        if (object.bold != null)
            message.bold = Boolean(object.bold);
        if (object.italic != null)
            message.italic = Boolean(object.italic);
        if (object.strikethrough != null)
            message.strikethrough = Boolean(object.strikethrough);
        if (object.underline != null)
            message.underline = Boolean(object.underline);
        return message;
    };

    /**
     * Creates a plain object from a Formatting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Formatting
     * @static
     * @param {Formatting} message Formatting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Formatting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.bold = false;
            object.italic = false;
            object.strikethrough = false;
            object.underline = false;
        }
        if (message.bold != null && message.hasOwnProperty("bold"))
            object.bold = message.bold;
        if (message.italic != null && message.hasOwnProperty("italic"))
            object.italic = message.italic;
        if (message.strikethrough != null && message.hasOwnProperty("strikethrough"))
            object.strikethrough = message.strikethrough;
        if (message.underline != null && message.hasOwnProperty("underline"))
            object.underline = message.underline;
        return object;
    };

    /**
     * Converts this Formatting to JSON.
     * @function toJSON
     * @memberof Formatting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Formatting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Formatting;
})();

export const LinkData = $root.LinkData = (() => {

    /**
     * Properties of a LinkData.
     * @exports ILinkData
     * @interface ILinkData
     * @property {string|null} [linkTarget] LinkData linkTarget
     */

    /**
     * Constructs a new LinkData.
     * @exports LinkData
     * @classdesc Represents a LinkData.
     * @implements ILinkData
     * @constructor
     * @param {ILinkData=} [properties] Properties to set
     */
    function LinkData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * LinkData linkTarget.
     * @member {string} linkTarget
     * @memberof LinkData
     * @instance
     */
    LinkData.prototype.linkTarget = "";

    /**
     * Creates a new LinkData instance using the specified properties.
     * @function create
     * @memberof LinkData
     * @static
     * @param {ILinkData=} [properties] Properties to set
     * @returns {LinkData} LinkData instance
     */
    LinkData.create = function create(properties) {
        return new LinkData(properties);
    };

    /**
     * Encodes the specified LinkData message. Does not implicitly {@link LinkData.verify|verify} messages.
     * @function encode
     * @memberof LinkData
     * @static
     * @param {ILinkData} message LinkData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LinkData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.linkTarget != null && message.hasOwnProperty("linkTarget"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.linkTarget);
        return writer;
    };

    /**
     * Encodes the specified LinkData message, length delimited. Does not implicitly {@link LinkData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof LinkData
     * @static
     * @param {ILinkData} message LinkData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    LinkData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a LinkData message from the specified reader or buffer.
     * @function decode
     * @memberof LinkData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {LinkData} LinkData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LinkData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.LinkData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.linkTarget = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a LinkData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof LinkData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {LinkData} LinkData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    LinkData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a LinkData message.
     * @function verify
     * @memberof LinkData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    LinkData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.linkTarget != null && message.hasOwnProperty("linkTarget"))
            if (!$util.isString(message.linkTarget))
                return "linkTarget: string expected";
        return null;
    };

    /**
     * Creates a LinkData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof LinkData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {LinkData} LinkData
     */
    LinkData.fromObject = function fromObject(object) {
        if (object instanceof $root.LinkData)
            return object;
        let message = new $root.LinkData();
        if (object.linkTarget != null)
            message.linkTarget = String(object.linkTarget);
        return message;
    };

    /**
     * Creates a plain object from a LinkData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof LinkData
     * @static
     * @param {LinkData} message LinkData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    LinkData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.linkTarget = "";
        if (message.linkTarget != null && message.hasOwnProperty("linkTarget"))
            object.linkTarget = message.linkTarget;
        return object;
    };

    /**
     * Converts this LinkData to JSON.
     * @function toJSON
     * @memberof LinkData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    LinkData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return LinkData;
})();

export const Segment = $root.Segment = (() => {

    /**
     * Properties of a Segment.
     * @exports ISegment
     * @interface ISegment
     * @property {SegmentType} type Segment type
     * @property {string|null} [text] Segment text
     * @property {IFormatting|null} [formatting] Segment formatting
     * @property {ILinkData|null} [linkData] Segment linkData
     */

    /**
     * Constructs a new Segment.
     * @exports Segment
     * @classdesc Represents a Segment.
     * @implements ISegment
     * @constructor
     * @param {ISegment=} [properties] Properties to set
     */
    function Segment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Segment type.
     * @member {SegmentType} type
     * @memberof Segment
     * @instance
     */
    Segment.prototype.type = 0;

    /**
     * Segment text.
     * @member {string} text
     * @memberof Segment
     * @instance
     */
    Segment.prototype.text = "";

    /**
     * Segment formatting.
     * @member {IFormatting|null|undefined} formatting
     * @memberof Segment
     * @instance
     */
    Segment.prototype.formatting = null;

    /**
     * Segment linkData.
     * @member {ILinkData|null|undefined} linkData
     * @memberof Segment
     * @instance
     */
    Segment.prototype.linkData = null;

    /**
     * Creates a new Segment instance using the specified properties.
     * @function create
     * @memberof Segment
     * @static
     * @param {ISegment=} [properties] Properties to set
     * @returns {Segment} Segment instance
     */
    Segment.create = function create(properties) {
        return new Segment(properties);
    };

    /**
     * Encodes the specified Segment message. Does not implicitly {@link Segment.verify|verify} messages.
     * @function encode
     * @memberof Segment
     * @static
     * @param {ISegment} message Segment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Segment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.text != null && message.hasOwnProperty("text"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
        if (message.formatting != null && message.hasOwnProperty("formatting"))
            $root.Formatting.encode(message.formatting, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.linkData != null && message.hasOwnProperty("linkData"))
            $root.LinkData.encode(message.linkData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Segment message, length delimited. Does not implicitly {@link Segment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Segment
     * @static
     * @param {ISegment} message Segment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Segment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Segment message from the specified reader or buffer.
     * @function decode
     * @memberof Segment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Segment} Segment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Segment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Segment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.text = reader.string();
                break;
            case 3:
                message.formatting = $root.Formatting.decode(reader, reader.uint32());
                break;
            case 4:
                message.linkData = $root.LinkData.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("type"))
            throw $util.ProtocolError("missing required 'type'", { instance: message });
        return message;
    };

    /**
     * Decodes a Segment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Segment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Segment} Segment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Segment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Segment message.
     * @function verify
     * @memberof Segment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Segment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        switch (message.type) {
        default:
            return "type: enum value expected";
        case 0:
        case 1:
        case 2:
            break;
        }
        if (message.text != null && message.hasOwnProperty("text"))
            if (!$util.isString(message.text))
                return "text: string expected";
        if (message.formatting != null && message.hasOwnProperty("formatting")) {
            let error = $root.Formatting.verify(message.formatting);
            if (error)
                return "formatting." + error;
        }
        if (message.linkData != null && message.hasOwnProperty("linkData")) {
            let error = $root.LinkData.verify(message.linkData);
            if (error)
                return "linkData." + error;
        }
        return null;
    };

    /**
     * Creates a Segment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Segment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Segment} Segment
     */
    Segment.fromObject = function fromObject(object) {
        if (object instanceof $root.Segment)
            return object;
        let message = new $root.Segment();
        switch (object.type) {
        case "SEGMENT_TYPE_TEXT":
        case 0:
            message.type = 0;
            break;
        case "SEGMENT_TYPE_LINE_BREAK":
        case 1:
            message.type = 1;
            break;
        case "SEGMENT_TYPE_LINK":
        case 2:
            message.type = 2;
            break;
        }
        if (object.text != null)
            message.text = String(object.text);
        if (object.formatting != null) {
            if (typeof object.formatting !== "object")
                throw TypeError(".Segment.formatting: object expected");
            message.formatting = $root.Formatting.fromObject(object.formatting);
        }
        if (object.linkData != null) {
            if (typeof object.linkData !== "object")
                throw TypeError(".Segment.linkData: object expected");
            message.linkData = $root.LinkData.fromObject(object.linkData);
        }
        return message;
    };

    /**
     * Creates a plain object from a Segment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Segment
     * @static
     * @param {Segment} message Segment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Segment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "SEGMENT_TYPE_TEXT" : 0;
            object.text = "";
            object.formatting = null;
            object.linkData = null;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.SegmentType[message.type] : message.type;
        if (message.text != null && message.hasOwnProperty("text"))
            object.text = message.text;
        if (message.formatting != null && message.hasOwnProperty("formatting"))
            object.formatting = $root.Formatting.toObject(message.formatting, options);
        if (message.linkData != null && message.hasOwnProperty("linkData"))
            object.linkData = $root.LinkData.toObject(message.linkData, options);
        return object;
    };

    /**
     * Converts this Segment to JSON.
     * @function toJSON
     * @memberof Segment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Segment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Segment;
})();

/**
 * ItemType enum.
 * @exports ItemType
 * @enum {string}
 * @property {number} ITEM_TYPE_THING=0 ITEM_TYPE_THING value
 * @property {number} ITEM_TYPE_PLUS_PHOTO=249 ITEM_TYPE_PLUS_PHOTO value
 * @property {number} ITEM_TYPE_PLACE=335 ITEM_TYPE_PLACE value
 * @property {number} ITEM_TYPE_PLACE_V2=340 ITEM_TYPE_PLACE_V2 value
 */
$root.ItemType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "ITEM_TYPE_THING"] = 0;
    values[valuesById[249] = "ITEM_TYPE_PLUS_PHOTO"] = 249;
    values[valuesById[335] = "ITEM_TYPE_PLACE"] = 335;
    values[valuesById[340] = "ITEM_TYPE_PLACE_V2"] = 340;
    return values;
})();

export const PlusPhoto = $root.PlusPhoto = (() => {

    /**
     * Properties of a PlusPhoto.
     * @exports IPlusPhoto
     * @interface IPlusPhoto
     * @property {PlusPhoto.IThumbnail|null} [thumbnail] PlusPhoto thumbnail
     * @property {string|null} [ownerObfuscatedId] PlusPhoto ownerObfuscatedId
     * @property {string|null} [albumId] PlusPhoto albumId
     * @property {string|null} [photoId] PlusPhoto photoId
     * @property {string|null} [url] PlusPhoto url
     * @property {string|null} [originalContentUrl] PlusPhoto originalContentUrl
     * @property {PlusPhoto.MediaType|null} [mediaType] PlusPhoto mediaType
     * @property {Array.<string>|null} [streamId] PlusPhoto streamId
     */

    /**
     * Constructs a new PlusPhoto.
     * @exports PlusPhoto
     * @classdesc Represents a PlusPhoto.
     * @implements IPlusPhoto
     * @constructor
     * @param {IPlusPhoto=} [properties] Properties to set
     */
    function PlusPhoto(properties) {
        this.streamId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PlusPhoto thumbnail.
     * @member {PlusPhoto.IThumbnail|null|undefined} thumbnail
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.thumbnail = null;

    /**
     * PlusPhoto ownerObfuscatedId.
     * @member {string} ownerObfuscatedId
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.ownerObfuscatedId = "";

    /**
     * PlusPhoto albumId.
     * @member {string} albumId
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.albumId = "";

    /**
     * PlusPhoto photoId.
     * @member {string} photoId
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.photoId = "";

    /**
     * PlusPhoto url.
     * @member {string} url
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.url = "";

    /**
     * PlusPhoto originalContentUrl.
     * @member {string} originalContentUrl
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.originalContentUrl = "";

    /**
     * PlusPhoto mediaType.
     * @member {PlusPhoto.MediaType} mediaType
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.mediaType = 0;

    /**
     * PlusPhoto streamId.
     * @member {Array.<string>} streamId
     * @memberof PlusPhoto
     * @instance
     */
    PlusPhoto.prototype.streamId = $util.emptyArray;

    /**
     * Creates a new PlusPhoto instance using the specified properties.
     * @function create
     * @memberof PlusPhoto
     * @static
     * @param {IPlusPhoto=} [properties] Properties to set
     * @returns {PlusPhoto} PlusPhoto instance
     */
    PlusPhoto.create = function create(properties) {
        return new PlusPhoto(properties);
    };

    /**
     * Encodes the specified PlusPhoto message. Does not implicitly {@link PlusPhoto.verify|verify} messages.
     * @function encode
     * @memberof PlusPhoto
     * @static
     * @param {IPlusPhoto} message PlusPhoto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusPhoto.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
            $root.PlusPhoto.Thumbnail.encode(message.thumbnail, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.ownerObfuscatedId != null && message.hasOwnProperty("ownerObfuscatedId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.ownerObfuscatedId);
        if (message.albumId != null && message.hasOwnProperty("albumId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.albumId);
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.photoId);
        if (message.url != null && message.hasOwnProperty("url"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.url);
        if (message.originalContentUrl != null && message.hasOwnProperty("originalContentUrl"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.originalContentUrl);
        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.mediaType);
        if (message.streamId != null && message.streamId.length)
            for (let i = 0; i < message.streamId.length; ++i)
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.streamId[i]);
        return writer;
    };

    /**
     * Encodes the specified PlusPhoto message, length delimited. Does not implicitly {@link PlusPhoto.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PlusPhoto
     * @static
     * @param {IPlusPhoto} message PlusPhoto message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PlusPhoto.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PlusPhoto message from the specified reader or buffer.
     * @function decode
     * @memberof PlusPhoto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlusPhoto} PlusPhoto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusPhoto.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlusPhoto();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.thumbnail = $root.PlusPhoto.Thumbnail.decode(reader, reader.uint32());
                break;
            case 2:
                message.ownerObfuscatedId = reader.string();
                break;
            case 3:
                message.albumId = reader.string();
                break;
            case 4:
                message.photoId = reader.string();
                break;
            case 6:
                message.url = reader.string();
                break;
            case 10:
                message.originalContentUrl = reader.string();
                break;
            case 13:
                message.mediaType = reader.int32();
                break;
            case 14:
                if (!(message.streamId && message.streamId.length))
                    message.streamId = [];
                message.streamId.push(reader.string());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PlusPhoto message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PlusPhoto
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PlusPhoto} PlusPhoto
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlusPhoto.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PlusPhoto message.
     * @function verify
     * @memberof PlusPhoto
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PlusPhoto.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail")) {
            let error = $root.PlusPhoto.Thumbnail.verify(message.thumbnail);
            if (error)
                return "thumbnail." + error;
        }
        if (message.ownerObfuscatedId != null && message.hasOwnProperty("ownerObfuscatedId"))
            if (!$util.isString(message.ownerObfuscatedId))
                return "ownerObfuscatedId: string expected";
        if (message.albumId != null && message.hasOwnProperty("albumId"))
            if (!$util.isString(message.albumId))
                return "albumId: string expected";
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            if (!$util.isString(message.photoId))
                return "photoId: string expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.originalContentUrl != null && message.hasOwnProperty("originalContentUrl"))
            if (!$util.isString(message.originalContentUrl))
                return "originalContentUrl: string expected";
        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
            switch (message.mediaType) {
            default:
                return "mediaType: enum value expected";
            case 0:
            case 1:
            case 4:
                break;
            }
        if (message.streamId != null && message.hasOwnProperty("streamId")) {
            if (!Array.isArray(message.streamId))
                return "streamId: array expected";
            for (let i = 0; i < message.streamId.length; ++i)
                if (!$util.isString(message.streamId[i]))
                    return "streamId: string[] expected";
        }
        return null;
    };

    /**
     * Creates a PlusPhoto message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PlusPhoto
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PlusPhoto} PlusPhoto
     */
    PlusPhoto.fromObject = function fromObject(object) {
        if (object instanceof $root.PlusPhoto)
            return object;
        let message = new $root.PlusPhoto();
        if (object.thumbnail != null) {
            if (typeof object.thumbnail !== "object")
                throw TypeError(".PlusPhoto.thumbnail: object expected");
            message.thumbnail = $root.PlusPhoto.Thumbnail.fromObject(object.thumbnail);
        }
        if (object.ownerObfuscatedId != null)
            message.ownerObfuscatedId = String(object.ownerObfuscatedId);
        if (object.albumId != null)
            message.albumId = String(object.albumId);
        if (object.photoId != null)
            message.photoId = String(object.photoId);
        if (object.url != null)
            message.url = String(object.url);
        if (object.originalContentUrl != null)
            message.originalContentUrl = String(object.originalContentUrl);
        switch (object.mediaType) {
        case "MEDIA_TYPE_UNKNOWN":
        case 0:
            message.mediaType = 0;
            break;
        case "MEDIA_TYPE_PHOTO":
        case 1:
            message.mediaType = 1;
            break;
        case "MEDIA_TYPE_ANIMATED_PHOTO":
        case 4:
            message.mediaType = 4;
            break;
        }
        if (object.streamId) {
            if (!Array.isArray(object.streamId))
                throw TypeError(".PlusPhoto.streamId: array expected");
            message.streamId = [];
            for (let i = 0; i < object.streamId.length; ++i)
                message.streamId[i] = String(object.streamId[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a PlusPhoto message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PlusPhoto
     * @static
     * @param {PlusPhoto} message PlusPhoto
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PlusPhoto.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.streamId = [];
        if (options.defaults) {
            object.thumbnail = null;
            object.ownerObfuscatedId = "";
            object.albumId = "";
            object.photoId = "";
            object.url = "";
            object.originalContentUrl = "";
            object.mediaType = options.enums === String ? "MEDIA_TYPE_UNKNOWN" : 0;
        }
        if (message.thumbnail != null && message.hasOwnProperty("thumbnail"))
            object.thumbnail = $root.PlusPhoto.Thumbnail.toObject(message.thumbnail, options);
        if (message.ownerObfuscatedId != null && message.hasOwnProperty("ownerObfuscatedId"))
            object.ownerObfuscatedId = message.ownerObfuscatedId;
        if (message.albumId != null && message.hasOwnProperty("albumId"))
            object.albumId = message.albumId;
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            object.photoId = message.photoId;
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.originalContentUrl != null && message.hasOwnProperty("originalContentUrl"))
            object.originalContentUrl = message.originalContentUrl;
        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
            object.mediaType = options.enums === String ? $root.PlusPhoto.MediaType[message.mediaType] : message.mediaType;
        if (message.streamId && message.streamId.length) {
            object.streamId = [];
            for (let j = 0; j < message.streamId.length; ++j)
                object.streamId[j] = message.streamId[j];
        }
        return object;
    };

    /**
     * Converts this PlusPhoto to JSON.
     * @function toJSON
     * @memberof PlusPhoto
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PlusPhoto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    PlusPhoto.Thumbnail = (function() {

        /**
         * Properties of a Thumbnail.
         * @memberof PlusPhoto
         * @interface IThumbnail
         * @property {string|null} [url] Thumbnail url
         * @property {string|null} [imageUrl] Thumbnail imageUrl
         * @property {number|Long|null} [widthPx] Thumbnail widthPx
         * @property {number|Long|null} [heightPx] Thumbnail heightPx
         */

        /**
         * Constructs a new Thumbnail.
         * @memberof PlusPhoto
         * @classdesc Represents a Thumbnail.
         * @implements IThumbnail
         * @constructor
         * @param {PlusPhoto.IThumbnail=} [properties] Properties to set
         */
        function Thumbnail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Thumbnail url.
         * @member {string} url
         * @memberof PlusPhoto.Thumbnail
         * @instance
         */
        Thumbnail.prototype.url = "";

        /**
         * Thumbnail imageUrl.
         * @member {string} imageUrl
         * @memberof PlusPhoto.Thumbnail
         * @instance
         */
        Thumbnail.prototype.imageUrl = "";

        /**
         * Thumbnail widthPx.
         * @member {number|Long} widthPx
         * @memberof PlusPhoto.Thumbnail
         * @instance
         */
        Thumbnail.prototype.widthPx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Thumbnail heightPx.
         * @member {number|Long} heightPx
         * @memberof PlusPhoto.Thumbnail
         * @instance
         */
        Thumbnail.prototype.heightPx = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Thumbnail instance using the specified properties.
         * @function create
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {PlusPhoto.IThumbnail=} [properties] Properties to set
         * @returns {PlusPhoto.Thumbnail} Thumbnail instance
         */
        Thumbnail.create = function create(properties) {
            return new Thumbnail(properties);
        };

        /**
         * Encodes the specified Thumbnail message. Does not implicitly {@link PlusPhoto.Thumbnail.verify|verify} messages.
         * @function encode
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {PlusPhoto.IThumbnail} message Thumbnail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Thumbnail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.imageUrl);
            if (message.widthPx != null && message.hasOwnProperty("widthPx"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.widthPx);
            if (message.heightPx != null && message.hasOwnProperty("heightPx"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.heightPx);
            return writer;
        };

        /**
         * Encodes the specified Thumbnail message, length delimited. Does not implicitly {@link PlusPhoto.Thumbnail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {PlusPhoto.IThumbnail} message Thumbnail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Thumbnail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Thumbnail message from the specified reader or buffer.
         * @function decode
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PlusPhoto.Thumbnail} Thumbnail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Thumbnail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlusPhoto.Thumbnail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 4:
                    message.imageUrl = reader.string();
                    break;
                case 10:
                    message.widthPx = reader.uint64();
                    break;
                case 11:
                    message.heightPx = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Thumbnail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PlusPhoto.Thumbnail} Thumbnail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Thumbnail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Thumbnail message.
         * @function verify
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Thumbnail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                if (!$util.isString(message.imageUrl))
                    return "imageUrl: string expected";
            if (message.widthPx != null && message.hasOwnProperty("widthPx"))
                if (!$util.isInteger(message.widthPx) && !(message.widthPx && $util.isInteger(message.widthPx.low) && $util.isInteger(message.widthPx.high)))
                    return "widthPx: integer|Long expected";
            if (message.heightPx != null && message.hasOwnProperty("heightPx"))
                if (!$util.isInteger(message.heightPx) && !(message.heightPx && $util.isInteger(message.heightPx.low) && $util.isInteger(message.heightPx.high)))
                    return "heightPx: integer|Long expected";
            return null;
        };

        /**
         * Creates a Thumbnail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PlusPhoto.Thumbnail} Thumbnail
         */
        Thumbnail.fromObject = function fromObject(object) {
            if (object instanceof $root.PlusPhoto.Thumbnail)
                return object;
            let message = new $root.PlusPhoto.Thumbnail();
            if (object.url != null)
                message.url = String(object.url);
            if (object.imageUrl != null)
                message.imageUrl = String(object.imageUrl);
            if (object.widthPx != null)
                if ($util.Long)
                    (message.widthPx = $util.Long.fromValue(object.widthPx)).unsigned = true;
                else if (typeof object.widthPx === "string")
                    message.widthPx = parseInt(object.widthPx, 10);
                else if (typeof object.widthPx === "number")
                    message.widthPx = object.widthPx;
                else if (typeof object.widthPx === "object")
                    message.widthPx = new $util.LongBits(object.widthPx.low >>> 0, object.widthPx.high >>> 0).toNumber(true);
            if (object.heightPx != null)
                if ($util.Long)
                    (message.heightPx = $util.Long.fromValue(object.heightPx)).unsigned = true;
                else if (typeof object.heightPx === "string")
                    message.heightPx = parseInt(object.heightPx, 10);
                else if (typeof object.heightPx === "number")
                    message.heightPx = object.heightPx;
                else if (typeof object.heightPx === "object")
                    message.heightPx = new $util.LongBits(object.heightPx.low >>> 0, object.heightPx.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a Thumbnail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PlusPhoto.Thumbnail
         * @static
         * @param {PlusPhoto.Thumbnail} message Thumbnail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Thumbnail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.url = "";
                object.imageUrl = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.widthPx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.widthPx = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.heightPx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.heightPx = options.longs === String ? "0" : 0;
            }
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                object.imageUrl = message.imageUrl;
            if (message.widthPx != null && message.hasOwnProperty("widthPx"))
                if (typeof message.widthPx === "number")
                    object.widthPx = options.longs === String ? String(message.widthPx) : message.widthPx;
                else
                    object.widthPx = options.longs === String ? $util.Long.prototype.toString.call(message.widthPx) : options.longs === Number ? new $util.LongBits(message.widthPx.low >>> 0, message.widthPx.high >>> 0).toNumber(true) : message.widthPx;
            if (message.heightPx != null && message.hasOwnProperty("heightPx"))
                if (typeof message.heightPx === "number")
                    object.heightPx = options.longs === String ? String(message.heightPx) : message.heightPx;
                else
                    object.heightPx = options.longs === String ? $util.Long.prototype.toString.call(message.heightPx) : options.longs === Number ? new $util.LongBits(message.heightPx.low >>> 0, message.heightPx.high >>> 0).toNumber(true) : message.heightPx;
            return object;
        };

        /**
         * Converts this Thumbnail to JSON.
         * @function toJSON
         * @memberof PlusPhoto.Thumbnail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Thumbnail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Thumbnail;
    })();

    /**
     * MediaType enum.
     * @name PlusPhoto.MediaType
     * @enum {string}
     * @property {number} MEDIA_TYPE_UNKNOWN=0 MEDIA_TYPE_UNKNOWN value
     * @property {number} MEDIA_TYPE_PHOTO=1 MEDIA_TYPE_PHOTO value
     * @property {number} MEDIA_TYPE_ANIMATED_PHOTO=4 MEDIA_TYPE_ANIMATED_PHOTO value
     */
    PlusPhoto.MediaType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MEDIA_TYPE_UNKNOWN"] = 0;
        values[valuesById[1] = "MEDIA_TYPE_PHOTO"] = 1;
        values[valuesById[4] = "MEDIA_TYPE_ANIMATED_PHOTO"] = 4;
        return values;
    })();

    return PlusPhoto;
})();

export const Place = $root.Place = (() => {

    /**
     * Properties of a Place.
     * @exports IPlace
     * @interface IPlace
     * @property {string|null} [url] Place url
     * @property {string|null} [name] Place name
     * @property {IEmbedItem|null} [address] Place address
     * @property {IEmbedItem|null} [geo] Place geo
     * @property {IEmbedItem|null} [representativeImage] Place representativeImage
     */

    /**
     * Constructs a new Place.
     * @exports Place
     * @classdesc Represents a Place.
     * @implements IPlace
     * @constructor
     * @param {IPlace=} [properties] Properties to set
     */
    function Place(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Place url.
     * @member {string} url
     * @memberof Place
     * @instance
     */
    Place.prototype.url = "";

    /**
     * Place name.
     * @member {string} name
     * @memberof Place
     * @instance
     */
    Place.prototype.name = "";

    /**
     * Place address.
     * @member {IEmbedItem|null|undefined} address
     * @memberof Place
     * @instance
     */
    Place.prototype.address = null;

    /**
     * Place geo.
     * @member {IEmbedItem|null|undefined} geo
     * @memberof Place
     * @instance
     */
    Place.prototype.geo = null;

    /**
     * Place representativeImage.
     * @member {IEmbedItem|null|undefined} representativeImage
     * @memberof Place
     * @instance
     */
    Place.prototype.representativeImage = null;

    /**
     * Creates a new Place instance using the specified properties.
     * @function create
     * @memberof Place
     * @static
     * @param {IPlace=} [properties] Properties to set
     * @returns {Place} Place instance
     */
    Place.create = function create(properties) {
        return new Place(properties);
    };

    /**
     * Encodes the specified Place message. Does not implicitly {@link Place.verify|verify} messages.
     * @function encode
     * @memberof Place
     * @static
     * @param {IPlace} message Place message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Place.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.url != null && message.hasOwnProperty("url"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.address != null && message.hasOwnProperty("address"))
            $root.EmbedItem.encode(message.address, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
        if (message.geo != null && message.hasOwnProperty("geo"))
            $root.EmbedItem.encode(message.geo, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
        if (message.representativeImage != null && message.hasOwnProperty("representativeImage"))
            $root.EmbedItem.encode(message.representativeImage, writer.uint32(/* id 185, wireType 2 =*/1482).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Place message, length delimited. Does not implicitly {@link Place.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Place
     * @static
     * @param {IPlace} message Place message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Place.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Place message from the specified reader or buffer.
     * @function decode
     * @memberof Place
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Place} Place
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Place.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Place();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.url = reader.string();
                break;
            case 3:
                message.name = reader.string();
                break;
            case 24:
                message.address = $root.EmbedItem.decode(reader, reader.uint32());
                break;
            case 25:
                message.geo = $root.EmbedItem.decode(reader, reader.uint32());
                break;
            case 185:
                message.representativeImage = $root.EmbedItem.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Place message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Place
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Place} Place
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Place.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Place message.
     * @function verify
     * @memberof Place
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Place.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.url != null && message.hasOwnProperty("url"))
            if (!$util.isString(message.url))
                return "url: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.address != null && message.hasOwnProperty("address")) {
            let error = $root.EmbedItem.verify(message.address);
            if (error)
                return "address." + error;
        }
        if (message.geo != null && message.hasOwnProperty("geo")) {
            let error = $root.EmbedItem.verify(message.geo);
            if (error)
                return "geo." + error;
        }
        if (message.representativeImage != null && message.hasOwnProperty("representativeImage")) {
            let error = $root.EmbedItem.verify(message.representativeImage);
            if (error)
                return "representativeImage." + error;
        }
        return null;
    };

    /**
     * Creates a Place message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Place
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Place} Place
     */
    Place.fromObject = function fromObject(object) {
        if (object instanceof $root.Place)
            return object;
        let message = new $root.Place();
        if (object.url != null)
            message.url = String(object.url);
        if (object.name != null)
            message.name = String(object.name);
        if (object.address != null) {
            if (typeof object.address !== "object")
                throw TypeError(".Place.address: object expected");
            message.address = $root.EmbedItem.fromObject(object.address);
        }
        if (object.geo != null) {
            if (typeof object.geo !== "object")
                throw TypeError(".Place.geo: object expected");
            message.geo = $root.EmbedItem.fromObject(object.geo);
        }
        if (object.representativeImage != null) {
            if (typeof object.representativeImage !== "object")
                throw TypeError(".Place.representativeImage: object expected");
            message.representativeImage = $root.EmbedItem.fromObject(object.representativeImage);
        }
        return message;
    };

    /**
     * Creates a plain object from a Place message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Place
     * @static
     * @param {Place} message Place
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Place.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.url = "";
            object.name = "";
            object.address = null;
            object.geo = null;
            object.representativeImage = null;
        }
        if (message.url != null && message.hasOwnProperty("url"))
            object.url = message.url;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.address != null && message.hasOwnProperty("address"))
            object.address = $root.EmbedItem.toObject(message.address, options);
        if (message.geo != null && message.hasOwnProperty("geo"))
            object.geo = $root.EmbedItem.toObject(message.geo, options);
        if (message.representativeImage != null && message.hasOwnProperty("representativeImage"))
            object.representativeImage = $root.EmbedItem.toObject(message.representativeImage, options);
        return object;
    };

    /**
     * Converts this Place to JSON.
     * @function toJSON
     * @memberof Place
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Place.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Place;
})();

export const EmbedItem = $root.EmbedItem = (() => {

    /**
     * Properties of an EmbedItem.
     * @exports IEmbedItem
     * @interface IEmbedItem
     * @property {Array.<ItemType>|null} [type] EmbedItem type
     * @property {string|null} [id] EmbedItem id
     * @property {IPlusPhoto|null} [plusPhoto] EmbedItem plusPhoto
     * @property {IPlace|null} [place] EmbedItem place
     * @property {EmbedItem.IPostalAddress|null} [postalAddress] EmbedItem postalAddress
     * @property {EmbedItem.IGeoCoordinates|null} [geoCoordinates] EmbedItem geoCoordinates
     * @property {EmbedItem.IImage|null} [image] EmbedItem image
     */

    /**
     * Constructs a new EmbedItem.
     * @exports EmbedItem
     * @classdesc Represents an EmbedItem.
     * @implements IEmbedItem
     * @constructor
     * @param {IEmbedItem=} [properties] Properties to set
     */
    function EmbedItem(properties) {
        this.type = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EmbedItem type.
     * @member {Array.<ItemType>} type
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.type = $util.emptyArray;

    /**
     * EmbedItem id.
     * @member {string} id
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.id = "";

    /**
     * EmbedItem plusPhoto.
     * @member {IPlusPhoto|null|undefined} plusPhoto
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.plusPhoto = null;

    /**
     * EmbedItem place.
     * @member {IPlace|null|undefined} place
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.place = null;

    /**
     * EmbedItem postalAddress.
     * @member {EmbedItem.IPostalAddress|null|undefined} postalAddress
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.postalAddress = null;

    /**
     * EmbedItem geoCoordinates.
     * @member {EmbedItem.IGeoCoordinates|null|undefined} geoCoordinates
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.geoCoordinates = null;

    /**
     * EmbedItem image.
     * @member {EmbedItem.IImage|null|undefined} image
     * @memberof EmbedItem
     * @instance
     */
    EmbedItem.prototype.image = null;

    /**
     * Creates a new EmbedItem instance using the specified properties.
     * @function create
     * @memberof EmbedItem
     * @static
     * @param {IEmbedItem=} [properties] Properties to set
     * @returns {EmbedItem} EmbedItem instance
     */
    EmbedItem.create = function create(properties) {
        return new EmbedItem(properties);
    };

    /**
     * Encodes the specified EmbedItem message. Does not implicitly {@link EmbedItem.verify|verify} messages.
     * @function encode
     * @memberof EmbedItem
     * @static
     * @param {IEmbedItem} message EmbedItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmbedItem.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.type.length)
            for (let i = 0; i < message.type.length; ++i)
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type[i]);
        if (message.id != null && message.hasOwnProperty("id"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
        if (message.plusPhoto != null && message.hasOwnProperty("plusPhoto"))
            $root.PlusPhoto.encode(message.plusPhoto, writer.uint32(/* id 27639957, wireType 2 =*/221119658).fork()).ldelim();
        if (message.place != null && message.hasOwnProperty("place"))
            $root.Place.encode(message.place, writer.uint32(/* id 35825640, wireType 2 =*/286605122).fork()).ldelim();
        if (message.postalAddress != null && message.hasOwnProperty("postalAddress"))
            $root.EmbedItem.PostalAddress.encode(message.postalAddress, writer.uint32(/* id 36003298, wireType 2 =*/288026386).fork()).ldelim();
        if (message.geoCoordinates != null && message.hasOwnProperty("geoCoordinates"))
            $root.EmbedItem.GeoCoordinates.encode(message.geoCoordinates, writer.uint32(/* id 36736749, wireType 2 =*/293893994).fork()).ldelim();
        if (message.image != null && message.hasOwnProperty("image"))
            $root.EmbedItem.Image.encode(message.image, writer.uint32(/* id 40265033, wireType 2 =*/322120266).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EmbedItem message, length delimited. Does not implicitly {@link EmbedItem.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EmbedItem
     * @static
     * @param {IEmbedItem} message EmbedItem message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EmbedItem.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EmbedItem message from the specified reader or buffer.
     * @function decode
     * @memberof EmbedItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EmbedItem} EmbedItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmbedItem.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmbedItem();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.type && message.type.length))
                    message.type = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.type.push(reader.int32());
                } else
                    message.type.push(reader.int32());
                break;
            case 2:
                message.id = reader.string();
                break;
            case 27639957:
                message.plusPhoto = $root.PlusPhoto.decode(reader, reader.uint32());
                break;
            case 35825640:
                message.place = $root.Place.decode(reader, reader.uint32());
                break;
            case 36003298:
                message.postalAddress = $root.EmbedItem.PostalAddress.decode(reader, reader.uint32());
                break;
            case 36736749:
                message.geoCoordinates = $root.EmbedItem.GeoCoordinates.decode(reader, reader.uint32());
                break;
            case 40265033:
                message.image = $root.EmbedItem.Image.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EmbedItem message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EmbedItem
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EmbedItem} EmbedItem
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EmbedItem.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EmbedItem message.
     * @function verify
     * @memberof EmbedItem
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EmbedItem.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type")) {
            if (!Array.isArray(message.type))
                return "type: array expected";
            for (let i = 0; i < message.type.length; ++i)
                switch (message.type[i]) {
                default:
                    return "type: enum value[] expected";
                case 0:
                case 249:
                case 335:
                case 340:
                    break;
                }
        }
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isString(message.id))
                return "id: string expected";
        if (message.plusPhoto != null && message.hasOwnProperty("plusPhoto")) {
            let error = $root.PlusPhoto.verify(message.plusPhoto);
            if (error)
                return "plusPhoto." + error;
        }
        if (message.place != null && message.hasOwnProperty("place")) {
            let error = $root.Place.verify(message.place);
            if (error)
                return "place." + error;
        }
        if (message.postalAddress != null && message.hasOwnProperty("postalAddress")) {
            let error = $root.EmbedItem.PostalAddress.verify(message.postalAddress);
            if (error)
                return "postalAddress." + error;
        }
        if (message.geoCoordinates != null && message.hasOwnProperty("geoCoordinates")) {
            let error = $root.EmbedItem.GeoCoordinates.verify(message.geoCoordinates);
            if (error)
                return "geoCoordinates." + error;
        }
        if (message.image != null && message.hasOwnProperty("image")) {
            let error = $root.EmbedItem.Image.verify(message.image);
            if (error)
                return "image." + error;
        }
        return null;
    };

    /**
     * Creates an EmbedItem message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EmbedItem
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EmbedItem} EmbedItem
     */
    EmbedItem.fromObject = function fromObject(object) {
        if (object instanceof $root.EmbedItem)
            return object;
        let message = new $root.EmbedItem();
        if (object.type) {
            if (!Array.isArray(object.type))
                throw TypeError(".EmbedItem.type: array expected");
            message.type = [];
            for (let i = 0; i < object.type.length; ++i)
                switch (object.type[i]) {
                default:
                case "ITEM_TYPE_THING":
                case 0:
                    message.type[i] = 0;
                    break;
                case "ITEM_TYPE_PLUS_PHOTO":
                case 249:
                    message.type[i] = 249;
                    break;
                case "ITEM_TYPE_PLACE":
                case 335:
                    message.type[i] = 335;
                    break;
                case "ITEM_TYPE_PLACE_V2":
                case 340:
                    message.type[i] = 340;
                    break;
                }
        }
        if (object.id != null)
            message.id = String(object.id);
        if (object.plusPhoto != null) {
            if (typeof object.plusPhoto !== "object")
                throw TypeError(".EmbedItem.plusPhoto: object expected");
            message.plusPhoto = $root.PlusPhoto.fromObject(object.plusPhoto);
        }
        if (object.place != null) {
            if (typeof object.place !== "object")
                throw TypeError(".EmbedItem.place: object expected");
            message.place = $root.Place.fromObject(object.place);
        }
        if (object.postalAddress != null) {
            if (typeof object.postalAddress !== "object")
                throw TypeError(".EmbedItem.postalAddress: object expected");
            message.postalAddress = $root.EmbedItem.PostalAddress.fromObject(object.postalAddress);
        }
        if (object.geoCoordinates != null) {
            if (typeof object.geoCoordinates !== "object")
                throw TypeError(".EmbedItem.geoCoordinates: object expected");
            message.geoCoordinates = $root.EmbedItem.GeoCoordinates.fromObject(object.geoCoordinates);
        }
        if (object.image != null) {
            if (typeof object.image !== "object")
                throw TypeError(".EmbedItem.image: object expected");
            message.image = $root.EmbedItem.Image.fromObject(object.image);
        }
        return message;
    };

    /**
     * Creates a plain object from an EmbedItem message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EmbedItem
     * @static
     * @param {EmbedItem} message EmbedItem
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EmbedItem.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.type = [];
        if (options.defaults) {
            object.id = "";
            object.plusPhoto = null;
            object.place = null;
            object.postalAddress = null;
            object.geoCoordinates = null;
            object.image = null;
        }
        if (message.type && message.type.length) {
            object.type = [];
            for (let j = 0; j < message.type.length; ++j)
                object.type[j] = options.enums === String ? $root.ItemType[message.type[j]] : message.type[j];
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.plusPhoto != null && message.hasOwnProperty("plusPhoto"))
            object.plusPhoto = $root.PlusPhoto.toObject(message.plusPhoto, options);
        if (message.place != null && message.hasOwnProperty("place"))
            object.place = $root.Place.toObject(message.place, options);
        if (message.postalAddress != null && message.hasOwnProperty("postalAddress"))
            object.postalAddress = $root.EmbedItem.PostalAddress.toObject(message.postalAddress, options);
        if (message.geoCoordinates != null && message.hasOwnProperty("geoCoordinates"))
            object.geoCoordinates = $root.EmbedItem.GeoCoordinates.toObject(message.geoCoordinates, options);
        if (message.image != null && message.hasOwnProperty("image"))
            object.image = $root.EmbedItem.Image.toObject(message.image, options);
        return object;
    };

    /**
     * Converts this EmbedItem to JSON.
     * @function toJSON
     * @memberof EmbedItem
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EmbedItem.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    EmbedItem.PostalAddress = (function() {

        /**
         * Properties of a PostalAddress.
         * @memberof EmbedItem
         * @interface IPostalAddress
         * @property {string|null} [streetAddress] PostalAddress streetAddress
         */

        /**
         * Constructs a new PostalAddress.
         * @memberof EmbedItem
         * @classdesc Represents a PostalAddress.
         * @implements IPostalAddress
         * @constructor
         * @param {EmbedItem.IPostalAddress=} [properties] Properties to set
         */
        function PostalAddress(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PostalAddress streetAddress.
         * @member {string} streetAddress
         * @memberof EmbedItem.PostalAddress
         * @instance
         */
        PostalAddress.prototype.streetAddress = "";

        /**
         * Creates a new PostalAddress instance using the specified properties.
         * @function create
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {EmbedItem.IPostalAddress=} [properties] Properties to set
         * @returns {EmbedItem.PostalAddress} PostalAddress instance
         */
        PostalAddress.create = function create(properties) {
            return new PostalAddress(properties);
        };

        /**
         * Encodes the specified PostalAddress message. Does not implicitly {@link EmbedItem.PostalAddress.verify|verify} messages.
         * @function encode
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {EmbedItem.IPostalAddress} message PostalAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostalAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.streetAddress != null && message.hasOwnProperty("streetAddress"))
                writer.uint32(/* id 35, wireType 2 =*/282).string(message.streetAddress);
            return writer;
        };

        /**
         * Encodes the specified PostalAddress message, length delimited. Does not implicitly {@link EmbedItem.PostalAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {EmbedItem.IPostalAddress} message PostalAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PostalAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PostalAddress message from the specified reader or buffer.
         * @function decode
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EmbedItem.PostalAddress} PostalAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostalAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmbedItem.PostalAddress();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 35:
                    message.streetAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PostalAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EmbedItem.PostalAddress} PostalAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PostalAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PostalAddress message.
         * @function verify
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PostalAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.streetAddress != null && message.hasOwnProperty("streetAddress"))
                if (!$util.isString(message.streetAddress))
                    return "streetAddress: string expected";
            return null;
        };

        /**
         * Creates a PostalAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EmbedItem.PostalAddress} PostalAddress
         */
        PostalAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.EmbedItem.PostalAddress)
                return object;
            let message = new $root.EmbedItem.PostalAddress();
            if (object.streetAddress != null)
                message.streetAddress = String(object.streetAddress);
            return message;
        };

        /**
         * Creates a plain object from a PostalAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EmbedItem.PostalAddress
         * @static
         * @param {EmbedItem.PostalAddress} message PostalAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PostalAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.streetAddress = "";
            if (message.streetAddress != null && message.hasOwnProperty("streetAddress"))
                object.streetAddress = message.streetAddress;
            return object;
        };

        /**
         * Converts this PostalAddress to JSON.
         * @function toJSON
         * @memberof EmbedItem.PostalAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PostalAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PostalAddress;
    })();

    EmbedItem.GeoCoordinates = (function() {

        /**
         * Properties of a GeoCoordinates.
         * @memberof EmbedItem
         * @interface IGeoCoordinates
         * @property {number|null} [latitude] GeoCoordinates latitude
         * @property {number|null} [longitude] GeoCoordinates longitude
         */

        /**
         * Constructs a new GeoCoordinates.
         * @memberof EmbedItem
         * @classdesc Represents a GeoCoordinates.
         * @implements IGeoCoordinates
         * @constructor
         * @param {EmbedItem.IGeoCoordinates=} [properties] Properties to set
         */
        function GeoCoordinates(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GeoCoordinates latitude.
         * @member {number} latitude
         * @memberof EmbedItem.GeoCoordinates
         * @instance
         */
        GeoCoordinates.prototype.latitude = 0;

        /**
         * GeoCoordinates longitude.
         * @member {number} longitude
         * @memberof EmbedItem.GeoCoordinates
         * @instance
         */
        GeoCoordinates.prototype.longitude = 0;

        /**
         * Creates a new GeoCoordinates instance using the specified properties.
         * @function create
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {EmbedItem.IGeoCoordinates=} [properties] Properties to set
         * @returns {EmbedItem.GeoCoordinates} GeoCoordinates instance
         */
        GeoCoordinates.create = function create(properties) {
            return new GeoCoordinates(properties);
        };

        /**
         * Encodes the specified GeoCoordinates message. Does not implicitly {@link EmbedItem.GeoCoordinates.verify|verify} messages.
         * @function encode
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {EmbedItem.IGeoCoordinates} message GeoCoordinates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeoCoordinates.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                writer.uint32(/* id 36, wireType 1 =*/289).double(message.latitude);
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                writer.uint32(/* id 37, wireType 1 =*/297).double(message.longitude);
            return writer;
        };

        /**
         * Encodes the specified GeoCoordinates message, length delimited. Does not implicitly {@link EmbedItem.GeoCoordinates.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {EmbedItem.IGeoCoordinates} message GeoCoordinates message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeoCoordinates.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GeoCoordinates message from the specified reader or buffer.
         * @function decode
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EmbedItem.GeoCoordinates} GeoCoordinates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeoCoordinates.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmbedItem.GeoCoordinates();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 36:
                    message.latitude = reader.double();
                    break;
                case 37:
                    message.longitude = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GeoCoordinates message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EmbedItem.GeoCoordinates} GeoCoordinates
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeoCoordinates.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GeoCoordinates message.
         * @function verify
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GeoCoordinates.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (typeof message.latitude !== "number")
                    return "latitude: number expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (typeof message.longitude !== "number")
                    return "longitude: number expected";
            return null;
        };

        /**
         * Creates a GeoCoordinates message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EmbedItem.GeoCoordinates} GeoCoordinates
         */
        GeoCoordinates.fromObject = function fromObject(object) {
            if (object instanceof $root.EmbedItem.GeoCoordinates)
                return object;
            let message = new $root.EmbedItem.GeoCoordinates();
            if (object.latitude != null)
                message.latitude = Number(object.latitude);
            if (object.longitude != null)
                message.longitude = Number(object.longitude);
            return message;
        };

        /**
         * Creates a plain object from a GeoCoordinates message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EmbedItem.GeoCoordinates
         * @static
         * @param {EmbedItem.GeoCoordinates} message GeoCoordinates
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GeoCoordinates.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.latitude = 0;
                object.longitude = 0;
            }
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
            return object;
        };

        /**
         * Converts this GeoCoordinates to JSON.
         * @function toJSON
         * @memberof EmbedItem.GeoCoordinates
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GeoCoordinates.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GeoCoordinates;
    })();

    EmbedItem.Image = (function() {

        /**
         * Properties of an Image.
         * @memberof EmbedItem
         * @interface IImage
         * @property {string|null} [url] Image url
         */

        /**
         * Constructs a new Image.
         * @memberof EmbedItem
         * @classdesc Represents an Image.
         * @implements IImage
         * @constructor
         * @param {EmbedItem.IImage=} [properties] Properties to set
         */
        function Image(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Image url.
         * @member {string} url
         * @memberof EmbedItem.Image
         * @instance
         */
        Image.prototype.url = "";

        /**
         * Creates a new Image instance using the specified properties.
         * @function create
         * @memberof EmbedItem.Image
         * @static
         * @param {EmbedItem.IImage=} [properties] Properties to set
         * @returns {EmbedItem.Image} Image instance
         */
        Image.create = function create(properties) {
            return new Image(properties);
        };

        /**
         * Encodes the specified Image message. Does not implicitly {@link EmbedItem.Image.verify|verify} messages.
         * @function encode
         * @memberof EmbedItem.Image
         * @static
         * @param {EmbedItem.IImage} message Image message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Image.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified Image message, length delimited. Does not implicitly {@link EmbedItem.Image.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EmbedItem.Image
         * @static
         * @param {EmbedItem.IImage} message Image message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Image.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Image message from the specified reader or buffer.
         * @function decode
         * @memberof EmbedItem.Image
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EmbedItem.Image} Image
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Image.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmbedItem.Image();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Image message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EmbedItem.Image
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EmbedItem.Image} Image
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Image.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Image message.
         * @function verify
         * @memberof EmbedItem.Image
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Image.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates an Image message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EmbedItem.Image
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EmbedItem.Image} Image
         */
        Image.fromObject = function fromObject(object) {
            if (object instanceof $root.EmbedItem.Image)
                return object;
            let message = new $root.EmbedItem.Image();
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from an Image message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EmbedItem.Image
         * @static
         * @param {EmbedItem.Image} message Image
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Image.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.url = "";
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this Image to JSON.
         * @function toJSON
         * @memberof EmbedItem.Image
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Image.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Image;
    })();

    return EmbedItem;
})();

export const Attachment = $root.Attachment = (() => {

    /**
     * Properties of an Attachment.
     * @exports IAttachment
     * @interface IAttachment
     * @property {IEmbedItem|null} [embedItem] Attachment embedItem
     */

    /**
     * Constructs a new Attachment.
     * @exports Attachment
     * @classdesc Represents an Attachment.
     * @implements IAttachment
     * @constructor
     * @param {IAttachment=} [properties] Properties to set
     */
    function Attachment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Attachment embedItem.
     * @member {IEmbedItem|null|undefined} embedItem
     * @memberof Attachment
     * @instance
     */
    Attachment.prototype.embedItem = null;

    /**
     * Creates a new Attachment instance using the specified properties.
     * @function create
     * @memberof Attachment
     * @static
     * @param {IAttachment=} [properties] Properties to set
     * @returns {Attachment} Attachment instance
     */
    Attachment.create = function create(properties) {
        return new Attachment(properties);
    };

    /**
     * Encodes the specified Attachment message. Does not implicitly {@link Attachment.verify|verify} messages.
     * @function encode
     * @memberof Attachment
     * @static
     * @param {IAttachment} message Attachment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Attachment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.embedItem != null && message.hasOwnProperty("embedItem"))
            $root.EmbedItem.encode(message.embedItem, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Attachment message, length delimited. Does not implicitly {@link Attachment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Attachment
     * @static
     * @param {IAttachment} message Attachment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Attachment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Attachment message from the specified reader or buffer.
     * @function decode
     * @memberof Attachment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Attachment} Attachment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Attachment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Attachment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.embedItem = $root.EmbedItem.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Attachment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Attachment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Attachment} Attachment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Attachment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Attachment message.
     * @function verify
     * @memberof Attachment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Attachment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.embedItem != null && message.hasOwnProperty("embedItem")) {
            let error = $root.EmbedItem.verify(message.embedItem);
            if (error)
                return "embedItem." + error;
        }
        return null;
    };

    /**
     * Creates an Attachment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Attachment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Attachment} Attachment
     */
    Attachment.fromObject = function fromObject(object) {
        if (object instanceof $root.Attachment)
            return object;
        let message = new $root.Attachment();
        if (object.embedItem != null) {
            if (typeof object.embedItem !== "object")
                throw TypeError(".Attachment.embedItem: object expected");
            message.embedItem = $root.EmbedItem.fromObject(object.embedItem);
        }
        return message;
    };

    /**
     * Creates a plain object from an Attachment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Attachment
     * @static
     * @param {Attachment} message Attachment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Attachment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.embedItem = null;
        if (message.embedItem != null && message.hasOwnProperty("embedItem"))
            object.embedItem = $root.EmbedItem.toObject(message.embedItem, options);
        return object;
    };

    /**
     * Converts this Attachment to JSON.
     * @function toJSON
     * @memberof Attachment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Attachment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Attachment;
})();

export const MessageContent = $root.MessageContent = (() => {

    /**
     * Properties of a MessageContent.
     * @exports IMessageContent
     * @interface IMessageContent
     * @property {Array.<ISegment>|null} [segment] MessageContent segment
     * @property {Array.<IAttachment>|null} [attachment] MessageContent attachment
     */

    /**
     * Constructs a new MessageContent.
     * @exports MessageContent
     * @classdesc Represents a MessageContent.
     * @implements IMessageContent
     * @constructor
     * @param {IMessageContent=} [properties] Properties to set
     */
    function MessageContent(properties) {
        this.segment = [];
        this.attachment = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MessageContent segment.
     * @member {Array.<ISegment>} segment
     * @memberof MessageContent
     * @instance
     */
    MessageContent.prototype.segment = $util.emptyArray;

    /**
     * MessageContent attachment.
     * @member {Array.<IAttachment>} attachment
     * @memberof MessageContent
     * @instance
     */
    MessageContent.prototype.attachment = $util.emptyArray;

    /**
     * Creates a new MessageContent instance using the specified properties.
     * @function create
     * @memberof MessageContent
     * @static
     * @param {IMessageContent=} [properties] Properties to set
     * @returns {MessageContent} MessageContent instance
     */
    MessageContent.create = function create(properties) {
        return new MessageContent(properties);
    };

    /**
     * Encodes the specified MessageContent message. Does not implicitly {@link MessageContent.verify|verify} messages.
     * @function encode
     * @memberof MessageContent
     * @static
     * @param {IMessageContent} message MessageContent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MessageContent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.segment != null && message.segment.length)
            for (let i = 0; i < message.segment.length; ++i)
                $root.Segment.encode(message.segment[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.attachment != null && message.attachment.length)
            for (let i = 0; i < message.attachment.length; ++i)
                $root.Attachment.encode(message.attachment[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MessageContent message, length delimited. Does not implicitly {@link MessageContent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MessageContent
     * @static
     * @param {IMessageContent} message MessageContent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MessageContent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MessageContent message from the specified reader or buffer.
     * @function decode
     * @memberof MessageContent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MessageContent} MessageContent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MessageContent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MessageContent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.segment && message.segment.length))
                    message.segment = [];
                message.segment.push($root.Segment.decode(reader, reader.uint32()));
                break;
            case 2:
                if (!(message.attachment && message.attachment.length))
                    message.attachment = [];
                message.attachment.push($root.Attachment.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MessageContent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MessageContent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MessageContent} MessageContent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MessageContent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MessageContent message.
     * @function verify
     * @memberof MessageContent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MessageContent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.segment != null && message.hasOwnProperty("segment")) {
            if (!Array.isArray(message.segment))
                return "segment: array expected";
            for (let i = 0; i < message.segment.length; ++i) {
                let error = $root.Segment.verify(message.segment[i]);
                if (error)
                    return "segment." + error;
            }
        }
        if (message.attachment != null && message.hasOwnProperty("attachment")) {
            if (!Array.isArray(message.attachment))
                return "attachment: array expected";
            for (let i = 0; i < message.attachment.length; ++i) {
                let error = $root.Attachment.verify(message.attachment[i]);
                if (error)
                    return "attachment." + error;
            }
        }
        return null;
    };

    /**
     * Creates a MessageContent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MessageContent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MessageContent} MessageContent
     */
    MessageContent.fromObject = function fromObject(object) {
        if (object instanceof $root.MessageContent)
            return object;
        let message = new $root.MessageContent();
        if (object.segment) {
            if (!Array.isArray(object.segment))
                throw TypeError(".MessageContent.segment: array expected");
            message.segment = [];
            for (let i = 0; i < object.segment.length; ++i) {
                if (typeof object.segment[i] !== "object")
                    throw TypeError(".MessageContent.segment: object expected");
                message.segment[i] = $root.Segment.fromObject(object.segment[i]);
            }
        }
        if (object.attachment) {
            if (!Array.isArray(object.attachment))
                throw TypeError(".MessageContent.attachment: array expected");
            message.attachment = [];
            for (let i = 0; i < object.attachment.length; ++i) {
                if (typeof object.attachment[i] !== "object")
                    throw TypeError(".MessageContent.attachment: object expected");
                message.attachment[i] = $root.Attachment.fromObject(object.attachment[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a MessageContent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MessageContent
     * @static
     * @param {MessageContent} message MessageContent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MessageContent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.segment = [];
            object.attachment = [];
        }
        if (message.segment && message.segment.length) {
            object.segment = [];
            for (let j = 0; j < message.segment.length; ++j)
                object.segment[j] = $root.Segment.toObject(message.segment[j], options);
        }
        if (message.attachment && message.attachment.length) {
            object.attachment = [];
            for (let j = 0; j < message.attachment.length; ++j)
                object.attachment[j] = $root.Attachment.toObject(message.attachment[j], options);
        }
        return object;
    };

    /**
     * Converts this MessageContent to JSON.
     * @function toJSON
     * @memberof MessageContent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MessageContent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MessageContent;
})();

export const EventAnnotation = $root.EventAnnotation = (() => {

    /**
     * Properties of an EventAnnotation.
     * @exports IEventAnnotation
     * @interface IEventAnnotation
     * @property {number|null} [type] EventAnnotation type
     * @property {string|null} [value] EventAnnotation value
     */

    /**
     * Constructs a new EventAnnotation.
     * @exports EventAnnotation
     * @classdesc Represents an EventAnnotation.
     * @implements IEventAnnotation
     * @constructor
     * @param {IEventAnnotation=} [properties] Properties to set
     */
    function EventAnnotation(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EventAnnotation type.
     * @member {number} type
     * @memberof EventAnnotation
     * @instance
     */
    EventAnnotation.prototype.type = 0;

    /**
     * EventAnnotation value.
     * @member {string} value
     * @memberof EventAnnotation
     * @instance
     */
    EventAnnotation.prototype.value = "";

    /**
     * Creates a new EventAnnotation instance using the specified properties.
     * @function create
     * @memberof EventAnnotation
     * @static
     * @param {IEventAnnotation=} [properties] Properties to set
     * @returns {EventAnnotation} EventAnnotation instance
     */
    EventAnnotation.create = function create(properties) {
        return new EventAnnotation(properties);
    };

    /**
     * Encodes the specified EventAnnotation message. Does not implicitly {@link EventAnnotation.verify|verify} messages.
     * @function encode
     * @memberof EventAnnotation
     * @static
     * @param {IEventAnnotation} message EventAnnotation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventAnnotation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
        return writer;
    };

    /**
     * Encodes the specified EventAnnotation message, length delimited. Does not implicitly {@link EventAnnotation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EventAnnotation
     * @static
     * @param {IEventAnnotation} message EventAnnotation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EventAnnotation message from the specified reader or buffer.
     * @function decode
     * @memberof EventAnnotation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EventAnnotation} EventAnnotation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventAnnotation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EventAnnotation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.value = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EventAnnotation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EventAnnotation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EventAnnotation} EventAnnotation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventAnnotation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EventAnnotation message.
     * @function verify
     * @memberof EventAnnotation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EventAnnotation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            if (!$util.isInteger(message.type))
                return "type: integer expected";
        if (message.value != null && message.hasOwnProperty("value"))
            if (!$util.isString(message.value))
                return "value: string expected";
        return null;
    };

    /**
     * Creates an EventAnnotation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EventAnnotation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EventAnnotation} EventAnnotation
     */
    EventAnnotation.fromObject = function fromObject(object) {
        if (object instanceof $root.EventAnnotation)
            return object;
        let message = new $root.EventAnnotation();
        if (object.type != null)
            message.type = object.type | 0;
        if (object.value != null)
            message.value = String(object.value);
        return message;
    };

    /**
     * Creates a plain object from an EventAnnotation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EventAnnotation
     * @static
     * @param {EventAnnotation} message EventAnnotation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EventAnnotation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = 0;
            object.value = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = message.type;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this EventAnnotation to JSON.
     * @function toJSON
     * @memberof EventAnnotation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EventAnnotation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EventAnnotation;
})();

export const ChatMessage = $root.ChatMessage = (() => {

    /**
     * Properties of a ChatMessage.
     * @exports IChatMessage
     * @interface IChatMessage
     * @property {Array.<IEventAnnotation>|null} [annotation] ChatMessage annotation
     * @property {IMessageContent|null} [messageContent] ChatMessage messageContent
     */

    /**
     * Constructs a new ChatMessage.
     * @exports ChatMessage
     * @classdesc Represents a ChatMessage.
     * @implements IChatMessage
     * @constructor
     * @param {IChatMessage=} [properties] Properties to set
     */
    function ChatMessage(properties) {
        this.annotation = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ChatMessage annotation.
     * @member {Array.<IEventAnnotation>} annotation
     * @memberof ChatMessage
     * @instance
     */
    ChatMessage.prototype.annotation = $util.emptyArray;

    /**
     * ChatMessage messageContent.
     * @member {IMessageContent|null|undefined} messageContent
     * @memberof ChatMessage
     * @instance
     */
    ChatMessage.prototype.messageContent = null;

    /**
     * Creates a new ChatMessage instance using the specified properties.
     * @function create
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage=} [properties] Properties to set
     * @returns {ChatMessage} ChatMessage instance
     */
    ChatMessage.create = function create(properties) {
        return new ChatMessage(properties);
    };

    /**
     * Encodes the specified ChatMessage message. Does not implicitly {@link ChatMessage.verify|verify} messages.
     * @function encode
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage} message ChatMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.annotation != null && message.annotation.length)
            for (let i = 0; i < message.annotation.length; ++i)
                $root.EventAnnotation.encode(message.annotation[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.messageContent != null && message.hasOwnProperty("messageContent"))
            $root.MessageContent.encode(message.messageContent, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ChatMessage message, length delimited. Does not implicitly {@link ChatMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ChatMessage
     * @static
     * @param {IChatMessage} message ChatMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ChatMessage message from the specified reader or buffer.
     * @function decode
     * @memberof ChatMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ChatMessage} ChatMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                if (!(message.annotation && message.annotation.length))
                    message.annotation = [];
                message.annotation.push($root.EventAnnotation.decode(reader, reader.uint32()));
                break;
            case 3:
                message.messageContent = $root.MessageContent.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ChatMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ChatMessage} ChatMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ChatMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ChatMessage message.
     * @function verify
     * @memberof ChatMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ChatMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.annotation != null && message.hasOwnProperty("annotation")) {
            if (!Array.isArray(message.annotation))
                return "annotation: array expected";
            for (let i = 0; i < message.annotation.length; ++i) {
                let error = $root.EventAnnotation.verify(message.annotation[i]);
                if (error)
                    return "annotation." + error;
            }
        }
        if (message.messageContent != null && message.hasOwnProperty("messageContent")) {
            let error = $root.MessageContent.verify(message.messageContent);
            if (error)
                return "messageContent." + error;
        }
        return null;
    };

    /**
     * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ChatMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ChatMessage} ChatMessage
     */
    ChatMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.ChatMessage)
            return object;
        let message = new $root.ChatMessage();
        if (object.annotation) {
            if (!Array.isArray(object.annotation))
                throw TypeError(".ChatMessage.annotation: array expected");
            message.annotation = [];
            for (let i = 0; i < object.annotation.length; ++i) {
                if (typeof object.annotation[i] !== "object")
                    throw TypeError(".ChatMessage.annotation: object expected");
                message.annotation[i] = $root.EventAnnotation.fromObject(object.annotation[i]);
            }
        }
        if (object.messageContent != null) {
            if (typeof object.messageContent !== "object")
                throw TypeError(".ChatMessage.messageContent: object expected");
            message.messageContent = $root.MessageContent.fromObject(object.messageContent);
        }
        return message;
    };

    /**
     * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ChatMessage
     * @static
     * @param {ChatMessage} message ChatMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ChatMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.annotation = [];
        if (options.defaults)
            object.messageContent = null;
        if (message.annotation && message.annotation.length) {
            object.annotation = [];
            for (let j = 0; j < message.annotation.length; ++j)
                object.annotation[j] = $root.EventAnnotation.toObject(message.annotation[j], options);
        }
        if (message.messageContent != null && message.hasOwnProperty("messageContent"))
            object.messageContent = $root.MessageContent.toObject(message.messageContent, options);
        return object;
    };

    /**
     * Converts this ChatMessage to JSON.
     * @function toJSON
     * @memberof ChatMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ChatMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ChatMessage;
})();

/**
 * MembershipChangeType enum.
 * @exports MembershipChangeType
 * @enum {string}
 * @property {number} MEMBERSHIP_CHANGE_TYPE_JOIN=1 MEMBERSHIP_CHANGE_TYPE_JOIN value
 * @property {number} MEMBERSHIP_CHANGE_TYPE_LEAVE=2 MEMBERSHIP_CHANGE_TYPE_LEAVE value
 */
$root.MembershipChangeType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "MEMBERSHIP_CHANGE_TYPE_JOIN"] = 1;
    values[valuesById[2] = "MEMBERSHIP_CHANGE_TYPE_LEAVE"] = 2;
    return values;
})();

export const MembershipChange = $root.MembershipChange = (() => {

    /**
     * Properties of a MembershipChange.
     * @exports IMembershipChange
     * @interface IMembershipChange
     * @property {MembershipChangeType|null} [type] MembershipChange type
     * @property {Array.<IParticipantId>|null} [participantIds] MembershipChange participantIds
     */

    /**
     * Constructs a new MembershipChange.
     * @exports MembershipChange
     * @classdesc Represents a MembershipChange.
     * @implements IMembershipChange
     * @constructor
     * @param {IMembershipChange=} [properties] Properties to set
     */
    function MembershipChange(properties) {
        this.participantIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MembershipChange type.
     * @member {MembershipChangeType} type
     * @memberof MembershipChange
     * @instance
     */
    MembershipChange.prototype.type = 1;

    /**
     * MembershipChange participantIds.
     * @member {Array.<IParticipantId>} participantIds
     * @memberof MembershipChange
     * @instance
     */
    MembershipChange.prototype.participantIds = $util.emptyArray;

    /**
     * Creates a new MembershipChange instance using the specified properties.
     * @function create
     * @memberof MembershipChange
     * @static
     * @param {IMembershipChange=} [properties] Properties to set
     * @returns {MembershipChange} MembershipChange instance
     */
    MembershipChange.create = function create(properties) {
        return new MembershipChange(properties);
    };

    /**
     * Encodes the specified MembershipChange message. Does not implicitly {@link MembershipChange.verify|verify} messages.
     * @function encode
     * @memberof MembershipChange
     * @static
     * @param {IMembershipChange} message MembershipChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MembershipChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.participantIds != null && message.participantIds.length)
            for (let i = 0; i < message.participantIds.length; ++i)
                $root.ParticipantId.encode(message.participantIds[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MembershipChange message, length delimited. Does not implicitly {@link MembershipChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MembershipChange
     * @static
     * @param {IMembershipChange} message MembershipChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MembershipChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MembershipChange message from the specified reader or buffer.
     * @function decode
     * @memberof MembershipChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MembershipChange} MembershipChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MembershipChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MembershipChange();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 3:
                if (!(message.participantIds && message.participantIds.length))
                    message.participantIds = [];
                message.participantIds.push($root.ParticipantId.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MembershipChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MembershipChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MembershipChange} MembershipChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MembershipChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MembershipChange message.
     * @function verify
     * @memberof MembershipChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MembershipChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 1:
            case 2:
                break;
            }
        if (message.participantIds != null && message.hasOwnProperty("participantIds")) {
            if (!Array.isArray(message.participantIds))
                return "participantIds: array expected";
            for (let i = 0; i < message.participantIds.length; ++i) {
                let error = $root.ParticipantId.verify(message.participantIds[i]);
                if (error)
                    return "participantIds." + error;
            }
        }
        return null;
    };

    /**
     * Creates a MembershipChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MembershipChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MembershipChange} MembershipChange
     */
    MembershipChange.fromObject = function fromObject(object) {
        if (object instanceof $root.MembershipChange)
            return object;
        let message = new $root.MembershipChange();
        switch (object.type) {
        case "MEMBERSHIP_CHANGE_TYPE_JOIN":
        case 1:
            message.type = 1;
            break;
        case "MEMBERSHIP_CHANGE_TYPE_LEAVE":
        case 2:
            message.type = 2;
            break;
        }
        if (object.participantIds) {
            if (!Array.isArray(object.participantIds))
                throw TypeError(".MembershipChange.participantIds: array expected");
            message.participantIds = [];
            for (let i = 0; i < object.participantIds.length; ++i) {
                if (typeof object.participantIds[i] !== "object")
                    throw TypeError(".MembershipChange.participantIds: object expected");
                message.participantIds[i] = $root.ParticipantId.fromObject(object.participantIds[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a MembershipChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MembershipChange
     * @static
     * @param {MembershipChange} message MembershipChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MembershipChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.participantIds = [];
        if (options.defaults)
            object.type = options.enums === String ? "MEMBERSHIP_CHANGE_TYPE_JOIN" : 1;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.MembershipChangeType[message.type] : message.type;
        if (message.participantIds && message.participantIds.length) {
            object.participantIds = [];
            for (let j = 0; j < message.participantIds.length; ++j)
                object.participantIds[j] = $root.ParticipantId.toObject(message.participantIds[j], options);
        }
        return object;
    };

    /**
     * Converts this MembershipChange to JSON.
     * @function toJSON
     * @memberof MembershipChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MembershipChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MembershipChange;
})();

export const ConversationRename = $root.ConversationRename = (() => {

    /**
     * Properties of a ConversationRename.
     * @exports IConversationRename
     * @interface IConversationRename
     * @property {string|null} [newName] ConversationRename newName
     * @property {string|null} [oldName] ConversationRename oldName
     */

    /**
     * Constructs a new ConversationRename.
     * @exports ConversationRename
     * @classdesc Represents a ConversationRename.
     * @implements IConversationRename
     * @constructor
     * @param {IConversationRename=} [properties] Properties to set
     */
    function ConversationRename(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationRename newName.
     * @member {string} newName
     * @memberof ConversationRename
     * @instance
     */
    ConversationRename.prototype.newName = "";

    /**
     * ConversationRename oldName.
     * @member {string} oldName
     * @memberof ConversationRename
     * @instance
     */
    ConversationRename.prototype.oldName = "";

    /**
     * Creates a new ConversationRename instance using the specified properties.
     * @function create
     * @memberof ConversationRename
     * @static
     * @param {IConversationRename=} [properties] Properties to set
     * @returns {ConversationRename} ConversationRename instance
     */
    ConversationRename.create = function create(properties) {
        return new ConversationRename(properties);
    };

    /**
     * Encodes the specified ConversationRename message. Does not implicitly {@link ConversationRename.verify|verify} messages.
     * @function encode
     * @memberof ConversationRename
     * @static
     * @param {IConversationRename} message ConversationRename message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationRename.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.newName != null && message.hasOwnProperty("newName"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.newName);
        if (message.oldName != null && message.hasOwnProperty("oldName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.oldName);
        return writer;
    };

    /**
     * Encodes the specified ConversationRename message, length delimited. Does not implicitly {@link ConversationRename.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationRename
     * @static
     * @param {IConversationRename} message ConversationRename message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationRename.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationRename message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationRename
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationRename} ConversationRename
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationRename.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationRename();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.newName = reader.string();
                break;
            case 2:
                message.oldName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationRename message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationRename
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationRename} ConversationRename
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationRename.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationRename message.
     * @function verify
     * @memberof ConversationRename
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationRename.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.newName != null && message.hasOwnProperty("newName"))
            if (!$util.isString(message.newName))
                return "newName: string expected";
        if (message.oldName != null && message.hasOwnProperty("oldName"))
            if (!$util.isString(message.oldName))
                return "oldName: string expected";
        return null;
    };

    /**
     * Creates a ConversationRename message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationRename
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationRename} ConversationRename
     */
    ConversationRename.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationRename)
            return object;
        let message = new $root.ConversationRename();
        if (object.newName != null)
            message.newName = String(object.newName);
        if (object.oldName != null)
            message.oldName = String(object.oldName);
        return message;
    };

    /**
     * Creates a plain object from a ConversationRename message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationRename
     * @static
     * @param {ConversationRename} message ConversationRename
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationRename.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.newName = "";
            object.oldName = "";
        }
        if (message.newName != null && message.hasOwnProperty("newName"))
            object.newName = message.newName;
        if (message.oldName != null && message.hasOwnProperty("oldName"))
            object.oldName = message.oldName;
        return object;
    };

    /**
     * Converts this ConversationRename to JSON.
     * @function toJSON
     * @memberof ConversationRename
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationRename.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationRename;
})();

/**
 * HangoutEventType enum.
 * @exports HangoutEventType
 * @enum {string}
 * @property {number} HANGOUT_EVENT_TYPE_UNKNOWN=0 HANGOUT_EVENT_TYPE_UNKNOWN value
 * @property {number} HANGOUT_EVENT_TYPE_START=1 HANGOUT_EVENT_TYPE_START value
 * @property {number} HANGOUT_EVENT_TYPE_END=2 HANGOUT_EVENT_TYPE_END value
 * @property {number} HANGOUT_EVENT_TYPE_JOIN=3 HANGOUT_EVENT_TYPE_JOIN value
 * @property {number} HANGOUT_EVENT_TYPE_LEAVE=4 HANGOUT_EVENT_TYPE_LEAVE value
 * @property {number} HANGOUT_EVENT_TYPE_COMING_SOON=5 HANGOUT_EVENT_TYPE_COMING_SOON value
 * @property {number} HANGOUT_EVENT_TYPE_ONGOING=6 HANGOUT_EVENT_TYPE_ONGOING value
 */
$root.HangoutEventType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "HANGOUT_EVENT_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "HANGOUT_EVENT_TYPE_START"] = 1;
    values[valuesById[2] = "HANGOUT_EVENT_TYPE_END"] = 2;
    values[valuesById[3] = "HANGOUT_EVENT_TYPE_JOIN"] = 3;
    values[valuesById[4] = "HANGOUT_EVENT_TYPE_LEAVE"] = 4;
    values[valuesById[5] = "HANGOUT_EVENT_TYPE_COMING_SOON"] = 5;
    values[valuesById[6] = "HANGOUT_EVENT_TYPE_ONGOING"] = 6;
    return values;
})();

export const HangoutEvent = $root.HangoutEvent = (() => {

    /**
     * Properties of a HangoutEvent.
     * @exports IHangoutEvent
     * @interface IHangoutEvent
     * @property {HangoutEventType|null} [eventType] HangoutEvent eventType
     * @property {Array.<IParticipantId>|null} [participantId] HangoutEvent participantId
     */

    /**
     * Constructs a new HangoutEvent.
     * @exports HangoutEvent
     * @classdesc Represents a HangoutEvent.
     * @implements IHangoutEvent
     * @constructor
     * @param {IHangoutEvent=} [properties] Properties to set
     */
    function HangoutEvent(properties) {
        this.participantId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HangoutEvent eventType.
     * @member {HangoutEventType} eventType
     * @memberof HangoutEvent
     * @instance
     */
    HangoutEvent.prototype.eventType = 0;

    /**
     * HangoutEvent participantId.
     * @member {Array.<IParticipantId>} participantId
     * @memberof HangoutEvent
     * @instance
     */
    HangoutEvent.prototype.participantId = $util.emptyArray;

    /**
     * Creates a new HangoutEvent instance using the specified properties.
     * @function create
     * @memberof HangoutEvent
     * @static
     * @param {IHangoutEvent=} [properties] Properties to set
     * @returns {HangoutEvent} HangoutEvent instance
     */
    HangoutEvent.create = function create(properties) {
        return new HangoutEvent(properties);
    };

    /**
     * Encodes the specified HangoutEvent message. Does not implicitly {@link HangoutEvent.verify|verify} messages.
     * @function encode
     * @memberof HangoutEvent
     * @static
     * @param {IHangoutEvent} message HangoutEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HangoutEvent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.eventType);
        if (message.participantId != null && message.participantId.length)
            for (let i = 0; i < message.participantId.length; ++i)
                $root.ParticipantId.encode(message.participantId[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified HangoutEvent message, length delimited. Does not implicitly {@link HangoutEvent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HangoutEvent
     * @static
     * @param {IHangoutEvent} message HangoutEvent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HangoutEvent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HangoutEvent message from the specified reader or buffer.
     * @function decode
     * @memberof HangoutEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HangoutEvent} HangoutEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HangoutEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HangoutEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.eventType = reader.int32();
                break;
            case 2:
                if (!(message.participantId && message.participantId.length))
                    message.participantId = [];
                message.participantId.push($root.ParticipantId.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HangoutEvent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HangoutEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HangoutEvent} HangoutEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HangoutEvent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HangoutEvent message.
     * @function verify
     * @memberof HangoutEvent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HangoutEvent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            switch (message.eventType) {
            default:
                return "eventType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                break;
            }
        if (message.participantId != null && message.hasOwnProperty("participantId")) {
            if (!Array.isArray(message.participantId))
                return "participantId: array expected";
            for (let i = 0; i < message.participantId.length; ++i) {
                let error = $root.ParticipantId.verify(message.participantId[i]);
                if (error)
                    return "participantId." + error;
            }
        }
        return null;
    };

    /**
     * Creates a HangoutEvent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HangoutEvent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HangoutEvent} HangoutEvent
     */
    HangoutEvent.fromObject = function fromObject(object) {
        if (object instanceof $root.HangoutEvent)
            return object;
        let message = new $root.HangoutEvent();
        switch (object.eventType) {
        case "HANGOUT_EVENT_TYPE_UNKNOWN":
        case 0:
            message.eventType = 0;
            break;
        case "HANGOUT_EVENT_TYPE_START":
        case 1:
            message.eventType = 1;
            break;
        case "HANGOUT_EVENT_TYPE_END":
        case 2:
            message.eventType = 2;
            break;
        case "HANGOUT_EVENT_TYPE_JOIN":
        case 3:
            message.eventType = 3;
            break;
        case "HANGOUT_EVENT_TYPE_LEAVE":
        case 4:
            message.eventType = 4;
            break;
        case "HANGOUT_EVENT_TYPE_COMING_SOON":
        case 5:
            message.eventType = 5;
            break;
        case "HANGOUT_EVENT_TYPE_ONGOING":
        case 6:
            message.eventType = 6;
            break;
        }
        if (object.participantId) {
            if (!Array.isArray(object.participantId))
                throw TypeError(".HangoutEvent.participantId: array expected");
            message.participantId = [];
            for (let i = 0; i < object.participantId.length; ++i) {
                if (typeof object.participantId[i] !== "object")
                    throw TypeError(".HangoutEvent.participantId: object expected");
                message.participantId[i] = $root.ParticipantId.fromObject(object.participantId[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a HangoutEvent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HangoutEvent
     * @static
     * @param {HangoutEvent} message HangoutEvent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HangoutEvent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.participantId = [];
        if (options.defaults)
            object.eventType = options.enums === String ? "HANGOUT_EVENT_TYPE_UNKNOWN" : 0;
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            object.eventType = options.enums === String ? $root.HangoutEventType[message.eventType] : message.eventType;
        if (message.participantId && message.participantId.length) {
            object.participantId = [];
            for (let j = 0; j < message.participantId.length; ++j)
                object.participantId[j] = $root.ParticipantId.toObject(message.participantId[j], options);
        }
        return object;
    };

    /**
     * Converts this HangoutEvent to JSON.
     * @function toJSON
     * @memberof HangoutEvent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HangoutEvent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HangoutEvent;
})();

export const OTRModification = $root.OTRModification = (() => {

    /**
     * Properties of a OTRModification.
     * @exports IOTRModification
     * @interface IOTRModification
     * @property {OffTheRecordStatus|null} [oldOtrStatus] OTRModification oldOtrStatus
     * @property {OffTheRecordStatus|null} [newOtrStatus] OTRModification newOtrStatus
     * @property {OffTheRecordToggle|null} [oldOtrToggle] OTRModification oldOtrToggle
     * @property {OffTheRecordToggle|null} [newOtrToggle] OTRModification newOtrToggle
     */

    /**
     * Constructs a new OTRModification.
     * @exports OTRModification
     * @classdesc Represents a OTRModification.
     * @implements IOTRModification
     * @constructor
     * @param {IOTRModification=} [properties] Properties to set
     */
    function OTRModification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OTRModification oldOtrStatus.
     * @member {OffTheRecordStatus} oldOtrStatus
     * @memberof OTRModification
     * @instance
     */
    OTRModification.prototype.oldOtrStatus = 0;

    /**
     * OTRModification newOtrStatus.
     * @member {OffTheRecordStatus} newOtrStatus
     * @memberof OTRModification
     * @instance
     */
    OTRModification.prototype.newOtrStatus = 0;

    /**
     * OTRModification oldOtrToggle.
     * @member {OffTheRecordToggle} oldOtrToggle
     * @memberof OTRModification
     * @instance
     */
    OTRModification.prototype.oldOtrToggle = 0;

    /**
     * OTRModification newOtrToggle.
     * @member {OffTheRecordToggle} newOtrToggle
     * @memberof OTRModification
     * @instance
     */
    OTRModification.prototype.newOtrToggle = 0;

    /**
     * Creates a new OTRModification instance using the specified properties.
     * @function create
     * @memberof OTRModification
     * @static
     * @param {IOTRModification=} [properties] Properties to set
     * @returns {OTRModification} OTRModification instance
     */
    OTRModification.create = function create(properties) {
        return new OTRModification(properties);
    };

    /**
     * Encodes the specified OTRModification message. Does not implicitly {@link OTRModification.verify|verify} messages.
     * @function encode
     * @memberof OTRModification
     * @static
     * @param {IOTRModification} message OTRModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OTRModification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.oldOtrStatus != null && message.hasOwnProperty("oldOtrStatus"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.oldOtrStatus);
        if (message.newOtrStatus != null && message.hasOwnProperty("newOtrStatus"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newOtrStatus);
        if (message.oldOtrToggle != null && message.hasOwnProperty("oldOtrToggle"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.oldOtrToggle);
        if (message.newOtrToggle != null && message.hasOwnProperty("newOtrToggle"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.newOtrToggle);
        return writer;
    };

    /**
     * Encodes the specified OTRModification message, length delimited. Does not implicitly {@link OTRModification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OTRModification
     * @static
     * @param {IOTRModification} message OTRModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OTRModification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a OTRModification message from the specified reader or buffer.
     * @function decode
     * @memberof OTRModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OTRModification} OTRModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OTRModification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OTRModification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.oldOtrStatus = reader.int32();
                break;
            case 2:
                message.newOtrStatus = reader.int32();
                break;
            case 3:
                message.oldOtrToggle = reader.int32();
                break;
            case 4:
                message.newOtrToggle = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a OTRModification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OTRModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OTRModification} OTRModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OTRModification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a OTRModification message.
     * @function verify
     * @memberof OTRModification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OTRModification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.oldOtrStatus != null && message.hasOwnProperty("oldOtrStatus"))
            switch (message.oldOtrStatus) {
            default:
                return "oldOtrStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.newOtrStatus != null && message.hasOwnProperty("newOtrStatus"))
            switch (message.newOtrStatus) {
            default:
                return "newOtrStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.oldOtrToggle != null && message.hasOwnProperty("oldOtrToggle"))
            switch (message.oldOtrToggle) {
            default:
                return "oldOtrToggle: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.newOtrToggle != null && message.hasOwnProperty("newOtrToggle"))
            switch (message.newOtrToggle) {
            default:
                return "newOtrToggle: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a OTRModification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OTRModification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OTRModification} OTRModification
     */
    OTRModification.fromObject = function fromObject(object) {
        if (object instanceof $root.OTRModification)
            return object;
        let message = new $root.OTRModification();
        switch (object.oldOtrStatus) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.oldOtrStatus = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.oldOtrStatus = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.oldOtrStatus = 2;
            break;
        }
        switch (object.newOtrStatus) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.newOtrStatus = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.newOtrStatus = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.newOtrStatus = 2;
            break;
        }
        switch (object.oldOtrToggle) {
        case "OFF_THE_RECORD_TOGGLE_UNKNOWN":
        case 0:
            message.oldOtrToggle = 0;
            break;
        case "OFF_THE_RECORD_TOGGLE_ENABLED":
        case 1:
            message.oldOtrToggle = 1;
            break;
        case "OFF_THE_RECORD_TOGGLE_DISABLED":
        case 2:
            message.oldOtrToggle = 2;
            break;
        }
        switch (object.newOtrToggle) {
        case "OFF_THE_RECORD_TOGGLE_UNKNOWN":
        case 0:
            message.newOtrToggle = 0;
            break;
        case "OFF_THE_RECORD_TOGGLE_ENABLED":
        case 1:
            message.newOtrToggle = 1;
            break;
        case "OFF_THE_RECORD_TOGGLE_DISABLED":
        case 2:
            message.newOtrToggle = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a OTRModification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OTRModification
     * @static
     * @param {OTRModification} message OTRModification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OTRModification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.oldOtrStatus = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.newOtrStatus = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.oldOtrToggle = options.enums === String ? "OFF_THE_RECORD_TOGGLE_UNKNOWN" : 0;
            object.newOtrToggle = options.enums === String ? "OFF_THE_RECORD_TOGGLE_UNKNOWN" : 0;
        }
        if (message.oldOtrStatus != null && message.hasOwnProperty("oldOtrStatus"))
            object.oldOtrStatus = options.enums === String ? $root.OffTheRecordStatus[message.oldOtrStatus] : message.oldOtrStatus;
        if (message.newOtrStatus != null && message.hasOwnProperty("newOtrStatus"))
            object.newOtrStatus = options.enums === String ? $root.OffTheRecordStatus[message.newOtrStatus] : message.newOtrStatus;
        if (message.oldOtrToggle != null && message.hasOwnProperty("oldOtrToggle"))
            object.oldOtrToggle = options.enums === String ? $root.OffTheRecordToggle[message.oldOtrToggle] : message.oldOtrToggle;
        if (message.newOtrToggle != null && message.hasOwnProperty("newOtrToggle"))
            object.newOtrToggle = options.enums === String ? $root.OffTheRecordToggle[message.newOtrToggle] : message.newOtrToggle;
        return object;
    };

    /**
     * Converts this OTRModification to JSON.
     * @function toJSON
     * @memberof OTRModification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OTRModification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OTRModification;
})();

/**
 * OffTheRecordToggle enum.
 * @exports OffTheRecordToggle
 * @enum {string}
 * @property {number} OFF_THE_RECORD_TOGGLE_UNKNOWN=0 OFF_THE_RECORD_TOGGLE_UNKNOWN value
 * @property {number} OFF_THE_RECORD_TOGGLE_ENABLED=1 OFF_THE_RECORD_TOGGLE_ENABLED value
 * @property {number} OFF_THE_RECORD_TOGGLE_DISABLED=2 OFF_THE_RECORD_TOGGLE_DISABLED value
 */
$root.OffTheRecordToggle = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "OFF_THE_RECORD_TOGGLE_UNKNOWN"] = 0;
    values[valuesById[1] = "OFF_THE_RECORD_TOGGLE_ENABLED"] = 1;
    values[valuesById[2] = "OFF_THE_RECORD_TOGGLE_DISABLED"] = 2;
    return values;
})();

/**
 * OffTheRecordStatus enum.
 * @exports OffTheRecordStatus
 * @enum {string}
 * @property {number} OFF_THE_RECORD_STATUS_UNKNOWN=0 OFF_THE_RECORD_STATUS_UNKNOWN value
 * @property {number} OFF_THE_RECORD_STATUS_OFF_THE_RECORD=1 OFF_THE_RECORD_STATUS_OFF_THE_RECORD value
 * @property {number} OFF_THE_RECORD_STATUS_ON_THE_RECORD=2 OFF_THE_RECORD_STATUS_ON_THE_RECORD value
 */
$root.OffTheRecordStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "OFF_THE_RECORD_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "OFF_THE_RECORD_STATUS_OFF_THE_RECORD"] = 1;
    values[valuesById[2] = "OFF_THE_RECORD_STATUS_ON_THE_RECORD"] = 2;
    return values;
})();

/**
 * SourceType enum.
 * @exports SourceType
 * @enum {string}
 * @property {number} SOURCE_TYPE_UNKNOWN=0 SOURCE_TYPE_UNKNOWN value
 */
$root.SourceType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SOURCE_TYPE_UNKNOWN"] = 0;
    return values;
})();

/**
 * EventType enum.
 * @exports EventType
 * @enum {string}
 * @property {number} EVENT_TYPE_UNKNOWN=0 EVENT_TYPE_UNKNOWN value
 * @property {number} EVENT_TYPE_REGULAR_CHAT_MESSAGE=1 EVENT_TYPE_REGULAR_CHAT_MESSAGE value
 * @property {number} EVENT_TYPE_SMS=2 EVENT_TYPE_SMS value
 * @property {number} EVENT_TYPE_VOICEMAIL=3 EVENT_TYPE_VOICEMAIL value
 * @property {number} EVENT_TYPE_ADD_USER=4 EVENT_TYPE_ADD_USER value
 * @property {number} EVENT_TYPE_REMOVE_USER=5 EVENT_TYPE_REMOVE_USER value
 * @property {number} EVENT_TYPE_CONVERSATION_RENAME=6 EVENT_TYPE_CONVERSATION_RENAME value
 * @property {number} EVENT_TYPE_HANGOUT=7 EVENT_TYPE_HANGOUT value
 * @property {number} EVENT_TYPE_PHONE_CALL=8 EVENT_TYPE_PHONE_CALL value
 * @property {number} EVENT_TYPE_OTR_MODIFICATION=9 EVENT_TYPE_OTR_MODIFICATION value
 * @property {number} EVENT_TYPE_PLAN_MUTATION=10 EVENT_TYPE_PLAN_MUTATION value
 * @property {number} EVENT_TYPE_MMS=11 EVENT_TYPE_MMS value
 * @property {number} EVENT_TYPE_DEPRECATED_12=12 EVENT_TYPE_DEPRECATED_12 value
 * @property {number} EVENT_TYPE_OBSERVED_EVENT=13 EVENT_TYPE_OBSERVED_EVENT value
 * @property {number} EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION=14 EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION value
 */
$root.EventType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "EVENT_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "EVENT_TYPE_REGULAR_CHAT_MESSAGE"] = 1;
    values[valuesById[2] = "EVENT_TYPE_SMS"] = 2;
    values[valuesById[3] = "EVENT_TYPE_VOICEMAIL"] = 3;
    values[valuesById[4] = "EVENT_TYPE_ADD_USER"] = 4;
    values[valuesById[5] = "EVENT_TYPE_REMOVE_USER"] = 5;
    values[valuesById[6] = "EVENT_TYPE_CONVERSATION_RENAME"] = 6;
    values[valuesById[7] = "EVENT_TYPE_HANGOUT"] = 7;
    values[valuesById[8] = "EVENT_TYPE_PHONE_CALL"] = 8;
    values[valuesById[9] = "EVENT_TYPE_OTR_MODIFICATION"] = 9;
    values[valuesById[10] = "EVENT_TYPE_PLAN_MUTATION"] = 10;
    values[valuesById[11] = "EVENT_TYPE_MMS"] = 11;
    values[valuesById[12] = "EVENT_TYPE_DEPRECATED_12"] = 12;
    values[valuesById[13] = "EVENT_TYPE_OBSERVED_EVENT"] = 13;
    values[valuesById[14] = "EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION"] = 14;
    return values;
})();

export const HashModifier = $root.HashModifier = (() => {

    /**
     * Properties of a HashModifier.
     * @exports IHashModifier
     * @interface IHashModifier
     * @property {string|null} [updateId] HashModifier updateId
     * @property {number|Long|null} [hashDiff] HashModifier hashDiff
     * @property {number|Long|null} [version] HashModifier version
     */

    /**
     * Constructs a new HashModifier.
     * @exports HashModifier
     * @classdesc Represents a HashModifier.
     * @implements IHashModifier
     * @constructor
     * @param {IHashModifier=} [properties] Properties to set
     */
    function HashModifier(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * HashModifier updateId.
     * @member {string} updateId
     * @memberof HashModifier
     * @instance
     */
    HashModifier.prototype.updateId = "";

    /**
     * HashModifier hashDiff.
     * @member {number|Long} hashDiff
     * @memberof HashModifier
     * @instance
     */
    HashModifier.prototype.hashDiff = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * HashModifier version.
     * @member {number|Long} version
     * @memberof HashModifier
     * @instance
     */
    HashModifier.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new HashModifier instance using the specified properties.
     * @function create
     * @memberof HashModifier
     * @static
     * @param {IHashModifier=} [properties] Properties to set
     * @returns {HashModifier} HashModifier instance
     */
    HashModifier.create = function create(properties) {
        return new HashModifier(properties);
    };

    /**
     * Encodes the specified HashModifier message. Does not implicitly {@link HashModifier.verify|verify} messages.
     * @function encode
     * @memberof HashModifier
     * @static
     * @param {IHashModifier} message HashModifier message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashModifier.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.updateId != null && message.hasOwnProperty("updateId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.updateId);
        if (message.hashDiff != null && message.hasOwnProperty("hashDiff"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.hashDiff);
        if (message.version != null && message.hasOwnProperty("version"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.version);
        return writer;
    };

    /**
     * Encodes the specified HashModifier message, length delimited. Does not implicitly {@link HashModifier.verify|verify} messages.
     * @function encodeDelimited
     * @memberof HashModifier
     * @static
     * @param {IHashModifier} message HashModifier message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    HashModifier.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a HashModifier message from the specified reader or buffer.
     * @function decode
     * @memberof HashModifier
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {HashModifier} HashModifier
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashModifier.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.HashModifier();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.updateId = reader.string();
                break;
            case 2:
                message.hashDiff = reader.uint64();
                break;
            case 4:
                message.version = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a HashModifier message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof HashModifier
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {HashModifier} HashModifier
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    HashModifier.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a HashModifier message.
     * @function verify
     * @memberof HashModifier
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    HashModifier.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.updateId != null && message.hasOwnProperty("updateId"))
            if (!$util.isString(message.updateId))
                return "updateId: string expected";
        if (message.hashDiff != null && message.hasOwnProperty("hashDiff"))
            if (!$util.isInteger(message.hashDiff) && !(message.hashDiff && $util.isInteger(message.hashDiff.low) && $util.isInteger(message.hashDiff.high)))
                return "hashDiff: integer|Long expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                return "version: integer|Long expected";
        return null;
    };

    /**
     * Creates a HashModifier message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof HashModifier
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {HashModifier} HashModifier
     */
    HashModifier.fromObject = function fromObject(object) {
        if (object instanceof $root.HashModifier)
            return object;
        let message = new $root.HashModifier();
        if (object.updateId != null)
            message.updateId = String(object.updateId);
        if (object.hashDiff != null)
            if ($util.Long)
                (message.hashDiff = $util.Long.fromValue(object.hashDiff)).unsigned = true;
            else if (typeof object.hashDiff === "string")
                message.hashDiff = parseInt(object.hashDiff, 10);
            else if (typeof object.hashDiff === "number")
                message.hashDiff = object.hashDiff;
            else if (typeof object.hashDiff === "object")
                message.hashDiff = new $util.LongBits(object.hashDiff.low >>> 0, object.hashDiff.high >>> 0).toNumber(true);
        if (object.version != null)
            if ($util.Long)
                (message.version = $util.Long.fromValue(object.version)).unsigned = true;
            else if (typeof object.version === "string")
                message.version = parseInt(object.version, 10);
            else if (typeof object.version === "number")
                message.version = object.version;
            else if (typeof object.version === "object")
                message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a HashModifier message. Also converts values to other types if specified.
     * @function toObject
     * @memberof HashModifier
     * @static
     * @param {HashModifier} message HashModifier
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    HashModifier.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.updateId = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.hashDiff = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.hashDiff = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.version = options.longs === String ? "0" : 0;
        }
        if (message.updateId != null && message.hasOwnProperty("updateId"))
            object.updateId = message.updateId;
        if (message.hashDiff != null && message.hasOwnProperty("hashDiff"))
            if (typeof message.hashDiff === "number")
                object.hashDiff = options.longs === String ? String(message.hashDiff) : message.hashDiff;
            else
                object.hashDiff = options.longs === String ? $util.Long.prototype.toString.call(message.hashDiff) : options.longs === Number ? new $util.LongBits(message.hashDiff.low >>> 0, message.hashDiff.high >>> 0).toNumber(true) : message.hashDiff;
        if (message.version != null && message.hasOwnProperty("version"))
            if (typeof message.version === "number")
                object.version = options.longs === String ? String(message.version) : message.version;
            else
                object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
        return object;
    };

    /**
     * Converts this HashModifier to JSON.
     * @function toJSON
     * @memberof HashModifier
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    HashModifier.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return HashModifier;
})();

export const Event = $root.Event = (() => {

    /**
     * Properties of an Event.
     * @exports IEvent
     * @interface IEvent
     * @property {IConversationId|null} [conversationId] Event conversationId
     * @property {IParticipantId|null} [senderId] Event senderId
     * @property {number|Long|null} [timestamp] Event timestamp
     * @property {IUserEventState|null} [selfEventState] Event selfEventState
     * @property {SourceType|null} [sourceType] Event sourceType
     * @property {IChatMessage|null} [chatMessage] Event chatMessage
     * @property {IMembershipChange|null} [membershipChange] Event membershipChange
     * @property {IConversationRename|null} [conversationRename] Event conversationRename
     * @property {IHangoutEvent|null} [hangoutEvent] Event hangoutEvent
     * @property {string|null} [eventId] Event eventId
     * @property {number|Long|null} [expirationTimestamp] Event expirationTimestamp
     * @property {IOTRModification|null} [otrModification] Event otrModification
     * @property {boolean|null} [advancesSortTimestamp] Event advancesSortTimestamp
     * @property {OffTheRecordStatus|null} [otrStatus] Event otrStatus
     * @property {boolean|null} [persisted] Event persisted
     * @property {IDeliveryMedium|null} [mediumType] Event mediumType
     * @property {EventType|null} [eventType] Event eventType
     * @property {number|Long|null} [eventVersion] Event eventVersion
     * @property {IHashModifier|null} [hashModifier] Event hashModifier
     * @property {IGroupLinkSharingModification|null} [groupLinkSharingModification] Event groupLinkSharingModification
     */

    /**
     * Constructs a new Event.
     * @exports Event
     * @classdesc Represents an Event.
     * @implements IEvent
     * @constructor
     * @param {IEvent=} [properties] Properties to set
     */
    function Event(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Event conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof Event
     * @instance
     */
    Event.prototype.conversationId = null;

    /**
     * Event senderId.
     * @member {IParticipantId|null|undefined} senderId
     * @memberof Event
     * @instance
     */
    Event.prototype.senderId = null;

    /**
     * Event timestamp.
     * @member {number|Long} timestamp
     * @memberof Event
     * @instance
     */
    Event.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Event selfEventState.
     * @member {IUserEventState|null|undefined} selfEventState
     * @memberof Event
     * @instance
     */
    Event.prototype.selfEventState = null;

    /**
     * Event sourceType.
     * @member {SourceType} sourceType
     * @memberof Event
     * @instance
     */
    Event.prototype.sourceType = 0;

    /**
     * Event chatMessage.
     * @member {IChatMessage|null|undefined} chatMessage
     * @memberof Event
     * @instance
     */
    Event.prototype.chatMessage = null;

    /**
     * Event membershipChange.
     * @member {IMembershipChange|null|undefined} membershipChange
     * @memberof Event
     * @instance
     */
    Event.prototype.membershipChange = null;

    /**
     * Event conversationRename.
     * @member {IConversationRename|null|undefined} conversationRename
     * @memberof Event
     * @instance
     */
    Event.prototype.conversationRename = null;

    /**
     * Event hangoutEvent.
     * @member {IHangoutEvent|null|undefined} hangoutEvent
     * @memberof Event
     * @instance
     */
    Event.prototype.hangoutEvent = null;

    /**
     * Event eventId.
     * @member {string} eventId
     * @memberof Event
     * @instance
     */
    Event.prototype.eventId = "";

    /**
     * Event expirationTimestamp.
     * @member {number|Long} expirationTimestamp
     * @memberof Event
     * @instance
     */
    Event.prototype.expirationTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Event otrModification.
     * @member {IOTRModification|null|undefined} otrModification
     * @memberof Event
     * @instance
     */
    Event.prototype.otrModification = null;

    /**
     * Event advancesSortTimestamp.
     * @member {boolean} advancesSortTimestamp
     * @memberof Event
     * @instance
     */
    Event.prototype.advancesSortTimestamp = false;

    /**
     * Event otrStatus.
     * @member {OffTheRecordStatus} otrStatus
     * @memberof Event
     * @instance
     */
    Event.prototype.otrStatus = 0;

    /**
     * Event persisted.
     * @member {boolean} persisted
     * @memberof Event
     * @instance
     */
    Event.prototype.persisted = false;

    /**
     * Event mediumType.
     * @member {IDeliveryMedium|null|undefined} mediumType
     * @memberof Event
     * @instance
     */
    Event.prototype.mediumType = null;

    /**
     * Event eventType.
     * @member {EventType} eventType
     * @memberof Event
     * @instance
     */
    Event.prototype.eventType = 0;

    /**
     * Event eventVersion.
     * @member {number|Long} eventVersion
     * @memberof Event
     * @instance
     */
    Event.prototype.eventVersion = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Event hashModifier.
     * @member {IHashModifier|null|undefined} hashModifier
     * @memberof Event
     * @instance
     */
    Event.prototype.hashModifier = null;

    /**
     * Event groupLinkSharingModification.
     * @member {IGroupLinkSharingModification|null|undefined} groupLinkSharingModification
     * @memberof Event
     * @instance
     */
    Event.prototype.groupLinkSharingModification = null;

    /**
     * Creates a new Event instance using the specified properties.
     * @function create
     * @memberof Event
     * @static
     * @param {IEvent=} [properties] Properties to set
     * @returns {Event} Event instance
     */
    Event.create = function create(properties) {
        return new Event(properties);
    };

    /**
     * Encodes the specified Event message. Does not implicitly {@link Event.verify|verify} messages.
     * @function encode
     * @memberof Event
     * @static
     * @param {IEvent} message Event message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Event.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            $root.ParticipantId.encode(message.senderId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
        if (message.selfEventState != null && message.hasOwnProperty("selfEventState"))
            $root.UserEventState.encode(message.selfEventState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.sourceType != null && message.hasOwnProperty("sourceType"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sourceType);
        if (message.chatMessage != null && message.hasOwnProperty("chatMessage"))
            $root.ChatMessage.encode(message.chatMessage, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.membershipChange != null && message.hasOwnProperty("membershipChange"))
            $root.MembershipChange.encode(message.membershipChange, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.conversationRename != null && message.hasOwnProperty("conversationRename"))
            $root.ConversationRename.encode(message.conversationRename, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.hangoutEvent != null && message.hasOwnProperty("hangoutEvent"))
            $root.HangoutEvent.encode(message.hangoutEvent, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            writer.uint32(/* id 12, wireType 2 =*/98).string(message.eventId);
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.expirationTimestamp);
        if (message.otrModification != null && message.hasOwnProperty("otrModification"))
            $root.OTRModification.encode(message.otrModification, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.advancesSortTimestamp != null && message.hasOwnProperty("advancesSortTimestamp"))
            writer.uint32(/* id 15, wireType 0 =*/120).bool(message.advancesSortTimestamp);
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.otrStatus);
        if (message.persisted != null && message.hasOwnProperty("persisted"))
            writer.uint32(/* id 17, wireType 0 =*/136).bool(message.persisted);
        if (message.mediumType != null && message.hasOwnProperty("mediumType"))
            $root.DeliveryMedium.encode(message.mediumType, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            writer.uint32(/* id 23, wireType 0 =*/184).int32(message.eventType);
        if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
            writer.uint32(/* id 24, wireType 0 =*/192).uint64(message.eventVersion);
        if (message.hashModifier != null && message.hasOwnProperty("hashModifier"))
            $root.HashModifier.encode(message.hashModifier, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
        if (message.groupLinkSharingModification != null && message.hasOwnProperty("groupLinkSharingModification"))
            $root.GroupLinkSharingModification.encode(message.groupLinkSharingModification, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Event message, length delimited. Does not implicitly {@link Event.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Event
     * @static
     * @param {IEvent} message Event message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Event.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Event message from the specified reader or buffer.
     * @function decode
     * @memberof Event
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Event} Event
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Event.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Event();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.senderId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 3:
                message.timestamp = reader.uint64();
                break;
            case 4:
                message.selfEventState = $root.UserEventState.decode(reader, reader.uint32());
                break;
            case 6:
                message.sourceType = reader.int32();
                break;
            case 7:
                message.chatMessage = $root.ChatMessage.decode(reader, reader.uint32());
                break;
            case 9:
                message.membershipChange = $root.MembershipChange.decode(reader, reader.uint32());
                break;
            case 10:
                message.conversationRename = $root.ConversationRename.decode(reader, reader.uint32());
                break;
            case 11:
                message.hangoutEvent = $root.HangoutEvent.decode(reader, reader.uint32());
                break;
            case 12:
                message.eventId = reader.string();
                break;
            case 13:
                message.expirationTimestamp = reader.uint64();
                break;
            case 14:
                message.otrModification = $root.OTRModification.decode(reader, reader.uint32());
                break;
            case 15:
                message.advancesSortTimestamp = reader.bool();
                break;
            case 16:
                message.otrStatus = reader.int32();
                break;
            case 17:
                message.persisted = reader.bool();
                break;
            case 20:
                message.mediumType = $root.DeliveryMedium.decode(reader, reader.uint32());
                break;
            case 23:
                message.eventType = reader.int32();
                break;
            case 24:
                message.eventVersion = reader.uint64();
                break;
            case 26:
                message.hashModifier = $root.HashModifier.decode(reader, reader.uint32());
                break;
            case 31:
                message.groupLinkSharingModification = $root.GroupLinkSharingModification.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Event message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Event
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Event} Event
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Event.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Event message.
     * @function verify
     * @memberof Event
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Event.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.senderId != null && message.hasOwnProperty("senderId")) {
            let error = $root.ParticipantId.verify(message.senderId);
            if (error)
                return "senderId." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.selfEventState != null && message.hasOwnProperty("selfEventState")) {
            let error = $root.UserEventState.verify(message.selfEventState);
            if (error)
                return "selfEventState." + error;
        }
        if (message.sourceType != null && message.hasOwnProperty("sourceType"))
            switch (message.sourceType) {
            default:
                return "sourceType: enum value expected";
            case 0:
                break;
            }
        if (message.chatMessage != null && message.hasOwnProperty("chatMessage")) {
            let error = $root.ChatMessage.verify(message.chatMessage);
            if (error)
                return "chatMessage." + error;
        }
        if (message.membershipChange != null && message.hasOwnProperty("membershipChange")) {
            let error = $root.MembershipChange.verify(message.membershipChange);
            if (error)
                return "membershipChange." + error;
        }
        if (message.conversationRename != null && message.hasOwnProperty("conversationRename")) {
            let error = $root.ConversationRename.verify(message.conversationRename);
            if (error)
                return "conversationRename." + error;
        }
        if (message.hangoutEvent != null && message.hasOwnProperty("hangoutEvent")) {
            let error = $root.HangoutEvent.verify(message.hangoutEvent);
            if (error)
                return "hangoutEvent." + error;
        }
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            if (!$util.isString(message.eventId))
                return "eventId: string expected";
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            if (!$util.isInteger(message.expirationTimestamp) && !(message.expirationTimestamp && $util.isInteger(message.expirationTimestamp.low) && $util.isInteger(message.expirationTimestamp.high)))
                return "expirationTimestamp: integer|Long expected";
        if (message.otrModification != null && message.hasOwnProperty("otrModification")) {
            let error = $root.OTRModification.verify(message.otrModification);
            if (error)
                return "otrModification." + error;
        }
        if (message.advancesSortTimestamp != null && message.hasOwnProperty("advancesSortTimestamp"))
            if (typeof message.advancesSortTimestamp !== "boolean")
                return "advancesSortTimestamp: boolean expected";
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            switch (message.otrStatus) {
            default:
                return "otrStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.persisted != null && message.hasOwnProperty("persisted"))
            if (typeof message.persisted !== "boolean")
                return "persisted: boolean expected";
        if (message.mediumType != null && message.hasOwnProperty("mediumType")) {
            let error = $root.DeliveryMedium.verify(message.mediumType);
            if (error)
                return "mediumType." + error;
        }
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            switch (message.eventType) {
            default:
                return "eventType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                break;
            }
        if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
            if (!$util.isInteger(message.eventVersion) && !(message.eventVersion && $util.isInteger(message.eventVersion.low) && $util.isInteger(message.eventVersion.high)))
                return "eventVersion: integer|Long expected";
        if (message.hashModifier != null && message.hasOwnProperty("hashModifier")) {
            let error = $root.HashModifier.verify(message.hashModifier);
            if (error)
                return "hashModifier." + error;
        }
        if (message.groupLinkSharingModification != null && message.hasOwnProperty("groupLinkSharingModification")) {
            let error = $root.GroupLinkSharingModification.verify(message.groupLinkSharingModification);
            if (error)
                return "groupLinkSharingModification." + error;
        }
        return null;
    };

    /**
     * Creates an Event message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Event
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Event} Event
     */
    Event.fromObject = function fromObject(object) {
        if (object instanceof $root.Event)
            return object;
        let message = new $root.Event();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".Event.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.senderId != null) {
            if (typeof object.senderId !== "object")
                throw TypeError(".Event.senderId: object expected");
            message.senderId = $root.ParticipantId.fromObject(object.senderId);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        if (object.selfEventState != null) {
            if (typeof object.selfEventState !== "object")
                throw TypeError(".Event.selfEventState: object expected");
            message.selfEventState = $root.UserEventState.fromObject(object.selfEventState);
        }
        switch (object.sourceType) {
        case "SOURCE_TYPE_UNKNOWN":
        case 0:
            message.sourceType = 0;
            break;
        }
        if (object.chatMessage != null) {
            if (typeof object.chatMessage !== "object")
                throw TypeError(".Event.chatMessage: object expected");
            message.chatMessage = $root.ChatMessage.fromObject(object.chatMessage);
        }
        if (object.membershipChange != null) {
            if (typeof object.membershipChange !== "object")
                throw TypeError(".Event.membershipChange: object expected");
            message.membershipChange = $root.MembershipChange.fromObject(object.membershipChange);
        }
        if (object.conversationRename != null) {
            if (typeof object.conversationRename !== "object")
                throw TypeError(".Event.conversationRename: object expected");
            message.conversationRename = $root.ConversationRename.fromObject(object.conversationRename);
        }
        if (object.hangoutEvent != null) {
            if (typeof object.hangoutEvent !== "object")
                throw TypeError(".Event.hangoutEvent: object expected");
            message.hangoutEvent = $root.HangoutEvent.fromObject(object.hangoutEvent);
        }
        if (object.eventId != null)
            message.eventId = String(object.eventId);
        if (object.expirationTimestamp != null)
            if ($util.Long)
                (message.expirationTimestamp = $util.Long.fromValue(object.expirationTimestamp)).unsigned = true;
            else if (typeof object.expirationTimestamp === "string")
                message.expirationTimestamp = parseInt(object.expirationTimestamp, 10);
            else if (typeof object.expirationTimestamp === "number")
                message.expirationTimestamp = object.expirationTimestamp;
            else if (typeof object.expirationTimestamp === "object")
                message.expirationTimestamp = new $util.LongBits(object.expirationTimestamp.low >>> 0, object.expirationTimestamp.high >>> 0).toNumber(true);
        if (object.otrModification != null) {
            if (typeof object.otrModification !== "object")
                throw TypeError(".Event.otrModification: object expected");
            message.otrModification = $root.OTRModification.fromObject(object.otrModification);
        }
        if (object.advancesSortTimestamp != null)
            message.advancesSortTimestamp = Boolean(object.advancesSortTimestamp);
        switch (object.otrStatus) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.otrStatus = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.otrStatus = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.otrStatus = 2;
            break;
        }
        if (object.persisted != null)
            message.persisted = Boolean(object.persisted);
        if (object.mediumType != null) {
            if (typeof object.mediumType !== "object")
                throw TypeError(".Event.mediumType: object expected");
            message.mediumType = $root.DeliveryMedium.fromObject(object.mediumType);
        }
        switch (object.eventType) {
        case "EVENT_TYPE_UNKNOWN":
        case 0:
            message.eventType = 0;
            break;
        case "EVENT_TYPE_REGULAR_CHAT_MESSAGE":
        case 1:
            message.eventType = 1;
            break;
        case "EVENT_TYPE_SMS":
        case 2:
            message.eventType = 2;
            break;
        case "EVENT_TYPE_VOICEMAIL":
        case 3:
            message.eventType = 3;
            break;
        case "EVENT_TYPE_ADD_USER":
        case 4:
            message.eventType = 4;
            break;
        case "EVENT_TYPE_REMOVE_USER":
        case 5:
            message.eventType = 5;
            break;
        case "EVENT_TYPE_CONVERSATION_RENAME":
        case 6:
            message.eventType = 6;
            break;
        case "EVENT_TYPE_HANGOUT":
        case 7:
            message.eventType = 7;
            break;
        case "EVENT_TYPE_PHONE_CALL":
        case 8:
            message.eventType = 8;
            break;
        case "EVENT_TYPE_OTR_MODIFICATION":
        case 9:
            message.eventType = 9;
            break;
        case "EVENT_TYPE_PLAN_MUTATION":
        case 10:
            message.eventType = 10;
            break;
        case "EVENT_TYPE_MMS":
        case 11:
            message.eventType = 11;
            break;
        case "EVENT_TYPE_DEPRECATED_12":
        case 12:
            message.eventType = 12;
            break;
        case "EVENT_TYPE_OBSERVED_EVENT":
        case 13:
            message.eventType = 13;
            break;
        case "EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION":
        case 14:
            message.eventType = 14;
            break;
        }
        if (object.eventVersion != null)
            if ($util.Long)
                (message.eventVersion = $util.Long.fromValue(object.eventVersion)).unsigned = true;
            else if (typeof object.eventVersion === "string")
                message.eventVersion = parseInt(object.eventVersion, 10);
            else if (typeof object.eventVersion === "number")
                message.eventVersion = object.eventVersion;
            else if (typeof object.eventVersion === "object")
                message.eventVersion = new $util.LongBits(object.eventVersion.low >>> 0, object.eventVersion.high >>> 0).toNumber(true);
        if (object.hashModifier != null) {
            if (typeof object.hashModifier !== "object")
                throw TypeError(".Event.hashModifier: object expected");
            message.hashModifier = $root.HashModifier.fromObject(object.hashModifier);
        }
        if (object.groupLinkSharingModification != null) {
            if (typeof object.groupLinkSharingModification !== "object")
                throw TypeError(".Event.groupLinkSharingModification: object expected");
            message.groupLinkSharingModification = $root.GroupLinkSharingModification.fromObject(object.groupLinkSharingModification);
        }
        return message;
    };

    /**
     * Creates a plain object from an Event message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Event
     * @static
     * @param {Event} message Event
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Event.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.senderId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.selfEventState = null;
            object.sourceType = options.enums === String ? "SOURCE_TYPE_UNKNOWN" : 0;
            object.chatMessage = null;
            object.membershipChange = null;
            object.conversationRename = null;
            object.hangoutEvent = null;
            object.eventId = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.expirationTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.expirationTimestamp = options.longs === String ? "0" : 0;
            object.otrModification = null;
            object.advancesSortTimestamp = false;
            object.otrStatus = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.persisted = false;
            object.mediumType = null;
            object.eventType = options.enums === String ? "EVENT_TYPE_UNKNOWN" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.eventVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.eventVersion = options.longs === String ? "0" : 0;
            object.hashModifier = null;
            object.groupLinkSharingModification = null;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            object.senderId = $root.ParticipantId.toObject(message.senderId, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        if (message.selfEventState != null && message.hasOwnProperty("selfEventState"))
            object.selfEventState = $root.UserEventState.toObject(message.selfEventState, options);
        if (message.sourceType != null && message.hasOwnProperty("sourceType"))
            object.sourceType = options.enums === String ? $root.SourceType[message.sourceType] : message.sourceType;
        if (message.chatMessage != null && message.hasOwnProperty("chatMessage"))
            object.chatMessage = $root.ChatMessage.toObject(message.chatMessage, options);
        if (message.membershipChange != null && message.hasOwnProperty("membershipChange"))
            object.membershipChange = $root.MembershipChange.toObject(message.membershipChange, options);
        if (message.conversationRename != null && message.hasOwnProperty("conversationRename"))
            object.conversationRename = $root.ConversationRename.toObject(message.conversationRename, options);
        if (message.hangoutEvent != null && message.hasOwnProperty("hangoutEvent"))
            object.hangoutEvent = $root.HangoutEvent.toObject(message.hangoutEvent, options);
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            object.eventId = message.eventId;
        if (message.expirationTimestamp != null && message.hasOwnProperty("expirationTimestamp"))
            if (typeof message.expirationTimestamp === "number")
                object.expirationTimestamp = options.longs === String ? String(message.expirationTimestamp) : message.expirationTimestamp;
            else
                object.expirationTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.expirationTimestamp) : options.longs === Number ? new $util.LongBits(message.expirationTimestamp.low >>> 0, message.expirationTimestamp.high >>> 0).toNumber(true) : message.expirationTimestamp;
        if (message.otrModification != null && message.hasOwnProperty("otrModification"))
            object.otrModification = $root.OTRModification.toObject(message.otrModification, options);
        if (message.advancesSortTimestamp != null && message.hasOwnProperty("advancesSortTimestamp"))
            object.advancesSortTimestamp = message.advancesSortTimestamp;
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            object.otrStatus = options.enums === String ? $root.OffTheRecordStatus[message.otrStatus] : message.otrStatus;
        if (message.persisted != null && message.hasOwnProperty("persisted"))
            object.persisted = message.persisted;
        if (message.mediumType != null && message.hasOwnProperty("mediumType"))
            object.mediumType = $root.DeliveryMedium.toObject(message.mediumType, options);
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            object.eventType = options.enums === String ? $root.EventType[message.eventType] : message.eventType;
        if (message.eventVersion != null && message.hasOwnProperty("eventVersion"))
            if (typeof message.eventVersion === "number")
                object.eventVersion = options.longs === String ? String(message.eventVersion) : message.eventVersion;
            else
                object.eventVersion = options.longs === String ? $util.Long.prototype.toString.call(message.eventVersion) : options.longs === Number ? new $util.LongBits(message.eventVersion.low >>> 0, message.eventVersion.high >>> 0).toNumber(true) : message.eventVersion;
        if (message.hashModifier != null && message.hasOwnProperty("hashModifier"))
            object.hashModifier = $root.HashModifier.toObject(message.hashModifier, options);
        if (message.groupLinkSharingModification != null && message.hasOwnProperty("groupLinkSharingModification"))
            object.groupLinkSharingModification = $root.GroupLinkSharingModification.toObject(message.groupLinkSharingModification, options);
        return object;
    };

    /**
     * Converts this Event to JSON.
     * @function toJSON
     * @memberof Event
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Event.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Event;
})();

/**
 * ConversationType enum.
 * @exports ConversationType
 * @enum {string}
 * @property {number} CONVERSATION_TYPE_UNKNOWN=0 CONVERSATION_TYPE_UNKNOWN value
 * @property {number} CONVERSATION_TYPE_ONE_TO_ONE=1 CONVERSATION_TYPE_ONE_TO_ONE value
 * @property {number} CONVERSATION_TYPE_GROUP=2 CONVERSATION_TYPE_GROUP value
 */
$root.ConversationType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CONVERSATION_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "CONVERSATION_TYPE_ONE_TO_ONE"] = 1;
    values[valuesById[2] = "CONVERSATION_TYPE_GROUP"] = 2;
    return values;
})();

export const UserReadState = $root.UserReadState = (() => {

    /**
     * Properties of a UserReadState.
     * @exports IUserReadState
     * @interface IUserReadState
     * @property {IParticipantId|null} [participantId] UserReadState participantId
     * @property {number|Long|null} [latestReadTimestamp] UserReadState latestReadTimestamp
     */

    /**
     * Constructs a new UserReadState.
     * @exports UserReadState
     * @classdesc Represents a UserReadState.
     * @implements IUserReadState
     * @constructor
     * @param {IUserReadState=} [properties] Properties to set
     */
    function UserReadState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserReadState participantId.
     * @member {IParticipantId|null|undefined} participantId
     * @memberof UserReadState
     * @instance
     */
    UserReadState.prototype.participantId = null;

    /**
     * UserReadState latestReadTimestamp.
     * @member {number|Long} latestReadTimestamp
     * @memberof UserReadState
     * @instance
     */
    UserReadState.prototype.latestReadTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new UserReadState instance using the specified properties.
     * @function create
     * @memberof UserReadState
     * @static
     * @param {IUserReadState=} [properties] Properties to set
     * @returns {UserReadState} UserReadState instance
     */
    UserReadState.create = function create(properties) {
        return new UserReadState(properties);
    };

    /**
     * Encodes the specified UserReadState message. Does not implicitly {@link UserReadState.verify|verify} messages.
     * @function encode
     * @memberof UserReadState
     * @static
     * @param {IUserReadState} message UserReadState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserReadState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            $root.ParticipantId.encode(message.participantId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.latestReadTimestamp);
        return writer;
    };

    /**
     * Encodes the specified UserReadState message, length delimited. Does not implicitly {@link UserReadState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserReadState
     * @static
     * @param {IUserReadState} message UserReadState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserReadState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserReadState message from the specified reader or buffer.
     * @function decode
     * @memberof UserReadState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserReadState} UserReadState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserReadState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserReadState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.participantId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.latestReadTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserReadState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserReadState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserReadState} UserReadState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserReadState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserReadState message.
     * @function verify
     * @memberof UserReadState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserReadState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.participantId != null && message.hasOwnProperty("participantId")) {
            let error = $root.ParticipantId.verify(message.participantId);
            if (error)
                return "participantId." + error;
        }
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            if (!$util.isInteger(message.latestReadTimestamp) && !(message.latestReadTimestamp && $util.isInteger(message.latestReadTimestamp.low) && $util.isInteger(message.latestReadTimestamp.high)))
                return "latestReadTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a UserReadState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserReadState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserReadState} UserReadState
     */
    UserReadState.fromObject = function fromObject(object) {
        if (object instanceof $root.UserReadState)
            return object;
        let message = new $root.UserReadState();
        if (object.participantId != null) {
            if (typeof object.participantId !== "object")
                throw TypeError(".UserReadState.participantId: object expected");
            message.participantId = $root.ParticipantId.fromObject(object.participantId);
        }
        if (object.latestReadTimestamp != null)
            if ($util.Long)
                (message.latestReadTimestamp = $util.Long.fromValue(object.latestReadTimestamp)).unsigned = true;
            else if (typeof object.latestReadTimestamp === "string")
                message.latestReadTimestamp = parseInt(object.latestReadTimestamp, 10);
            else if (typeof object.latestReadTimestamp === "number")
                message.latestReadTimestamp = object.latestReadTimestamp;
            else if (typeof object.latestReadTimestamp === "object")
                message.latestReadTimestamp = new $util.LongBits(object.latestReadTimestamp.low >>> 0, object.latestReadTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a UserReadState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserReadState
     * @static
     * @param {UserReadState} message UserReadState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserReadState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.participantId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.latestReadTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.latestReadTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            object.participantId = $root.ParticipantId.toObject(message.participantId, options);
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            if (typeof message.latestReadTimestamp === "number")
                object.latestReadTimestamp = options.longs === String ? String(message.latestReadTimestamp) : message.latestReadTimestamp;
            else
                object.latestReadTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.latestReadTimestamp) : options.longs === Number ? new $util.LongBits(message.latestReadTimestamp.low >>> 0, message.latestReadTimestamp.high >>> 0).toNumber(true) : message.latestReadTimestamp;
        return object;
    };

    /**
     * Converts this UserReadState to JSON.
     * @function toJSON
     * @memberof UserReadState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserReadState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserReadState;
})();

/**
 * ConversationStatus enum.
 * @exports ConversationStatus
 * @enum {string}
 * @property {number} CONVERSATION_STATUS_UNKNOWN=0 CONVERSATION_STATUS_UNKNOWN value
 * @property {number} CONVERSATION_STATUS_INVITED=1 CONVERSATION_STATUS_INVITED value
 * @property {number} CONVERSATION_STATUS_ACTIVE=2 CONVERSATION_STATUS_ACTIVE value
 * @property {number} CONVERSATION_STATUS_LEFT=3 CONVERSATION_STATUS_LEFT value
 */
$root.ConversationStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CONVERSATION_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "CONVERSATION_STATUS_INVITED"] = 1;
    values[valuesById[2] = "CONVERSATION_STATUS_ACTIVE"] = 2;
    values[valuesById[3] = "CONVERSATION_STATUS_LEFT"] = 3;
    return values;
})();

/**
 * ConversationView enum.
 * @exports ConversationView
 * @enum {string}
 * @property {number} CONVERSATION_VIEW_UNKNOWN=0 CONVERSATION_VIEW_UNKNOWN value
 * @property {number} CONVERSATION_VIEW_INBOX=1 CONVERSATION_VIEW_INBOX value
 * @property {number} CONVERSATION_VIEW_ARCHIVED=2 CONVERSATION_VIEW_ARCHIVED value
 */
$root.ConversationView = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CONVERSATION_VIEW_UNKNOWN"] = 0;
    values[valuesById[1] = "CONVERSATION_VIEW_INBOX"] = 1;
    values[valuesById[2] = "CONVERSATION_VIEW_ARCHIVED"] = 2;
    return values;
})();

/**
 * DeliveryMediumType enum.
 * @exports DeliveryMediumType
 * @enum {string}
 * @property {number} DELIVERY_MEDIUM_UNKNOWN=0 DELIVERY_MEDIUM_UNKNOWN value
 * @property {number} DELIVERY_MEDIUM_BABEL=1 DELIVERY_MEDIUM_BABEL value
 * @property {number} DELIVERY_MEDIUM_GOOGLE_VOICE=2 DELIVERY_MEDIUM_GOOGLE_VOICE value
 * @property {number} DELIVERY_MEDIUM_LOCAL_SMS=3 DELIVERY_MEDIUM_LOCAL_SMS value
 */
$root.DeliveryMediumType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "DELIVERY_MEDIUM_UNKNOWN"] = 0;
    values[valuesById[1] = "DELIVERY_MEDIUM_BABEL"] = 1;
    values[valuesById[2] = "DELIVERY_MEDIUM_GOOGLE_VOICE"] = 2;
    values[valuesById[3] = "DELIVERY_MEDIUM_LOCAL_SMS"] = 3;
    return values;
})();

export const DeliveryMedium = $root.DeliveryMedium = (() => {

    /**
     * Properties of a DeliveryMedium.
     * @exports IDeliveryMedium
     * @interface IDeliveryMedium
     * @property {DeliveryMediumType|null} [mediumType] DeliveryMedium mediumType
     * @property {IPhoneNumber|null} [phoneNumber] DeliveryMedium phoneNumber
     */

    /**
     * Constructs a new DeliveryMedium.
     * @exports DeliveryMedium
     * @classdesc Represents a DeliveryMedium.
     * @implements IDeliveryMedium
     * @constructor
     * @param {IDeliveryMedium=} [properties] Properties to set
     */
    function DeliveryMedium(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeliveryMedium mediumType.
     * @member {DeliveryMediumType} mediumType
     * @memberof DeliveryMedium
     * @instance
     */
    DeliveryMedium.prototype.mediumType = 0;

    /**
     * DeliveryMedium phoneNumber.
     * @member {IPhoneNumber|null|undefined} phoneNumber
     * @memberof DeliveryMedium
     * @instance
     */
    DeliveryMedium.prototype.phoneNumber = null;

    /**
     * Creates a new DeliveryMedium instance using the specified properties.
     * @function create
     * @memberof DeliveryMedium
     * @static
     * @param {IDeliveryMedium=} [properties] Properties to set
     * @returns {DeliveryMedium} DeliveryMedium instance
     */
    DeliveryMedium.create = function create(properties) {
        return new DeliveryMedium(properties);
    };

    /**
     * Encodes the specified DeliveryMedium message. Does not implicitly {@link DeliveryMedium.verify|verify} messages.
     * @function encode
     * @memberof DeliveryMedium
     * @static
     * @param {IDeliveryMedium} message DeliveryMedium message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryMedium.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.mediumType != null && message.hasOwnProperty("mediumType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mediumType);
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            $root.PhoneNumber.encode(message.phoneNumber, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DeliveryMedium message, length delimited. Does not implicitly {@link DeliveryMedium.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeliveryMedium
     * @static
     * @param {IDeliveryMedium} message DeliveryMedium message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryMedium.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeliveryMedium message from the specified reader or buffer.
     * @function decode
     * @memberof DeliveryMedium
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeliveryMedium} DeliveryMedium
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryMedium.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeliveryMedium();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.mediumType = reader.int32();
                break;
            case 2:
                message.phoneNumber = $root.PhoneNumber.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeliveryMedium message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeliveryMedium
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeliveryMedium} DeliveryMedium
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryMedium.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeliveryMedium message.
     * @function verify
     * @memberof DeliveryMedium
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeliveryMedium.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.mediumType != null && message.hasOwnProperty("mediumType"))
            switch (message.mediumType) {
            default:
                return "mediumType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber")) {
            let error = $root.PhoneNumber.verify(message.phoneNumber);
            if (error)
                return "phoneNumber." + error;
        }
        return null;
    };

    /**
     * Creates a DeliveryMedium message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeliveryMedium
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeliveryMedium} DeliveryMedium
     */
    DeliveryMedium.fromObject = function fromObject(object) {
        if (object instanceof $root.DeliveryMedium)
            return object;
        let message = new $root.DeliveryMedium();
        switch (object.mediumType) {
        case "DELIVERY_MEDIUM_UNKNOWN":
        case 0:
            message.mediumType = 0;
            break;
        case "DELIVERY_MEDIUM_BABEL":
        case 1:
            message.mediumType = 1;
            break;
        case "DELIVERY_MEDIUM_GOOGLE_VOICE":
        case 2:
            message.mediumType = 2;
            break;
        case "DELIVERY_MEDIUM_LOCAL_SMS":
        case 3:
            message.mediumType = 3;
            break;
        }
        if (object.phoneNumber != null) {
            if (typeof object.phoneNumber !== "object")
                throw TypeError(".DeliveryMedium.phoneNumber: object expected");
            message.phoneNumber = $root.PhoneNumber.fromObject(object.phoneNumber);
        }
        return message;
    };

    /**
     * Creates a plain object from a DeliveryMedium message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeliveryMedium
     * @static
     * @param {DeliveryMedium} message DeliveryMedium
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeliveryMedium.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.mediumType = options.enums === String ? "DELIVERY_MEDIUM_UNKNOWN" : 0;
            object.phoneNumber = null;
        }
        if (message.mediumType != null && message.hasOwnProperty("mediumType"))
            object.mediumType = options.enums === String ? $root.DeliveryMediumType[message.mediumType] : message.mediumType;
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            object.phoneNumber = $root.PhoneNumber.toObject(message.phoneNumber, options);
        return object;
    };

    /**
     * Converts this DeliveryMedium to JSON.
     * @function toJSON
     * @memberof DeliveryMedium
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeliveryMedium.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeliveryMedium;
})();

export const DeliveryMediumOption = $root.DeliveryMediumOption = (() => {

    /**
     * Properties of a DeliveryMediumOption.
     * @exports IDeliveryMediumOption
     * @interface IDeliveryMediumOption
     * @property {IDeliveryMedium|null} [deliveryMedium] DeliveryMediumOption deliveryMedium
     * @property {boolean|null} [currentDefault] DeliveryMediumOption currentDefault
     */

    /**
     * Constructs a new DeliveryMediumOption.
     * @exports DeliveryMediumOption
     * @classdesc Represents a DeliveryMediumOption.
     * @implements IDeliveryMediumOption
     * @constructor
     * @param {IDeliveryMediumOption=} [properties] Properties to set
     */
    function DeliveryMediumOption(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeliveryMediumOption deliveryMedium.
     * @member {IDeliveryMedium|null|undefined} deliveryMedium
     * @memberof DeliveryMediumOption
     * @instance
     */
    DeliveryMediumOption.prototype.deliveryMedium = null;

    /**
     * DeliveryMediumOption currentDefault.
     * @member {boolean} currentDefault
     * @memberof DeliveryMediumOption
     * @instance
     */
    DeliveryMediumOption.prototype.currentDefault = false;

    /**
     * Creates a new DeliveryMediumOption instance using the specified properties.
     * @function create
     * @memberof DeliveryMediumOption
     * @static
     * @param {IDeliveryMediumOption=} [properties] Properties to set
     * @returns {DeliveryMediumOption} DeliveryMediumOption instance
     */
    DeliveryMediumOption.create = function create(properties) {
        return new DeliveryMediumOption(properties);
    };

    /**
     * Encodes the specified DeliveryMediumOption message. Does not implicitly {@link DeliveryMediumOption.verify|verify} messages.
     * @function encode
     * @memberof DeliveryMediumOption
     * @static
     * @param {IDeliveryMediumOption} message DeliveryMediumOption message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryMediumOption.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium"))
            $root.DeliveryMedium.encode(message.deliveryMedium, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.currentDefault != null && message.hasOwnProperty("currentDefault"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.currentDefault);
        return writer;
    };

    /**
     * Encodes the specified DeliveryMediumOption message, length delimited. Does not implicitly {@link DeliveryMediumOption.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeliveryMediumOption
     * @static
     * @param {IDeliveryMediumOption} message DeliveryMediumOption message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeliveryMediumOption.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeliveryMediumOption message from the specified reader or buffer.
     * @function decode
     * @memberof DeliveryMediumOption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeliveryMediumOption} DeliveryMediumOption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryMediumOption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeliveryMediumOption();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.deliveryMedium = $root.DeliveryMedium.decode(reader, reader.uint32());
                break;
            case 2:
                message.currentDefault = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeliveryMediumOption message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeliveryMediumOption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeliveryMediumOption} DeliveryMediumOption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeliveryMediumOption.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeliveryMediumOption message.
     * @function verify
     * @memberof DeliveryMediumOption
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeliveryMediumOption.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium")) {
            let error = $root.DeliveryMedium.verify(message.deliveryMedium);
            if (error)
                return "deliveryMedium." + error;
        }
        if (message.currentDefault != null && message.hasOwnProperty("currentDefault"))
            if (typeof message.currentDefault !== "boolean")
                return "currentDefault: boolean expected";
        return null;
    };

    /**
     * Creates a DeliveryMediumOption message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeliveryMediumOption
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeliveryMediumOption} DeliveryMediumOption
     */
    DeliveryMediumOption.fromObject = function fromObject(object) {
        if (object instanceof $root.DeliveryMediumOption)
            return object;
        let message = new $root.DeliveryMediumOption();
        if (object.deliveryMedium != null) {
            if (typeof object.deliveryMedium !== "object")
                throw TypeError(".DeliveryMediumOption.deliveryMedium: object expected");
            message.deliveryMedium = $root.DeliveryMedium.fromObject(object.deliveryMedium);
        }
        if (object.currentDefault != null)
            message.currentDefault = Boolean(object.currentDefault);
        return message;
    };

    /**
     * Creates a plain object from a DeliveryMediumOption message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeliveryMediumOption
     * @static
     * @param {DeliveryMediumOption} message DeliveryMediumOption
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeliveryMediumOption.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.deliveryMedium = null;
            object.currentDefault = false;
        }
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium"))
            object.deliveryMedium = $root.DeliveryMedium.toObject(message.deliveryMedium, options);
        if (message.currentDefault != null && message.hasOwnProperty("currentDefault"))
            object.currentDefault = message.currentDefault;
        return object;
    };

    /**
     * Converts this DeliveryMediumOption to JSON.
     * @function toJSON
     * @memberof DeliveryMediumOption
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeliveryMediumOption.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeliveryMediumOption;
})();

/**
 * InvitationAffinity enum.
 * @exports InvitationAffinity
 * @enum {string}
 * @property {number} INVITE_AFFINITY_UNKNOWN=0 INVITE_AFFINITY_UNKNOWN value
 * @property {number} INVITE_AFFINITY_HIGH=1 INVITE_AFFINITY_HIGH value
 * @property {number} INVITE_AFFINITY_LOW=2 INVITE_AFFINITY_LOW value
 */
$root.InvitationAffinity = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "INVITE_AFFINITY_UNKNOWN"] = 0;
    values[valuesById[1] = "INVITE_AFFINITY_HIGH"] = 1;
    values[valuesById[2] = "INVITE_AFFINITY_LOW"] = 2;
    return values;
})();

export const UserConversationState = $root.UserConversationState = (() => {

    /**
     * Properties of a UserConversationState.
     * @exports IUserConversationState
     * @interface IUserConversationState
     * @property {string|null} [clientGeneratedId] UserConversationState clientGeneratedId
     * @property {IUserReadState|null} [selfReadState] UserConversationState selfReadState
     * @property {ConversationStatus|null} [status] UserConversationState status
     * @property {NotificationLevel|null} [notificationLevel] UserConversationState notificationLevel
     * @property {Array.<ConversationView>|null} [view] UserConversationState view
     * @property {IParticipantId|null} [inviterId] UserConversationState inviterId
     * @property {number|Long|null} [inviteTimestamp] UserConversationState inviteTimestamp
     * @property {number|Long|null} [sortTimestamp] UserConversationState sortTimestamp
     * @property {number|Long|null} [activeTimestamp] UserConversationState activeTimestamp
     * @property {InvitationAffinity|null} [inviteAffinity] UserConversationState inviteAffinity
     * @property {Array.<IDeliveryMediumOption>|null} [deliveryMediumOption] UserConversationState deliveryMediumOption
     */

    /**
     * Constructs a new UserConversationState.
     * @exports UserConversationState
     * @classdesc Represents a UserConversationState.
     * @implements IUserConversationState
     * @constructor
     * @param {IUserConversationState=} [properties] Properties to set
     */
    function UserConversationState(properties) {
        this.view = [];
        this.deliveryMediumOption = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UserConversationState clientGeneratedId.
     * @member {string} clientGeneratedId
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.clientGeneratedId = "";

    /**
     * UserConversationState selfReadState.
     * @member {IUserReadState|null|undefined} selfReadState
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.selfReadState = null;

    /**
     * UserConversationState status.
     * @member {ConversationStatus} status
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.status = 0;

    /**
     * UserConversationState notificationLevel.
     * @member {NotificationLevel} notificationLevel
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.notificationLevel = 0;

    /**
     * UserConversationState view.
     * @member {Array.<ConversationView>} view
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.view = $util.emptyArray;

    /**
     * UserConversationState inviterId.
     * @member {IParticipantId|null|undefined} inviterId
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.inviterId = null;

    /**
     * UserConversationState inviteTimestamp.
     * @member {number|Long} inviteTimestamp
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.inviteTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UserConversationState sortTimestamp.
     * @member {number|Long} sortTimestamp
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.sortTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UserConversationState activeTimestamp.
     * @member {number|Long} activeTimestamp
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.activeTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * UserConversationState inviteAffinity.
     * @member {InvitationAffinity} inviteAffinity
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.inviteAffinity = 0;

    /**
     * UserConversationState deliveryMediumOption.
     * @member {Array.<IDeliveryMediumOption>} deliveryMediumOption
     * @memberof UserConversationState
     * @instance
     */
    UserConversationState.prototype.deliveryMediumOption = $util.emptyArray;

    /**
     * Creates a new UserConversationState instance using the specified properties.
     * @function create
     * @memberof UserConversationState
     * @static
     * @param {IUserConversationState=} [properties] Properties to set
     * @returns {UserConversationState} UserConversationState instance
     */
    UserConversationState.create = function create(properties) {
        return new UserConversationState(properties);
    };

    /**
     * Encodes the specified UserConversationState message. Does not implicitly {@link UserConversationState.verify|verify} messages.
     * @function encode
     * @memberof UserConversationState
     * @static
     * @param {IUserConversationState} message UserConversationState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserConversationState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientGeneratedId);
        if (message.selfReadState != null && message.hasOwnProperty("selfReadState"))
            $root.UserReadState.encode(message.selfReadState, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.status != null && message.hasOwnProperty("status"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.status);
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.notificationLevel);
        if (message.view != null && message.view.length)
            for (let i = 0; i < message.view.length; ++i)
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.view[i]);
        if (message.inviterId != null && message.hasOwnProperty("inviterId"))
            $root.ParticipantId.encode(message.inviterId, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.inviteTimestamp != null && message.hasOwnProperty("inviteTimestamp"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.inviteTimestamp);
        if (message.sortTimestamp != null && message.hasOwnProperty("sortTimestamp"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.sortTimestamp);
        if (message.activeTimestamp != null && message.hasOwnProperty("activeTimestamp"))
            writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.activeTimestamp);
        if (message.inviteAffinity != null && message.hasOwnProperty("inviteAffinity"))
            writer.uint32(/* id 15, wireType 0 =*/120).int32(message.inviteAffinity);
        if (message.deliveryMediumOption != null && message.deliveryMediumOption.length)
            for (let i = 0; i < message.deliveryMediumOption.length; ++i)
                $root.DeliveryMediumOption.encode(message.deliveryMediumOption[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UserConversationState message, length delimited. Does not implicitly {@link UserConversationState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UserConversationState
     * @static
     * @param {IUserConversationState} message UserConversationState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UserConversationState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a UserConversationState message from the specified reader or buffer.
     * @function decode
     * @memberof UserConversationState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UserConversationState} UserConversationState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserConversationState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UserConversationState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 2:
                message.clientGeneratedId = reader.string();
                break;
            case 7:
                message.selfReadState = $root.UserReadState.decode(reader, reader.uint32());
                break;
            case 8:
                message.status = reader.int32();
                break;
            case 9:
                message.notificationLevel = reader.int32();
                break;
            case 10:
                if (!(message.view && message.view.length))
                    message.view = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.view.push(reader.int32());
                } else
                    message.view.push(reader.int32());
                break;
            case 11:
                message.inviterId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 12:
                message.inviteTimestamp = reader.uint64();
                break;
            case 13:
                message.sortTimestamp = reader.uint64();
                break;
            case 14:
                message.activeTimestamp = reader.uint64();
                break;
            case 15:
                message.inviteAffinity = reader.int32();
                break;
            case 17:
                if (!(message.deliveryMediumOption && message.deliveryMediumOption.length))
                    message.deliveryMediumOption = [];
                message.deliveryMediumOption.push($root.DeliveryMediumOption.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a UserConversationState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UserConversationState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UserConversationState} UserConversationState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UserConversationState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a UserConversationState message.
     * @function verify
     * @memberof UserConversationState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UserConversationState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (!$util.isString(message.clientGeneratedId))
                return "clientGeneratedId: string expected";
        if (message.selfReadState != null && message.hasOwnProperty("selfReadState")) {
            let error = $root.UserReadState.verify(message.selfReadState);
            if (error)
                return "selfReadState." + error;
        }
        if (message.status != null && message.hasOwnProperty("status"))
            switch (message.status) {
            default:
                return "status: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            switch (message.notificationLevel) {
            default:
                return "notificationLevel: enum value expected";
            case 0:
            case 10:
            case 30:
                break;
            }
        if (message.view != null && message.hasOwnProperty("view")) {
            if (!Array.isArray(message.view))
                return "view: array expected";
            for (let i = 0; i < message.view.length; ++i)
                switch (message.view[i]) {
                default:
                    return "view: enum value[] expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
        }
        if (message.inviterId != null && message.hasOwnProperty("inviterId")) {
            let error = $root.ParticipantId.verify(message.inviterId);
            if (error)
                return "inviterId." + error;
        }
        if (message.inviteTimestamp != null && message.hasOwnProperty("inviteTimestamp"))
            if (!$util.isInteger(message.inviteTimestamp) && !(message.inviteTimestamp && $util.isInteger(message.inviteTimestamp.low) && $util.isInteger(message.inviteTimestamp.high)))
                return "inviteTimestamp: integer|Long expected";
        if (message.sortTimestamp != null && message.hasOwnProperty("sortTimestamp"))
            if (!$util.isInteger(message.sortTimestamp) && !(message.sortTimestamp && $util.isInteger(message.sortTimestamp.low) && $util.isInteger(message.sortTimestamp.high)))
                return "sortTimestamp: integer|Long expected";
        if (message.activeTimestamp != null && message.hasOwnProperty("activeTimestamp"))
            if (!$util.isInteger(message.activeTimestamp) && !(message.activeTimestamp && $util.isInteger(message.activeTimestamp.low) && $util.isInteger(message.activeTimestamp.high)))
                return "activeTimestamp: integer|Long expected";
        if (message.inviteAffinity != null && message.hasOwnProperty("inviteAffinity"))
            switch (message.inviteAffinity) {
            default:
                return "inviteAffinity: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.deliveryMediumOption != null && message.hasOwnProperty("deliveryMediumOption")) {
            if (!Array.isArray(message.deliveryMediumOption))
                return "deliveryMediumOption: array expected";
            for (let i = 0; i < message.deliveryMediumOption.length; ++i) {
                let error = $root.DeliveryMediumOption.verify(message.deliveryMediumOption[i]);
                if (error)
                    return "deliveryMediumOption." + error;
            }
        }
        return null;
    };

    /**
     * Creates a UserConversationState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UserConversationState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UserConversationState} UserConversationState
     */
    UserConversationState.fromObject = function fromObject(object) {
        if (object instanceof $root.UserConversationState)
            return object;
        let message = new $root.UserConversationState();
        if (object.clientGeneratedId != null)
            message.clientGeneratedId = String(object.clientGeneratedId);
        if (object.selfReadState != null) {
            if (typeof object.selfReadState !== "object")
                throw TypeError(".UserConversationState.selfReadState: object expected");
            message.selfReadState = $root.UserReadState.fromObject(object.selfReadState);
        }
        switch (object.status) {
        case "CONVERSATION_STATUS_UNKNOWN":
        case 0:
            message.status = 0;
            break;
        case "CONVERSATION_STATUS_INVITED":
        case 1:
            message.status = 1;
            break;
        case "CONVERSATION_STATUS_ACTIVE":
        case 2:
            message.status = 2;
            break;
        case "CONVERSATION_STATUS_LEFT":
        case 3:
            message.status = 3;
            break;
        }
        switch (object.notificationLevel) {
        case "NOTIFICATION_LEVEL_UNKNOWN":
        case 0:
            message.notificationLevel = 0;
            break;
        case "NOTIFICATION_LEVEL_QUIET":
        case 10:
            message.notificationLevel = 10;
            break;
        case "NOTIFICATION_LEVEL_RING":
        case 30:
            message.notificationLevel = 30;
            break;
        }
        if (object.view) {
            if (!Array.isArray(object.view))
                throw TypeError(".UserConversationState.view: array expected");
            message.view = [];
            for (let i = 0; i < object.view.length; ++i)
                switch (object.view[i]) {
                default:
                case "CONVERSATION_VIEW_UNKNOWN":
                case 0:
                    message.view[i] = 0;
                    break;
                case "CONVERSATION_VIEW_INBOX":
                case 1:
                    message.view[i] = 1;
                    break;
                case "CONVERSATION_VIEW_ARCHIVED":
                case 2:
                    message.view[i] = 2;
                    break;
                }
        }
        if (object.inviterId != null) {
            if (typeof object.inviterId !== "object")
                throw TypeError(".UserConversationState.inviterId: object expected");
            message.inviterId = $root.ParticipantId.fromObject(object.inviterId);
        }
        if (object.inviteTimestamp != null)
            if ($util.Long)
                (message.inviteTimestamp = $util.Long.fromValue(object.inviteTimestamp)).unsigned = true;
            else if (typeof object.inviteTimestamp === "string")
                message.inviteTimestamp = parseInt(object.inviteTimestamp, 10);
            else if (typeof object.inviteTimestamp === "number")
                message.inviteTimestamp = object.inviteTimestamp;
            else if (typeof object.inviteTimestamp === "object")
                message.inviteTimestamp = new $util.LongBits(object.inviteTimestamp.low >>> 0, object.inviteTimestamp.high >>> 0).toNumber(true);
        if (object.sortTimestamp != null)
            if ($util.Long)
                (message.sortTimestamp = $util.Long.fromValue(object.sortTimestamp)).unsigned = true;
            else if (typeof object.sortTimestamp === "string")
                message.sortTimestamp = parseInt(object.sortTimestamp, 10);
            else if (typeof object.sortTimestamp === "number")
                message.sortTimestamp = object.sortTimestamp;
            else if (typeof object.sortTimestamp === "object")
                message.sortTimestamp = new $util.LongBits(object.sortTimestamp.low >>> 0, object.sortTimestamp.high >>> 0).toNumber(true);
        if (object.activeTimestamp != null)
            if ($util.Long)
                (message.activeTimestamp = $util.Long.fromValue(object.activeTimestamp)).unsigned = true;
            else if (typeof object.activeTimestamp === "string")
                message.activeTimestamp = parseInt(object.activeTimestamp, 10);
            else if (typeof object.activeTimestamp === "number")
                message.activeTimestamp = object.activeTimestamp;
            else if (typeof object.activeTimestamp === "object")
                message.activeTimestamp = new $util.LongBits(object.activeTimestamp.low >>> 0, object.activeTimestamp.high >>> 0).toNumber(true);
        switch (object.inviteAffinity) {
        case "INVITE_AFFINITY_UNKNOWN":
        case 0:
            message.inviteAffinity = 0;
            break;
        case "INVITE_AFFINITY_HIGH":
        case 1:
            message.inviteAffinity = 1;
            break;
        case "INVITE_AFFINITY_LOW":
        case 2:
            message.inviteAffinity = 2;
            break;
        }
        if (object.deliveryMediumOption) {
            if (!Array.isArray(object.deliveryMediumOption))
                throw TypeError(".UserConversationState.deliveryMediumOption: array expected");
            message.deliveryMediumOption = [];
            for (let i = 0; i < object.deliveryMediumOption.length; ++i) {
                if (typeof object.deliveryMediumOption[i] !== "object")
                    throw TypeError(".UserConversationState.deliveryMediumOption: object expected");
                message.deliveryMediumOption[i] = $root.DeliveryMediumOption.fromObject(object.deliveryMediumOption[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a UserConversationState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UserConversationState
     * @static
     * @param {UserConversationState} message UserConversationState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UserConversationState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.view = [];
            object.deliveryMediumOption = [];
        }
        if (options.defaults) {
            object.clientGeneratedId = "";
            object.selfReadState = null;
            object.status = options.enums === String ? "CONVERSATION_STATUS_UNKNOWN" : 0;
            object.notificationLevel = options.enums === String ? "NOTIFICATION_LEVEL_UNKNOWN" : 0;
            object.inviterId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.inviteTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.inviteTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.sortTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.sortTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.activeTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.activeTimestamp = options.longs === String ? "0" : 0;
            object.inviteAffinity = options.enums === String ? "INVITE_AFFINITY_UNKNOWN" : 0;
        }
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            object.clientGeneratedId = message.clientGeneratedId;
        if (message.selfReadState != null && message.hasOwnProperty("selfReadState"))
            object.selfReadState = $root.UserReadState.toObject(message.selfReadState, options);
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = options.enums === String ? $root.ConversationStatus[message.status] : message.status;
        if (message.notificationLevel != null && message.hasOwnProperty("notificationLevel"))
            object.notificationLevel = options.enums === String ? $root.NotificationLevel[message.notificationLevel] : message.notificationLevel;
        if (message.view && message.view.length) {
            object.view = [];
            for (let j = 0; j < message.view.length; ++j)
                object.view[j] = options.enums === String ? $root.ConversationView[message.view[j]] : message.view[j];
        }
        if (message.inviterId != null && message.hasOwnProperty("inviterId"))
            object.inviterId = $root.ParticipantId.toObject(message.inviterId, options);
        if (message.inviteTimestamp != null && message.hasOwnProperty("inviteTimestamp"))
            if (typeof message.inviteTimestamp === "number")
                object.inviteTimestamp = options.longs === String ? String(message.inviteTimestamp) : message.inviteTimestamp;
            else
                object.inviteTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.inviteTimestamp) : options.longs === Number ? new $util.LongBits(message.inviteTimestamp.low >>> 0, message.inviteTimestamp.high >>> 0).toNumber(true) : message.inviteTimestamp;
        if (message.sortTimestamp != null && message.hasOwnProperty("sortTimestamp"))
            if (typeof message.sortTimestamp === "number")
                object.sortTimestamp = options.longs === String ? String(message.sortTimestamp) : message.sortTimestamp;
            else
                object.sortTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.sortTimestamp) : options.longs === Number ? new $util.LongBits(message.sortTimestamp.low >>> 0, message.sortTimestamp.high >>> 0).toNumber(true) : message.sortTimestamp;
        if (message.activeTimestamp != null && message.hasOwnProperty("activeTimestamp"))
            if (typeof message.activeTimestamp === "number")
                object.activeTimestamp = options.longs === String ? String(message.activeTimestamp) : message.activeTimestamp;
            else
                object.activeTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.activeTimestamp) : options.longs === Number ? new $util.LongBits(message.activeTimestamp.low >>> 0, message.activeTimestamp.high >>> 0).toNumber(true) : message.activeTimestamp;
        if (message.inviteAffinity != null && message.hasOwnProperty("inviteAffinity"))
            object.inviteAffinity = options.enums === String ? $root.InvitationAffinity[message.inviteAffinity] : message.inviteAffinity;
        if (message.deliveryMediumOption && message.deliveryMediumOption.length) {
            object.deliveryMediumOption = [];
            for (let j = 0; j < message.deliveryMediumOption.length; ++j)
                object.deliveryMediumOption[j] = $root.DeliveryMediumOption.toObject(message.deliveryMediumOption[j], options);
        }
        return object;
    };

    /**
     * Converts this UserConversationState to JSON.
     * @function toJSON
     * @memberof UserConversationState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UserConversationState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UserConversationState;
})();

/**
 * ParticipantType enum.
 * @exports ParticipantType
 * @enum {string}
 * @property {number} PARTICIPANT_TYPE_UNKNOWN=0 PARTICIPANT_TYPE_UNKNOWN value
 * @property {number} PARTICIPANT_TYPE_GAIA=2 PARTICIPANT_TYPE_GAIA value
 * @property {number} PARTICIPANT_TYPE_GOOGLE_VOICE=3 PARTICIPANT_TYPE_GOOGLE_VOICE value
 */
$root.ParticipantType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PARTICIPANT_TYPE_UNKNOWN"] = 0;
    values[valuesById[2] = "PARTICIPANT_TYPE_GAIA"] = 2;
    values[valuesById[3] = "PARTICIPANT_TYPE_GOOGLE_VOICE"] = 3;
    return values;
})();

/**
 * InvitationStatus enum.
 * @exports InvitationStatus
 * @enum {string}
 * @property {number} INVITATION_STATUS_UNKNOWN=0 INVITATION_STATUS_UNKNOWN value
 * @property {number} INVITATION_STATUS_PENDING=1 INVITATION_STATUS_PENDING value
 * @property {number} INVITATION_STATUS_ACCEPTED=2 INVITATION_STATUS_ACCEPTED value
 */
$root.InvitationStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "INVITATION_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "INVITATION_STATUS_PENDING"] = 1;
    values[valuesById[2] = "INVITATION_STATUS_ACCEPTED"] = 2;
    return values;
})();

export const ConversationParticipantData = $root.ConversationParticipantData = (() => {

    /**
     * Properties of a ConversationParticipantData.
     * @exports IConversationParticipantData
     * @interface IConversationParticipantData
     * @property {IParticipantId|null} [id] ConversationParticipantData id
     * @property {string|null} [fallbackName] ConversationParticipantData fallbackName
     * @property {InvitationStatus|null} [invitationStatus] ConversationParticipantData invitationStatus
     * @property {ParticipantType|null} [participantType] ConversationParticipantData participantType
     * @property {InvitationStatus|null} [newInvitationStatus] ConversationParticipantData newInvitationStatus
     */

    /**
     * Constructs a new ConversationParticipantData.
     * @exports ConversationParticipantData
     * @classdesc Represents a ConversationParticipantData.
     * @implements IConversationParticipantData
     * @constructor
     * @param {IConversationParticipantData=} [properties] Properties to set
     */
    function ConversationParticipantData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationParticipantData id.
     * @member {IParticipantId|null|undefined} id
     * @memberof ConversationParticipantData
     * @instance
     */
    ConversationParticipantData.prototype.id = null;

    /**
     * ConversationParticipantData fallbackName.
     * @member {string} fallbackName
     * @memberof ConversationParticipantData
     * @instance
     */
    ConversationParticipantData.prototype.fallbackName = "";

    /**
     * ConversationParticipantData invitationStatus.
     * @member {InvitationStatus} invitationStatus
     * @memberof ConversationParticipantData
     * @instance
     */
    ConversationParticipantData.prototype.invitationStatus = 0;

    /**
     * ConversationParticipantData participantType.
     * @member {ParticipantType} participantType
     * @memberof ConversationParticipantData
     * @instance
     */
    ConversationParticipantData.prototype.participantType = 0;

    /**
     * ConversationParticipantData newInvitationStatus.
     * @member {InvitationStatus} newInvitationStatus
     * @memberof ConversationParticipantData
     * @instance
     */
    ConversationParticipantData.prototype.newInvitationStatus = 0;

    /**
     * Creates a new ConversationParticipantData instance using the specified properties.
     * @function create
     * @memberof ConversationParticipantData
     * @static
     * @param {IConversationParticipantData=} [properties] Properties to set
     * @returns {ConversationParticipantData} ConversationParticipantData instance
     */
    ConversationParticipantData.create = function create(properties) {
        return new ConversationParticipantData(properties);
    };

    /**
     * Encodes the specified ConversationParticipantData message. Does not implicitly {@link ConversationParticipantData.verify|verify} messages.
     * @function encode
     * @memberof ConversationParticipantData
     * @static
     * @param {IConversationParticipantData} message ConversationParticipantData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationParticipantData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && message.hasOwnProperty("id"))
            $root.ParticipantId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.fallbackName);
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.invitationStatus);
        if (message.participantType != null && message.hasOwnProperty("participantType"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.participantType);
        if (message.newInvitationStatus != null && message.hasOwnProperty("newInvitationStatus"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.newInvitationStatus);
        return writer;
    };

    /**
     * Encodes the specified ConversationParticipantData message, length delimited. Does not implicitly {@link ConversationParticipantData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationParticipantData
     * @static
     * @param {IConversationParticipantData} message ConversationParticipantData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationParticipantData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationParticipantData message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationParticipantData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationParticipantData} ConversationParticipantData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationParticipantData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationParticipantData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.id = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.fallbackName = reader.string();
                break;
            case 3:
                message.invitationStatus = reader.int32();
                break;
            case 5:
                message.participantType = reader.int32();
                break;
            case 6:
                message.newInvitationStatus = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationParticipantData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationParticipantData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationParticipantData} ConversationParticipantData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationParticipantData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationParticipantData message.
     * @function verify
     * @memberof ConversationParticipantData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationParticipantData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id")) {
            let error = $root.ParticipantId.verify(message.id);
            if (error)
                return "id." + error;
        }
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            if (!$util.isString(message.fallbackName))
                return "fallbackName: string expected";
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            switch (message.invitationStatus) {
            default:
                return "invitationStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.participantType != null && message.hasOwnProperty("participantType"))
            switch (message.participantType) {
            default:
                return "participantType: enum value expected";
            case 0:
            case 2:
            case 3:
                break;
            }
        if (message.newInvitationStatus != null && message.hasOwnProperty("newInvitationStatus"))
            switch (message.newInvitationStatus) {
            default:
                return "newInvitationStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a ConversationParticipantData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationParticipantData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationParticipantData} ConversationParticipantData
     */
    ConversationParticipantData.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationParticipantData)
            return object;
        let message = new $root.ConversationParticipantData();
        if (object.id != null) {
            if (typeof object.id !== "object")
                throw TypeError(".ConversationParticipantData.id: object expected");
            message.id = $root.ParticipantId.fromObject(object.id);
        }
        if (object.fallbackName != null)
            message.fallbackName = String(object.fallbackName);
        switch (object.invitationStatus) {
        case "INVITATION_STATUS_UNKNOWN":
        case 0:
            message.invitationStatus = 0;
            break;
        case "INVITATION_STATUS_PENDING":
        case 1:
            message.invitationStatus = 1;
            break;
        case "INVITATION_STATUS_ACCEPTED":
        case 2:
            message.invitationStatus = 2;
            break;
        }
        switch (object.participantType) {
        case "PARTICIPANT_TYPE_UNKNOWN":
        case 0:
            message.participantType = 0;
            break;
        case "PARTICIPANT_TYPE_GAIA":
        case 2:
            message.participantType = 2;
            break;
        case "PARTICIPANT_TYPE_GOOGLE_VOICE":
        case 3:
            message.participantType = 3;
            break;
        }
        switch (object.newInvitationStatus) {
        case "INVITATION_STATUS_UNKNOWN":
        case 0:
            message.newInvitationStatus = 0;
            break;
        case "INVITATION_STATUS_PENDING":
        case 1:
            message.newInvitationStatus = 1;
            break;
        case "INVITATION_STATUS_ACCEPTED":
        case 2:
            message.newInvitationStatus = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ConversationParticipantData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationParticipantData
     * @static
     * @param {ConversationParticipantData} message ConversationParticipantData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationParticipantData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = null;
            object.fallbackName = "";
            object.invitationStatus = options.enums === String ? "INVITATION_STATUS_UNKNOWN" : 0;
            object.participantType = options.enums === String ? "PARTICIPANT_TYPE_UNKNOWN" : 0;
            object.newInvitationStatus = options.enums === String ? "INVITATION_STATUS_UNKNOWN" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = $root.ParticipantId.toObject(message.id, options);
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            object.fallbackName = message.fallbackName;
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            object.invitationStatus = options.enums === String ? $root.InvitationStatus[message.invitationStatus] : message.invitationStatus;
        if (message.participantType != null && message.hasOwnProperty("participantType"))
            object.participantType = options.enums === String ? $root.ParticipantType[message.participantType] : message.participantType;
        if (message.newInvitationStatus != null && message.hasOwnProperty("newInvitationStatus"))
            object.newInvitationStatus = options.enums === String ? $root.InvitationStatus[message.newInvitationStatus] : message.newInvitationStatus;
        return object;
    };

    /**
     * Converts this ConversationParticipantData to JSON.
     * @function toJSON
     * @memberof ConversationParticipantData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationParticipantData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationParticipantData;
})();

/**
 * ForceHistory enum.
 * @exports ForceHistory
 * @enum {string}
 * @property {number} FORCE_HISTORY_UNKNOWN=0 FORCE_HISTORY_UNKNOWN value
 * @property {number} FORCE_HISTORY_NO=1 FORCE_HISTORY_NO value
 */
$root.ForceHistory = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "FORCE_HISTORY_UNKNOWN"] = 0;
    values[valuesById[1] = "FORCE_HISTORY_NO"] = 1;
    return values;
})();

/**
 * NetworkType enum.
 * @exports NetworkType
 * @enum {string}
 * @property {number} NETWORK_TYPE_UNKNOWN=0 NETWORK_TYPE_UNKNOWN value
 * @property {number} NETWORK_TYPE_BABEL=1 NETWORK_TYPE_BABEL value
 * @property {number} NETWORK_TYPE_GOOGLE_VOICE=2 NETWORK_TYPE_GOOGLE_VOICE value
 */
$root.NetworkType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "NETWORK_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "NETWORK_TYPE_BABEL"] = 1;
    values[valuesById[2] = "NETWORK_TYPE_GOOGLE_VOICE"] = 2;
    return values;
})();

export const Conversation = $root.Conversation = (() => {

    /**
     * Properties of a Conversation.
     * @exports IConversation
     * @interface IConversation
     * @property {IConversationId|null} [conversationId] Conversation conversationId
     * @property {ConversationType|null} [type] Conversation type
     * @property {string|null} [name] Conversation name
     * @property {IUserConversationState|null} [selfConversationState] Conversation selfConversationState
     * @property {Array.<IUserReadState>|null} [readState] Conversation readState
     * @property {boolean|null} [hasActiveHangout] Conversation hasActiveHangout
     * @property {OffTheRecordStatus|null} [otrStatus] Conversation otrStatus
     * @property {OffTheRecordToggle|null} [otrToggle] Conversation otrToggle
     * @property {boolean|null} [conversationHistorySupported] Conversation conversationHistorySupported
     * @property {Array.<IParticipantId>|null} [currentParticipant] Conversation currentParticipant
     * @property {Array.<IConversationParticipantData>|null} [participantData] Conversation participantData
     * @property {Array.<NetworkType>|null} [networkType] Conversation networkType
     * @property {ForceHistory|null} [forceHistoryState] Conversation forceHistoryState
     * @property {GroupLinkSharingStatus|null} [groupLinkSharingStatus] Conversation groupLinkSharingStatus
     */

    /**
     * Constructs a new Conversation.
     * @exports Conversation
     * @classdesc Represents a Conversation.
     * @implements IConversation
     * @constructor
     * @param {IConversation=} [properties] Properties to set
     */
    function Conversation(properties) {
        this.readState = [];
        this.currentParticipant = [];
        this.participantData = [];
        this.networkType = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Conversation conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.conversationId = null;

    /**
     * Conversation type.
     * @member {ConversationType} type
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.type = 0;

    /**
     * Conversation name.
     * @member {string} name
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.name = "";

    /**
     * Conversation selfConversationState.
     * @member {IUserConversationState|null|undefined} selfConversationState
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.selfConversationState = null;

    /**
     * Conversation readState.
     * @member {Array.<IUserReadState>} readState
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.readState = $util.emptyArray;

    /**
     * Conversation hasActiveHangout.
     * @member {boolean} hasActiveHangout
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.hasActiveHangout = false;

    /**
     * Conversation otrStatus.
     * @member {OffTheRecordStatus} otrStatus
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.otrStatus = 0;

    /**
     * Conversation otrToggle.
     * @member {OffTheRecordToggle} otrToggle
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.otrToggle = 0;

    /**
     * Conversation conversationHistorySupported.
     * @member {boolean} conversationHistorySupported
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.conversationHistorySupported = false;

    /**
     * Conversation currentParticipant.
     * @member {Array.<IParticipantId>} currentParticipant
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.currentParticipant = $util.emptyArray;

    /**
     * Conversation participantData.
     * @member {Array.<IConversationParticipantData>} participantData
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.participantData = $util.emptyArray;

    /**
     * Conversation networkType.
     * @member {Array.<NetworkType>} networkType
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.networkType = $util.emptyArray;

    /**
     * Conversation forceHistoryState.
     * @member {ForceHistory} forceHistoryState
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.forceHistoryState = 0;

    /**
     * Conversation groupLinkSharingStatus.
     * @member {GroupLinkSharingStatus} groupLinkSharingStatus
     * @memberof Conversation
     * @instance
     */
    Conversation.prototype.groupLinkSharingStatus = 0;

    /**
     * Creates a new Conversation instance using the specified properties.
     * @function create
     * @memberof Conversation
     * @static
     * @param {IConversation=} [properties] Properties to set
     * @returns {Conversation} Conversation instance
     */
    Conversation.create = function create(properties) {
        return new Conversation(properties);
    };

    /**
     * Encodes the specified Conversation message. Does not implicitly {@link Conversation.verify|verify} messages.
     * @function encode
     * @memberof Conversation
     * @static
     * @param {IConversation} message Conversation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Conversation.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
        if (message.selfConversationState != null && message.hasOwnProperty("selfConversationState"))
            $root.UserConversationState.encode(message.selfConversationState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.readState != null && message.readState.length)
            for (let i = 0; i < message.readState.length; ++i)
                $root.UserReadState.encode(message.readState[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.hasActiveHangout != null && message.hasOwnProperty("hasActiveHangout"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasActiveHangout);
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.otrStatus);
        if (message.otrToggle != null && message.hasOwnProperty("otrToggle"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.otrToggle);
        if (message.conversationHistorySupported != null && message.hasOwnProperty("conversationHistorySupported"))
            writer.uint32(/* id 12, wireType 0 =*/96).bool(message.conversationHistorySupported);
        if (message.currentParticipant != null && message.currentParticipant.length)
            for (let i = 0; i < message.currentParticipant.length; ++i)
                $root.ParticipantId.encode(message.currentParticipant[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.participantData != null && message.participantData.length)
            for (let i = 0; i < message.participantData.length; ++i)
                $root.ConversationParticipantData.encode(message.participantData[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.networkType != null && message.networkType.length)
            for (let i = 0; i < message.networkType.length; ++i)
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.networkType[i]);
        if (message.forceHistoryState != null && message.hasOwnProperty("forceHistoryState"))
            writer.uint32(/* id 19, wireType 0 =*/152).int32(message.forceHistoryState);
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            writer.uint32(/* id 22, wireType 0 =*/176).int32(message.groupLinkSharingStatus);
        return writer;
    };

    /**
     * Encodes the specified Conversation message, length delimited. Does not implicitly {@link Conversation.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Conversation
     * @static
     * @param {IConversation} message Conversation message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Conversation.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Conversation message from the specified reader or buffer.
     * @function decode
     * @memberof Conversation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Conversation} Conversation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Conversation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Conversation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.type = reader.int32();
                break;
            case 3:
                message.name = reader.string();
                break;
            case 4:
                message.selfConversationState = $root.UserConversationState.decode(reader, reader.uint32());
                break;
            case 8:
                if (!(message.readState && message.readState.length))
                    message.readState = [];
                message.readState.push($root.UserReadState.decode(reader, reader.uint32()));
                break;
            case 9:
                message.hasActiveHangout = reader.bool();
                break;
            case 10:
                message.otrStatus = reader.int32();
                break;
            case 11:
                message.otrToggle = reader.int32();
                break;
            case 12:
                message.conversationHistorySupported = reader.bool();
                break;
            case 13:
                if (!(message.currentParticipant && message.currentParticipant.length))
                    message.currentParticipant = [];
                message.currentParticipant.push($root.ParticipantId.decode(reader, reader.uint32()));
                break;
            case 14:
                if (!(message.participantData && message.participantData.length))
                    message.participantData = [];
                message.participantData.push($root.ConversationParticipantData.decode(reader, reader.uint32()));
                break;
            case 18:
                if (!(message.networkType && message.networkType.length))
                    message.networkType = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.networkType.push(reader.int32());
                } else
                    message.networkType.push(reader.int32());
                break;
            case 19:
                message.forceHistoryState = reader.int32();
                break;
            case 22:
                message.groupLinkSharingStatus = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Conversation message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Conversation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Conversation} Conversation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Conversation.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Conversation message.
     * @function verify
     * @memberof Conversation
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Conversation.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.selfConversationState != null && message.hasOwnProperty("selfConversationState")) {
            let error = $root.UserConversationState.verify(message.selfConversationState);
            if (error)
                return "selfConversationState." + error;
        }
        if (message.readState != null && message.hasOwnProperty("readState")) {
            if (!Array.isArray(message.readState))
                return "readState: array expected";
            for (let i = 0; i < message.readState.length; ++i) {
                let error = $root.UserReadState.verify(message.readState[i]);
                if (error)
                    return "readState." + error;
            }
        }
        if (message.hasActiveHangout != null && message.hasOwnProperty("hasActiveHangout"))
            if (typeof message.hasActiveHangout !== "boolean")
                return "hasActiveHangout: boolean expected";
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            switch (message.otrStatus) {
            default:
                return "otrStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.otrToggle != null && message.hasOwnProperty("otrToggle"))
            switch (message.otrToggle) {
            default:
                return "otrToggle: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.conversationHistorySupported != null && message.hasOwnProperty("conversationHistorySupported"))
            if (typeof message.conversationHistorySupported !== "boolean")
                return "conversationHistorySupported: boolean expected";
        if (message.currentParticipant != null && message.hasOwnProperty("currentParticipant")) {
            if (!Array.isArray(message.currentParticipant))
                return "currentParticipant: array expected";
            for (let i = 0; i < message.currentParticipant.length; ++i) {
                let error = $root.ParticipantId.verify(message.currentParticipant[i]);
                if (error)
                    return "currentParticipant." + error;
            }
        }
        if (message.participantData != null && message.hasOwnProperty("participantData")) {
            if (!Array.isArray(message.participantData))
                return "participantData: array expected";
            for (let i = 0; i < message.participantData.length; ++i) {
                let error = $root.ConversationParticipantData.verify(message.participantData[i]);
                if (error)
                    return "participantData." + error;
            }
        }
        if (message.networkType != null && message.hasOwnProperty("networkType")) {
            if (!Array.isArray(message.networkType))
                return "networkType: array expected";
            for (let i = 0; i < message.networkType.length; ++i)
                switch (message.networkType[i]) {
                default:
                    return "networkType: enum value[] expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
        }
        if (message.forceHistoryState != null && message.hasOwnProperty("forceHistoryState"))
            switch (message.forceHistoryState) {
            default:
                return "forceHistoryState: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            switch (message.groupLinkSharingStatus) {
            default:
                return "groupLinkSharingStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a Conversation message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Conversation
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Conversation} Conversation
     */
    Conversation.fromObject = function fromObject(object) {
        if (object instanceof $root.Conversation)
            return object;
        let message = new $root.Conversation();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".Conversation.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.type) {
        case "CONVERSATION_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "CONVERSATION_TYPE_ONE_TO_ONE":
        case 1:
            message.type = 1;
            break;
        case "CONVERSATION_TYPE_GROUP":
        case 2:
            message.type = 2;
            break;
        }
        if (object.name != null)
            message.name = String(object.name);
        if (object.selfConversationState != null) {
            if (typeof object.selfConversationState !== "object")
                throw TypeError(".Conversation.selfConversationState: object expected");
            message.selfConversationState = $root.UserConversationState.fromObject(object.selfConversationState);
        }
        if (object.readState) {
            if (!Array.isArray(object.readState))
                throw TypeError(".Conversation.readState: array expected");
            message.readState = [];
            for (let i = 0; i < object.readState.length; ++i) {
                if (typeof object.readState[i] !== "object")
                    throw TypeError(".Conversation.readState: object expected");
                message.readState[i] = $root.UserReadState.fromObject(object.readState[i]);
            }
        }
        if (object.hasActiveHangout != null)
            message.hasActiveHangout = Boolean(object.hasActiveHangout);
        switch (object.otrStatus) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.otrStatus = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.otrStatus = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.otrStatus = 2;
            break;
        }
        switch (object.otrToggle) {
        case "OFF_THE_RECORD_TOGGLE_UNKNOWN":
        case 0:
            message.otrToggle = 0;
            break;
        case "OFF_THE_RECORD_TOGGLE_ENABLED":
        case 1:
            message.otrToggle = 1;
            break;
        case "OFF_THE_RECORD_TOGGLE_DISABLED":
        case 2:
            message.otrToggle = 2;
            break;
        }
        if (object.conversationHistorySupported != null)
            message.conversationHistorySupported = Boolean(object.conversationHistorySupported);
        if (object.currentParticipant) {
            if (!Array.isArray(object.currentParticipant))
                throw TypeError(".Conversation.currentParticipant: array expected");
            message.currentParticipant = [];
            for (let i = 0; i < object.currentParticipant.length; ++i) {
                if (typeof object.currentParticipant[i] !== "object")
                    throw TypeError(".Conversation.currentParticipant: object expected");
                message.currentParticipant[i] = $root.ParticipantId.fromObject(object.currentParticipant[i]);
            }
        }
        if (object.participantData) {
            if (!Array.isArray(object.participantData))
                throw TypeError(".Conversation.participantData: array expected");
            message.participantData = [];
            for (let i = 0; i < object.participantData.length; ++i) {
                if (typeof object.participantData[i] !== "object")
                    throw TypeError(".Conversation.participantData: object expected");
                message.participantData[i] = $root.ConversationParticipantData.fromObject(object.participantData[i]);
            }
        }
        if (object.networkType) {
            if (!Array.isArray(object.networkType))
                throw TypeError(".Conversation.networkType: array expected");
            message.networkType = [];
            for (let i = 0; i < object.networkType.length; ++i)
                switch (object.networkType[i]) {
                default:
                case "NETWORK_TYPE_UNKNOWN":
                case 0:
                    message.networkType[i] = 0;
                    break;
                case "NETWORK_TYPE_BABEL":
                case 1:
                    message.networkType[i] = 1;
                    break;
                case "NETWORK_TYPE_GOOGLE_VOICE":
                case 2:
                    message.networkType[i] = 2;
                    break;
                }
        }
        switch (object.forceHistoryState) {
        case "FORCE_HISTORY_UNKNOWN":
        case 0:
            message.forceHistoryState = 0;
            break;
        case "FORCE_HISTORY_NO":
        case 1:
            message.forceHistoryState = 1;
            break;
        }
        switch (object.groupLinkSharingStatus) {
        case "GROUP_LINK_SHARING_STATUS_UNKNOWN":
        case 0:
            message.groupLinkSharingStatus = 0;
            break;
        case "GROUP_LINK_SHARING_STATUS_ON":
        case 1:
            message.groupLinkSharingStatus = 1;
            break;
        case "GROUP_LINK_SHARING_STATUS_OFF":
        case 2:
            message.groupLinkSharingStatus = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a Conversation message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Conversation
     * @static
     * @param {Conversation} message Conversation
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Conversation.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.readState = [];
            object.currentParticipant = [];
            object.participantData = [];
            object.networkType = [];
        }
        if (options.defaults) {
            object.conversationId = null;
            object.type = options.enums === String ? "CONVERSATION_TYPE_UNKNOWN" : 0;
            object.name = "";
            object.selfConversationState = null;
            object.hasActiveHangout = false;
            object.otrStatus = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.otrToggle = options.enums === String ? "OFF_THE_RECORD_TOGGLE_UNKNOWN" : 0;
            object.conversationHistorySupported = false;
            object.forceHistoryState = options.enums === String ? "FORCE_HISTORY_UNKNOWN" : 0;
            object.groupLinkSharingStatus = options.enums === String ? "GROUP_LINK_SHARING_STATUS_UNKNOWN" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.ConversationType[message.type] : message.type;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.selfConversationState != null && message.hasOwnProperty("selfConversationState"))
            object.selfConversationState = $root.UserConversationState.toObject(message.selfConversationState, options);
        if (message.readState && message.readState.length) {
            object.readState = [];
            for (let j = 0; j < message.readState.length; ++j)
                object.readState[j] = $root.UserReadState.toObject(message.readState[j], options);
        }
        if (message.hasActiveHangout != null && message.hasOwnProperty("hasActiveHangout"))
            object.hasActiveHangout = message.hasActiveHangout;
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            object.otrStatus = options.enums === String ? $root.OffTheRecordStatus[message.otrStatus] : message.otrStatus;
        if (message.otrToggle != null && message.hasOwnProperty("otrToggle"))
            object.otrToggle = options.enums === String ? $root.OffTheRecordToggle[message.otrToggle] : message.otrToggle;
        if (message.conversationHistorySupported != null && message.hasOwnProperty("conversationHistorySupported"))
            object.conversationHistorySupported = message.conversationHistorySupported;
        if (message.currentParticipant && message.currentParticipant.length) {
            object.currentParticipant = [];
            for (let j = 0; j < message.currentParticipant.length; ++j)
                object.currentParticipant[j] = $root.ParticipantId.toObject(message.currentParticipant[j], options);
        }
        if (message.participantData && message.participantData.length) {
            object.participantData = [];
            for (let j = 0; j < message.participantData.length; ++j)
                object.participantData[j] = $root.ConversationParticipantData.toObject(message.participantData[j], options);
        }
        if (message.networkType && message.networkType.length) {
            object.networkType = [];
            for (let j = 0; j < message.networkType.length; ++j)
                object.networkType[j] = options.enums === String ? $root.NetworkType[message.networkType[j]] : message.networkType[j];
        }
        if (message.forceHistoryState != null && message.hasOwnProperty("forceHistoryState"))
            object.forceHistoryState = options.enums === String ? $root.ForceHistory[message.forceHistoryState] : message.forceHistoryState;
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            object.groupLinkSharingStatus = options.enums === String ? $root.GroupLinkSharingStatus[message.groupLinkSharingStatus] : message.groupLinkSharingStatus;
        return object;
    };

    /**
     * Converts this Conversation to JSON.
     * @function toJSON
     * @memberof Conversation
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Conversation.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Conversation;
})();

export const EasterEgg = $root.EasterEgg = (() => {

    /**
     * Properties of an EasterEgg.
     * @exports IEasterEgg
     * @interface IEasterEgg
     * @property {string|null} [message] EasterEgg message
     */

    /**
     * Constructs a new EasterEgg.
     * @exports EasterEgg
     * @classdesc Represents an EasterEgg.
     * @implements IEasterEgg
     * @constructor
     * @param {IEasterEgg=} [properties] Properties to set
     */
    function EasterEgg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EasterEgg message.
     * @member {string} message
     * @memberof EasterEgg
     * @instance
     */
    EasterEgg.prototype.message = "";

    /**
     * Creates a new EasterEgg instance using the specified properties.
     * @function create
     * @memberof EasterEgg
     * @static
     * @param {IEasterEgg=} [properties] Properties to set
     * @returns {EasterEgg} EasterEgg instance
     */
    EasterEgg.create = function create(properties) {
        return new EasterEgg(properties);
    };

    /**
     * Encodes the specified EasterEgg message. Does not implicitly {@link EasterEgg.verify|verify} messages.
     * @function encode
     * @memberof EasterEgg
     * @static
     * @param {IEasterEgg} message EasterEgg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEgg.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.message != null && message.hasOwnProperty("message"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified EasterEgg message, length delimited. Does not implicitly {@link EasterEgg.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EasterEgg
     * @static
     * @param {IEasterEgg} message EasterEgg message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEgg.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EasterEgg message from the specified reader or buffer.
     * @function decode
     * @memberof EasterEgg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EasterEgg} EasterEgg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEgg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EasterEgg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.message = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EasterEgg message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EasterEgg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EasterEgg} EasterEgg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEgg.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EasterEgg message.
     * @function verify
     * @memberof EasterEgg
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EasterEgg.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message))
                return "message: string expected";
        return null;
    };

    /**
     * Creates an EasterEgg message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EasterEgg
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EasterEgg} EasterEgg
     */
    EasterEgg.fromObject = function fromObject(object) {
        if (object instanceof $root.EasterEgg)
            return object;
        let message = new $root.EasterEgg();
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from an EasterEgg message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EasterEgg
     * @static
     * @param {EasterEgg} message EasterEgg
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EasterEgg.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.message = "";
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this EasterEgg to JSON.
     * @function toJSON
     * @memberof EasterEgg
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EasterEgg.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EasterEgg;
})();

/**
 * BlockState enum.
 * @exports BlockState
 * @enum {string}
 * @property {number} BLOCK_STATE_UNKNOWN=0 BLOCK_STATE_UNKNOWN value
 * @property {number} BLOCK_STATE_BLOCK=1 BLOCK_STATE_BLOCK value
 * @property {number} BLOCK_STATE_UNBLOCK=2 BLOCK_STATE_UNBLOCK value
 */
$root.BlockState = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "BLOCK_STATE_UNKNOWN"] = 0;
    values[valuesById[1] = "BLOCK_STATE_BLOCK"] = 1;
    values[valuesById[2] = "BLOCK_STATE_UNBLOCK"] = 2;
    return values;
})();

export const BlockStateChange = $root.BlockStateChange = (() => {

    /**
     * Properties of a BlockStateChange.
     * @exports IBlockStateChange
     * @interface IBlockStateChange
     * @property {IParticipantId|null} [participantId] BlockStateChange participantId
     * @property {BlockState|null} [newBlockState] BlockStateChange newBlockState
     */

    /**
     * Constructs a new BlockStateChange.
     * @exports BlockStateChange
     * @classdesc Represents a BlockStateChange.
     * @implements IBlockStateChange
     * @constructor
     * @param {IBlockStateChange=} [properties] Properties to set
     */
    function BlockStateChange(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BlockStateChange participantId.
     * @member {IParticipantId|null|undefined} participantId
     * @memberof BlockStateChange
     * @instance
     */
    BlockStateChange.prototype.participantId = null;

    /**
     * BlockStateChange newBlockState.
     * @member {BlockState} newBlockState
     * @memberof BlockStateChange
     * @instance
     */
    BlockStateChange.prototype.newBlockState = 0;

    /**
     * Creates a new BlockStateChange instance using the specified properties.
     * @function create
     * @memberof BlockStateChange
     * @static
     * @param {IBlockStateChange=} [properties] Properties to set
     * @returns {BlockStateChange} BlockStateChange instance
     */
    BlockStateChange.create = function create(properties) {
        return new BlockStateChange(properties);
    };

    /**
     * Encodes the specified BlockStateChange message. Does not implicitly {@link BlockStateChange.verify|verify} messages.
     * @function encode
     * @memberof BlockStateChange
     * @static
     * @param {IBlockStateChange} message BlockStateChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BlockStateChange.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            $root.ParticipantId.encode(message.participantId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.newBlockState != null && message.hasOwnProperty("newBlockState"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newBlockState);
        return writer;
    };

    /**
     * Encodes the specified BlockStateChange message, length delimited. Does not implicitly {@link BlockStateChange.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BlockStateChange
     * @static
     * @param {IBlockStateChange} message BlockStateChange message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BlockStateChange.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BlockStateChange message from the specified reader or buffer.
     * @function decode
     * @memberof BlockStateChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BlockStateChange} BlockStateChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BlockStateChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BlockStateChange();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.participantId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.newBlockState = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BlockStateChange message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BlockStateChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BlockStateChange} BlockStateChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BlockStateChange.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BlockStateChange message.
     * @function verify
     * @memberof BlockStateChange
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BlockStateChange.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.participantId != null && message.hasOwnProperty("participantId")) {
            let error = $root.ParticipantId.verify(message.participantId);
            if (error)
                return "participantId." + error;
        }
        if (message.newBlockState != null && message.hasOwnProperty("newBlockState"))
            switch (message.newBlockState) {
            default:
                return "newBlockState: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a BlockStateChange message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BlockStateChange
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BlockStateChange} BlockStateChange
     */
    BlockStateChange.fromObject = function fromObject(object) {
        if (object instanceof $root.BlockStateChange)
            return object;
        let message = new $root.BlockStateChange();
        if (object.participantId != null) {
            if (typeof object.participantId !== "object")
                throw TypeError(".BlockStateChange.participantId: object expected");
            message.participantId = $root.ParticipantId.fromObject(object.participantId);
        }
        switch (object.newBlockState) {
        case "BLOCK_STATE_UNKNOWN":
        case 0:
            message.newBlockState = 0;
            break;
        case "BLOCK_STATE_BLOCK":
        case 1:
            message.newBlockState = 1;
            break;
        case "BLOCK_STATE_UNBLOCK":
        case 2:
            message.newBlockState = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a BlockStateChange message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BlockStateChange
     * @static
     * @param {BlockStateChange} message BlockStateChange
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BlockStateChange.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.participantId = null;
            object.newBlockState = options.enums === String ? "BLOCK_STATE_UNKNOWN" : 0;
        }
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            object.participantId = $root.ParticipantId.toObject(message.participantId, options);
        if (message.newBlockState != null && message.hasOwnProperty("newBlockState"))
            object.newBlockState = options.enums === String ? $root.BlockState[message.newBlockState] : message.newBlockState;
        return object;
    };

    /**
     * Converts this BlockStateChange to JSON.
     * @function toJSON
     * @memberof BlockStateChange
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BlockStateChange.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BlockStateChange;
})();

/**
 * ReplyToInviteType enum.
 * @exports ReplyToInviteType
 * @enum {string}
 * @property {number} REPLY_TO_INVITE_TYPE_UNKNOWN=0 REPLY_TO_INVITE_TYPE_UNKNOWN value
 * @property {number} REPLY_TO_INVITE_TYPE_ACCEPT=1 REPLY_TO_INVITE_TYPE_ACCEPT value
 * @property {number} REPLY_TO_INVITE_TYPE_DECLINE=2 REPLY_TO_INVITE_TYPE_DECLINE value
 */
$root.ReplyToInviteType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "REPLY_TO_INVITE_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "REPLY_TO_INVITE_TYPE_ACCEPT"] = 1;
    values[valuesById[2] = "REPLY_TO_INVITE_TYPE_DECLINE"] = 2;
    return values;
})();

export const Photo = $root.Photo = (() => {

    /**
     * Properties of a Photo.
     * @exports IPhoto
     * @interface IPhoto
     * @property {string|null} [photoId] Photo photoId
     * @property {boolean|null} [deleteAlbumlessSourcePhoto] Photo deleteAlbumlessSourcePhoto
     * @property {string|null} [userId] Photo userId
     * @property {boolean|null} [isCustomUserId] Photo isCustomUserId
     */

    /**
     * Constructs a new Photo.
     * @exports Photo
     * @classdesc Represents a Photo.
     * @implements IPhoto
     * @constructor
     * @param {IPhoto=} [properties] Properties to set
     */
    function Photo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Photo photoId.
     * @member {string} photoId
     * @memberof Photo
     * @instance
     */
    Photo.prototype.photoId = "";

    /**
     * Photo deleteAlbumlessSourcePhoto.
     * @member {boolean} deleteAlbumlessSourcePhoto
     * @memberof Photo
     * @instance
     */
    Photo.prototype.deleteAlbumlessSourcePhoto = false;

    /**
     * Photo userId.
     * @member {string} userId
     * @memberof Photo
     * @instance
     */
    Photo.prototype.userId = "";

    /**
     * Photo isCustomUserId.
     * @member {boolean} isCustomUserId
     * @memberof Photo
     * @instance
     */
    Photo.prototype.isCustomUserId = false;

    /**
     * Creates a new Photo instance using the specified properties.
     * @function create
     * @memberof Photo
     * @static
     * @param {IPhoto=} [properties] Properties to set
     * @returns {Photo} Photo instance
     */
    Photo.create = function create(properties) {
        return new Photo(properties);
    };

    /**
     * Encodes the specified Photo message. Does not implicitly {@link Photo.verify|verify} messages.
     * @function encode
     * @memberof Photo
     * @static
     * @param {IPhoto} message Photo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Photo.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.photoId);
        if (message.deleteAlbumlessSourcePhoto != null && message.hasOwnProperty("deleteAlbumlessSourcePhoto"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.deleteAlbumlessSourcePhoto);
        if (message.userId != null && message.hasOwnProperty("userId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.userId);
        if (message.isCustomUserId != null && message.hasOwnProperty("isCustomUserId"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isCustomUserId);
        return writer;
    };

    /**
     * Encodes the specified Photo message, length delimited. Does not implicitly {@link Photo.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Photo
     * @static
     * @param {IPhoto} message Photo message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Photo.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Photo message from the specified reader or buffer.
     * @function decode
     * @memberof Photo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Photo} Photo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Photo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Photo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.photoId = reader.string();
                break;
            case 2:
                message.deleteAlbumlessSourcePhoto = reader.bool();
                break;
            case 3:
                message.userId = reader.string();
                break;
            case 4:
                message.isCustomUserId = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Photo message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Photo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Photo} Photo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Photo.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Photo message.
     * @function verify
     * @memberof Photo
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Photo.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            if (!$util.isString(message.photoId))
                return "photoId: string expected";
        if (message.deleteAlbumlessSourcePhoto != null && message.hasOwnProperty("deleteAlbumlessSourcePhoto"))
            if (typeof message.deleteAlbumlessSourcePhoto !== "boolean")
                return "deleteAlbumlessSourcePhoto: boolean expected";
        if (message.userId != null && message.hasOwnProperty("userId"))
            if (!$util.isString(message.userId))
                return "userId: string expected";
        if (message.isCustomUserId != null && message.hasOwnProperty("isCustomUserId"))
            if (typeof message.isCustomUserId !== "boolean")
                return "isCustomUserId: boolean expected";
        return null;
    };

    /**
     * Creates a Photo message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Photo
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Photo} Photo
     */
    Photo.fromObject = function fromObject(object) {
        if (object instanceof $root.Photo)
            return object;
        let message = new $root.Photo();
        if (object.photoId != null)
            message.photoId = String(object.photoId);
        if (object.deleteAlbumlessSourcePhoto != null)
            message.deleteAlbumlessSourcePhoto = Boolean(object.deleteAlbumlessSourcePhoto);
        if (object.userId != null)
            message.userId = String(object.userId);
        if (object.isCustomUserId != null)
            message.isCustomUserId = Boolean(object.isCustomUserId);
        return message;
    };

    /**
     * Creates a plain object from a Photo message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Photo
     * @static
     * @param {Photo} message Photo
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Photo.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.photoId = "";
            object.deleteAlbumlessSourcePhoto = false;
            object.userId = "";
            object.isCustomUserId = false;
        }
        if (message.photoId != null && message.hasOwnProperty("photoId"))
            object.photoId = message.photoId;
        if (message.deleteAlbumlessSourcePhoto != null && message.hasOwnProperty("deleteAlbumlessSourcePhoto"))
            object.deleteAlbumlessSourcePhoto = message.deleteAlbumlessSourcePhoto;
        if (message.userId != null && message.hasOwnProperty("userId"))
            object.userId = message.userId;
        if (message.isCustomUserId != null && message.hasOwnProperty("isCustomUserId"))
            object.isCustomUserId = message.isCustomUserId;
        return object;
    };

    /**
     * Converts this Photo to JSON.
     * @function toJSON
     * @memberof Photo
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Photo.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Photo;
})();

export const ExistingMedia = $root.ExistingMedia = (() => {

    /**
     * Properties of an ExistingMedia.
     * @exports IExistingMedia
     * @interface IExistingMedia
     * @property {IPhoto|null} [photo] ExistingMedia photo
     */

    /**
     * Constructs a new ExistingMedia.
     * @exports ExistingMedia
     * @classdesc Represents an ExistingMedia.
     * @implements IExistingMedia
     * @constructor
     * @param {IExistingMedia=} [properties] Properties to set
     */
    function ExistingMedia(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExistingMedia photo.
     * @member {IPhoto|null|undefined} photo
     * @memberof ExistingMedia
     * @instance
     */
    ExistingMedia.prototype.photo = null;

    /**
     * Creates a new ExistingMedia instance using the specified properties.
     * @function create
     * @memberof ExistingMedia
     * @static
     * @param {IExistingMedia=} [properties] Properties to set
     * @returns {ExistingMedia} ExistingMedia instance
     */
    ExistingMedia.create = function create(properties) {
        return new ExistingMedia(properties);
    };

    /**
     * Encodes the specified ExistingMedia message. Does not implicitly {@link ExistingMedia.verify|verify} messages.
     * @function encode
     * @memberof ExistingMedia
     * @static
     * @param {IExistingMedia} message ExistingMedia message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExistingMedia.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.photo != null && message.hasOwnProperty("photo"))
            $root.Photo.encode(message.photo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ExistingMedia message, length delimited. Does not implicitly {@link ExistingMedia.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExistingMedia
     * @static
     * @param {IExistingMedia} message ExistingMedia message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExistingMedia.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExistingMedia message from the specified reader or buffer.
     * @function decode
     * @memberof ExistingMedia
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExistingMedia} ExistingMedia
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExistingMedia.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExistingMedia();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.photo = $root.Photo.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExistingMedia message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExistingMedia
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExistingMedia} ExistingMedia
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExistingMedia.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExistingMedia message.
     * @function verify
     * @memberof ExistingMedia
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExistingMedia.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.photo != null && message.hasOwnProperty("photo")) {
            let error = $root.Photo.verify(message.photo);
            if (error)
                return "photo." + error;
        }
        return null;
    };

    /**
     * Creates an ExistingMedia message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExistingMedia
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExistingMedia} ExistingMedia
     */
    ExistingMedia.fromObject = function fromObject(object) {
        if (object instanceof $root.ExistingMedia)
            return object;
        let message = new $root.ExistingMedia();
        if (object.photo != null) {
            if (typeof object.photo !== "object")
                throw TypeError(".ExistingMedia.photo: object expected");
            message.photo = $root.Photo.fromObject(object.photo);
        }
        return message;
    };

    /**
     * Creates a plain object from an ExistingMedia message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExistingMedia
     * @static
     * @param {ExistingMedia} message ExistingMedia
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExistingMedia.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.photo = null;
        if (message.photo != null && message.hasOwnProperty("photo"))
            object.photo = $root.Photo.toObject(message.photo, options);
        return object;
    };

    /**
     * Converts this ExistingMedia to JSON.
     * @function toJSON
     * @memberof ExistingMedia
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExistingMedia.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ExistingMedia;
})();

export const EventRequestHeader = $root.EventRequestHeader = (() => {

    /**
     * Properties of an EventRequestHeader.
     * @exports IEventRequestHeader
     * @interface IEventRequestHeader
     * @property {IConversationId|null} [conversationId] EventRequestHeader conversationId
     * @property {number|Long|null} [clientGeneratedId] EventRequestHeader clientGeneratedId
     * @property {OffTheRecordStatus|null} [expectedOtr] EventRequestHeader expectedOtr
     * @property {IDeliveryMedium|null} [deliveryMedium] EventRequestHeader deliveryMedium
     * @property {EventType|null} [eventType] EventRequestHeader eventType
     */

    /**
     * Constructs a new EventRequestHeader.
     * @exports EventRequestHeader
     * @classdesc Represents an EventRequestHeader.
     * @implements IEventRequestHeader
     * @constructor
     * @param {IEventRequestHeader=} [properties] Properties to set
     */
    function EventRequestHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EventRequestHeader conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof EventRequestHeader
     * @instance
     */
    EventRequestHeader.prototype.conversationId = null;

    /**
     * EventRequestHeader clientGeneratedId.
     * @member {number|Long} clientGeneratedId
     * @memberof EventRequestHeader
     * @instance
     */
    EventRequestHeader.prototype.clientGeneratedId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * EventRequestHeader expectedOtr.
     * @member {OffTheRecordStatus} expectedOtr
     * @memberof EventRequestHeader
     * @instance
     */
    EventRequestHeader.prototype.expectedOtr = 0;

    /**
     * EventRequestHeader deliveryMedium.
     * @member {IDeliveryMedium|null|undefined} deliveryMedium
     * @memberof EventRequestHeader
     * @instance
     */
    EventRequestHeader.prototype.deliveryMedium = null;

    /**
     * EventRequestHeader eventType.
     * @member {EventType} eventType
     * @memberof EventRequestHeader
     * @instance
     */
    EventRequestHeader.prototype.eventType = 0;

    /**
     * Creates a new EventRequestHeader instance using the specified properties.
     * @function create
     * @memberof EventRequestHeader
     * @static
     * @param {IEventRequestHeader=} [properties] Properties to set
     * @returns {EventRequestHeader} EventRequestHeader instance
     */
    EventRequestHeader.create = function create(properties) {
        return new EventRequestHeader(properties);
    };

    /**
     * Encodes the specified EventRequestHeader message. Does not implicitly {@link EventRequestHeader.verify|verify} messages.
     * @function encode
     * @memberof EventRequestHeader
     * @static
     * @param {IEventRequestHeader} message EventRequestHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventRequestHeader.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.clientGeneratedId);
        if (message.expectedOtr != null && message.hasOwnProperty("expectedOtr"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.expectedOtr);
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium"))
            $root.DeliveryMedium.encode(message.deliveryMedium, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.eventType);
        return writer;
    };

    /**
     * Encodes the specified EventRequestHeader message, length delimited. Does not implicitly {@link EventRequestHeader.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EventRequestHeader
     * @static
     * @param {IEventRequestHeader} message EventRequestHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventRequestHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EventRequestHeader message from the specified reader or buffer.
     * @function decode
     * @memberof EventRequestHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EventRequestHeader} EventRequestHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventRequestHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EventRequestHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.clientGeneratedId = reader.uint64();
                break;
            case 3:
                message.expectedOtr = reader.int32();
                break;
            case 4:
                message.deliveryMedium = $root.DeliveryMedium.decode(reader, reader.uint32());
                break;
            case 5:
                message.eventType = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EventRequestHeader message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EventRequestHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EventRequestHeader} EventRequestHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventRequestHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EventRequestHeader message.
     * @function verify
     * @memberof EventRequestHeader
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EventRequestHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (!$util.isInteger(message.clientGeneratedId) && !(message.clientGeneratedId && $util.isInteger(message.clientGeneratedId.low) && $util.isInteger(message.clientGeneratedId.high)))
                return "clientGeneratedId: integer|Long expected";
        if (message.expectedOtr != null && message.hasOwnProperty("expectedOtr"))
            switch (message.expectedOtr) {
            default:
                return "expectedOtr: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium")) {
            let error = $root.DeliveryMedium.verify(message.deliveryMedium);
            if (error)
                return "deliveryMedium." + error;
        }
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            switch (message.eventType) {
            default:
                return "eventType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
                break;
            }
        return null;
    };

    /**
     * Creates an EventRequestHeader message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EventRequestHeader
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EventRequestHeader} EventRequestHeader
     */
    EventRequestHeader.fromObject = function fromObject(object) {
        if (object instanceof $root.EventRequestHeader)
            return object;
        let message = new $root.EventRequestHeader();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".EventRequestHeader.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.clientGeneratedId != null)
            if ($util.Long)
                (message.clientGeneratedId = $util.Long.fromValue(object.clientGeneratedId)).unsigned = true;
            else if (typeof object.clientGeneratedId === "string")
                message.clientGeneratedId = parseInt(object.clientGeneratedId, 10);
            else if (typeof object.clientGeneratedId === "number")
                message.clientGeneratedId = object.clientGeneratedId;
            else if (typeof object.clientGeneratedId === "object")
                message.clientGeneratedId = new $util.LongBits(object.clientGeneratedId.low >>> 0, object.clientGeneratedId.high >>> 0).toNumber(true);
        switch (object.expectedOtr) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.expectedOtr = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.expectedOtr = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.expectedOtr = 2;
            break;
        }
        if (object.deliveryMedium != null) {
            if (typeof object.deliveryMedium !== "object")
                throw TypeError(".EventRequestHeader.deliveryMedium: object expected");
            message.deliveryMedium = $root.DeliveryMedium.fromObject(object.deliveryMedium);
        }
        switch (object.eventType) {
        case "EVENT_TYPE_UNKNOWN":
        case 0:
            message.eventType = 0;
            break;
        case "EVENT_TYPE_REGULAR_CHAT_MESSAGE":
        case 1:
            message.eventType = 1;
            break;
        case "EVENT_TYPE_SMS":
        case 2:
            message.eventType = 2;
            break;
        case "EVENT_TYPE_VOICEMAIL":
        case 3:
            message.eventType = 3;
            break;
        case "EVENT_TYPE_ADD_USER":
        case 4:
            message.eventType = 4;
            break;
        case "EVENT_TYPE_REMOVE_USER":
        case 5:
            message.eventType = 5;
            break;
        case "EVENT_TYPE_CONVERSATION_RENAME":
        case 6:
            message.eventType = 6;
            break;
        case "EVENT_TYPE_HANGOUT":
        case 7:
            message.eventType = 7;
            break;
        case "EVENT_TYPE_PHONE_CALL":
        case 8:
            message.eventType = 8;
            break;
        case "EVENT_TYPE_OTR_MODIFICATION":
        case 9:
            message.eventType = 9;
            break;
        case "EVENT_TYPE_PLAN_MUTATION":
        case 10:
            message.eventType = 10;
            break;
        case "EVENT_TYPE_MMS":
        case 11:
            message.eventType = 11;
            break;
        case "EVENT_TYPE_DEPRECATED_12":
        case 12:
            message.eventType = 12;
            break;
        case "EVENT_TYPE_OBSERVED_EVENT":
        case 13:
            message.eventType = 13;
            break;
        case "EVENT_TYPE_GROUP_LINK_SHARING_MODIFICATION":
        case 14:
            message.eventType = 14;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from an EventRequestHeader message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EventRequestHeader
     * @static
     * @param {EventRequestHeader} message EventRequestHeader
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EventRequestHeader.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.clientGeneratedId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.clientGeneratedId = options.longs === String ? "0" : 0;
            object.expectedOtr = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.deliveryMedium = null;
            object.eventType = options.enums === String ? "EVENT_TYPE_UNKNOWN" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (typeof message.clientGeneratedId === "number")
                object.clientGeneratedId = options.longs === String ? String(message.clientGeneratedId) : message.clientGeneratedId;
            else
                object.clientGeneratedId = options.longs === String ? $util.Long.prototype.toString.call(message.clientGeneratedId) : options.longs === Number ? new $util.LongBits(message.clientGeneratedId.low >>> 0, message.clientGeneratedId.high >>> 0).toNumber(true) : message.clientGeneratedId;
        if (message.expectedOtr != null && message.hasOwnProperty("expectedOtr"))
            object.expectedOtr = options.enums === String ? $root.OffTheRecordStatus[message.expectedOtr] : message.expectedOtr;
        if (message.deliveryMedium != null && message.hasOwnProperty("deliveryMedium"))
            object.deliveryMedium = $root.DeliveryMedium.toObject(message.deliveryMedium, options);
        if (message.eventType != null && message.hasOwnProperty("eventType"))
            object.eventType = options.enums === String ? $root.EventType[message.eventType] : message.eventType;
        return object;
    };

    /**
     * Converts this EventRequestHeader to JSON.
     * @function toJSON
     * @memberof EventRequestHeader
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EventRequestHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EventRequestHeader;
})();

/**
 * ClientId enum.
 * @exports ClientId
 * @enum {string}
 * @property {number} CLIENT_ID_UNKNOWN=0 CLIENT_ID_UNKNOWN value
 * @property {number} CLIENT_ID_ANDROID=1 CLIENT_ID_ANDROID value
 * @property {number} CLIENT_ID_IOS=2 CLIENT_ID_IOS value
 * @property {number} CLIENT_ID_CHROME=3 CLIENT_ID_CHROME value
 * @property {number} CLIENT_ID_WEB_GPLUS=5 CLIENT_ID_WEB_GPLUS value
 * @property {number} CLIENT_ID_WEB_GMAIL=6 CLIENT_ID_WEB_GMAIL value
 * @property {number} CLIENT_ID_ULTRAVIOLET=13 CLIENT_ID_ULTRAVIOLET value
 * @property {number} CLIENT_ID_WEB_HANGOUTS=44 CLIENT_ID_WEB_HANGOUTS value
 */
$root.ClientId = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CLIENT_ID_UNKNOWN"] = 0;
    values[valuesById[1] = "CLIENT_ID_ANDROID"] = 1;
    values[valuesById[2] = "CLIENT_ID_IOS"] = 2;
    values[valuesById[3] = "CLIENT_ID_CHROME"] = 3;
    values[valuesById[5] = "CLIENT_ID_WEB_GPLUS"] = 5;
    values[valuesById[6] = "CLIENT_ID_WEB_GMAIL"] = 6;
    values[valuesById[13] = "CLIENT_ID_ULTRAVIOLET"] = 13;
    values[valuesById[44] = "CLIENT_ID_WEB_HANGOUTS"] = 44;
    return values;
})();

/**
 * ClientBuildType enum.
 * @exports ClientBuildType
 * @enum {string}
 * @property {number} BUILD_TYPE_UNKNOWN=0 BUILD_TYPE_UNKNOWN value
 * @property {number} BUILD_TYPE_PRODUCTION_WEB=1 BUILD_TYPE_PRODUCTION_WEB value
 * @property {number} BUILD_TYPE_PRODUCTION_APP=3 BUILD_TYPE_PRODUCTION_APP value
 */
$root.ClientBuildType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "BUILD_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "BUILD_TYPE_PRODUCTION_WEB"] = 1;
    values[valuesById[3] = "BUILD_TYPE_PRODUCTION_APP"] = 3;
    return values;
})();

export const ClientVersion = $root.ClientVersion = (() => {

    /**
     * Properties of a ClientVersion.
     * @exports IClientVersion
     * @interface IClientVersion
     * @property {ClientId|null} [clientId] ClientVersion clientId
     * @property {ClientBuildType|null} [buildType] ClientVersion buildType
     * @property {string|null} [majorVersion] ClientVersion majorVersion
     * @property {number|Long|null} [versionTimestamp] ClientVersion versionTimestamp
     * @property {string|null} [deviceOsVersion] ClientVersion deviceOsVersion
     * @property {string|null} [deviceHardware] ClientVersion deviceHardware
     */

    /**
     * Constructs a new ClientVersion.
     * @exports ClientVersion
     * @classdesc Represents a ClientVersion.
     * @implements IClientVersion
     * @constructor
     * @param {IClientVersion=} [properties] Properties to set
     */
    function ClientVersion(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ClientVersion clientId.
     * @member {ClientId} clientId
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.clientId = 0;

    /**
     * ClientVersion buildType.
     * @member {ClientBuildType} buildType
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.buildType = 0;

    /**
     * ClientVersion majorVersion.
     * @member {string} majorVersion
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.majorVersion = "";

    /**
     * ClientVersion versionTimestamp.
     * @member {number|Long} versionTimestamp
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.versionTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ClientVersion deviceOsVersion.
     * @member {string} deviceOsVersion
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.deviceOsVersion = "";

    /**
     * ClientVersion deviceHardware.
     * @member {string} deviceHardware
     * @memberof ClientVersion
     * @instance
     */
    ClientVersion.prototype.deviceHardware = "";

    /**
     * Creates a new ClientVersion instance using the specified properties.
     * @function create
     * @memberof ClientVersion
     * @static
     * @param {IClientVersion=} [properties] Properties to set
     * @returns {ClientVersion} ClientVersion instance
     */
    ClientVersion.create = function create(properties) {
        return new ClientVersion(properties);
    };

    /**
     * Encodes the specified ClientVersion message. Does not implicitly {@link ClientVersion.verify|verify} messages.
     * @function encode
     * @memberof ClientVersion
     * @static
     * @param {IClientVersion} message ClientVersion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientVersion.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.clientId);
        if (message.buildType != null && message.hasOwnProperty("buildType"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buildType);
        if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.majorVersion);
        if (message.versionTimestamp != null && message.hasOwnProperty("versionTimestamp"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.versionTimestamp);
        if (message.deviceOsVersion != null && message.hasOwnProperty("deviceOsVersion"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.deviceOsVersion);
        if (message.deviceHardware != null && message.hasOwnProperty("deviceHardware"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.deviceHardware);
        return writer;
    };

    /**
     * Encodes the specified ClientVersion message, length delimited. Does not implicitly {@link ClientVersion.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ClientVersion
     * @static
     * @param {IClientVersion} message ClientVersion message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ClientVersion.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ClientVersion message from the specified reader or buffer.
     * @function decode
     * @memberof ClientVersion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ClientVersion} ClientVersion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientVersion.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ClientVersion();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clientId = reader.int32();
                break;
            case 2:
                message.buildType = reader.int32();
                break;
            case 3:
                message.majorVersion = reader.string();
                break;
            case 4:
                message.versionTimestamp = reader.uint64();
                break;
            case 5:
                message.deviceOsVersion = reader.string();
                break;
            case 6:
                message.deviceHardware = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ClientVersion message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ClientVersion
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ClientVersion} ClientVersion
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ClientVersion.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ClientVersion message.
     * @function verify
     * @memberof ClientVersion
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ClientVersion.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            switch (message.clientId) {
            default:
                return "clientId: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 5:
            case 6:
            case 13:
            case 44:
                break;
            }
        if (message.buildType != null && message.hasOwnProperty("buildType"))
            switch (message.buildType) {
            default:
                return "buildType: enum value expected";
            case 0:
            case 1:
            case 3:
                break;
            }
        if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
            if (!$util.isString(message.majorVersion))
                return "majorVersion: string expected";
        if (message.versionTimestamp != null && message.hasOwnProperty("versionTimestamp"))
            if (!$util.isInteger(message.versionTimestamp) && !(message.versionTimestamp && $util.isInteger(message.versionTimestamp.low) && $util.isInteger(message.versionTimestamp.high)))
                return "versionTimestamp: integer|Long expected";
        if (message.deviceOsVersion != null && message.hasOwnProperty("deviceOsVersion"))
            if (!$util.isString(message.deviceOsVersion))
                return "deviceOsVersion: string expected";
        if (message.deviceHardware != null && message.hasOwnProperty("deviceHardware"))
            if (!$util.isString(message.deviceHardware))
                return "deviceHardware: string expected";
        return null;
    };

    /**
     * Creates a ClientVersion message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ClientVersion
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ClientVersion} ClientVersion
     */
    ClientVersion.fromObject = function fromObject(object) {
        if (object instanceof $root.ClientVersion)
            return object;
        let message = new $root.ClientVersion();
        switch (object.clientId) {
        case "CLIENT_ID_UNKNOWN":
        case 0:
            message.clientId = 0;
            break;
        case "CLIENT_ID_ANDROID":
        case 1:
            message.clientId = 1;
            break;
        case "CLIENT_ID_IOS":
        case 2:
            message.clientId = 2;
            break;
        case "CLIENT_ID_CHROME":
        case 3:
            message.clientId = 3;
            break;
        case "CLIENT_ID_WEB_GPLUS":
        case 5:
            message.clientId = 5;
            break;
        case "CLIENT_ID_WEB_GMAIL":
        case 6:
            message.clientId = 6;
            break;
        case "CLIENT_ID_ULTRAVIOLET":
        case 13:
            message.clientId = 13;
            break;
        case "CLIENT_ID_WEB_HANGOUTS":
        case 44:
            message.clientId = 44;
            break;
        }
        switch (object.buildType) {
        case "BUILD_TYPE_UNKNOWN":
        case 0:
            message.buildType = 0;
            break;
        case "BUILD_TYPE_PRODUCTION_WEB":
        case 1:
            message.buildType = 1;
            break;
        case "BUILD_TYPE_PRODUCTION_APP":
        case 3:
            message.buildType = 3;
            break;
        }
        if (object.majorVersion != null)
            message.majorVersion = String(object.majorVersion);
        if (object.versionTimestamp != null)
            if ($util.Long)
                (message.versionTimestamp = $util.Long.fromValue(object.versionTimestamp)).unsigned = true;
            else if (typeof object.versionTimestamp === "string")
                message.versionTimestamp = parseInt(object.versionTimestamp, 10);
            else if (typeof object.versionTimestamp === "number")
                message.versionTimestamp = object.versionTimestamp;
            else if (typeof object.versionTimestamp === "object")
                message.versionTimestamp = new $util.LongBits(object.versionTimestamp.low >>> 0, object.versionTimestamp.high >>> 0).toNumber(true);
        if (object.deviceOsVersion != null)
            message.deviceOsVersion = String(object.deviceOsVersion);
        if (object.deviceHardware != null)
            message.deviceHardware = String(object.deviceHardware);
        return message;
    };

    /**
     * Creates a plain object from a ClientVersion message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ClientVersion
     * @static
     * @param {ClientVersion} message ClientVersion
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ClientVersion.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.clientId = options.enums === String ? "CLIENT_ID_UNKNOWN" : 0;
            object.buildType = options.enums === String ? "BUILD_TYPE_UNKNOWN" : 0;
            object.majorVersion = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.versionTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.versionTimestamp = options.longs === String ? "0" : 0;
            object.deviceOsVersion = "";
            object.deviceHardware = "";
        }
        if (message.clientId != null && message.hasOwnProperty("clientId"))
            object.clientId = options.enums === String ? $root.ClientId[message.clientId] : message.clientId;
        if (message.buildType != null && message.hasOwnProperty("buildType"))
            object.buildType = options.enums === String ? $root.ClientBuildType[message.buildType] : message.buildType;
        if (message.majorVersion != null && message.hasOwnProperty("majorVersion"))
            object.majorVersion = message.majorVersion;
        if (message.versionTimestamp != null && message.hasOwnProperty("versionTimestamp"))
            if (typeof message.versionTimestamp === "number")
                object.versionTimestamp = options.longs === String ? String(message.versionTimestamp) : message.versionTimestamp;
            else
                object.versionTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.versionTimestamp) : options.longs === Number ? new $util.LongBits(message.versionTimestamp.low >>> 0, message.versionTimestamp.high >>> 0).toNumber(true) : message.versionTimestamp;
        if (message.deviceOsVersion != null && message.hasOwnProperty("deviceOsVersion"))
            object.deviceOsVersion = message.deviceOsVersion;
        if (message.deviceHardware != null && message.hasOwnProperty("deviceHardware"))
            object.deviceHardware = message.deviceHardware;
        return object;
    };

    /**
     * Converts this ClientVersion to JSON.
     * @function toJSON
     * @memberof ClientVersion
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ClientVersion.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ClientVersion;
})();

export const RequestHeader = $root.RequestHeader = (() => {

    /**
     * Properties of a RequestHeader.
     * @exports IRequestHeader
     * @interface IRequestHeader
     * @property {IClientVersion|null} [clientVersion] RequestHeader clientVersion
     * @property {IClientIdentifier|null} [clientIdentifier] RequestHeader clientIdentifier
     * @property {string|null} [languageCode] RequestHeader languageCode
     */

    /**
     * Constructs a new RequestHeader.
     * @exports RequestHeader
     * @classdesc Represents a RequestHeader.
     * @implements IRequestHeader
     * @constructor
     * @param {IRequestHeader=} [properties] Properties to set
     */
    function RequestHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RequestHeader clientVersion.
     * @member {IClientVersion|null|undefined} clientVersion
     * @memberof RequestHeader
     * @instance
     */
    RequestHeader.prototype.clientVersion = null;

    /**
     * RequestHeader clientIdentifier.
     * @member {IClientIdentifier|null|undefined} clientIdentifier
     * @memberof RequestHeader
     * @instance
     */
    RequestHeader.prototype.clientIdentifier = null;

    /**
     * RequestHeader languageCode.
     * @member {string} languageCode
     * @memberof RequestHeader
     * @instance
     */
    RequestHeader.prototype.languageCode = "";

    /**
     * Creates a new RequestHeader instance using the specified properties.
     * @function create
     * @memberof RequestHeader
     * @static
     * @param {IRequestHeader=} [properties] Properties to set
     * @returns {RequestHeader} RequestHeader instance
     */
    RequestHeader.create = function create(properties) {
        return new RequestHeader(properties);
    };

    /**
     * Encodes the specified RequestHeader message. Does not implicitly {@link RequestHeader.verify|verify} messages.
     * @function encode
     * @memberof RequestHeader
     * @static
     * @param {IRequestHeader} message RequestHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RequestHeader.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
            $root.ClientVersion.encode(message.clientVersion, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.clientIdentifier != null && message.hasOwnProperty("clientIdentifier"))
            $root.ClientIdentifier.encode(message.clientIdentifier, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.languageCode != null && message.hasOwnProperty("languageCode"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.languageCode);
        return writer;
    };

    /**
     * Encodes the specified RequestHeader message, length delimited. Does not implicitly {@link RequestHeader.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RequestHeader
     * @static
     * @param {IRequestHeader} message RequestHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RequestHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RequestHeader message from the specified reader or buffer.
     * @function decode
     * @memberof RequestHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RequestHeader} RequestHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RequestHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RequestHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clientVersion = $root.ClientVersion.decode(reader, reader.uint32());
                break;
            case 2:
                message.clientIdentifier = $root.ClientIdentifier.decode(reader, reader.uint32());
                break;
            case 4:
                message.languageCode = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RequestHeader message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RequestHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RequestHeader} RequestHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RequestHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RequestHeader message.
     * @function verify
     * @memberof RequestHeader
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RequestHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion")) {
            let error = $root.ClientVersion.verify(message.clientVersion);
            if (error)
                return "clientVersion." + error;
        }
        if (message.clientIdentifier != null && message.hasOwnProperty("clientIdentifier")) {
            let error = $root.ClientIdentifier.verify(message.clientIdentifier);
            if (error)
                return "clientIdentifier." + error;
        }
        if (message.languageCode != null && message.hasOwnProperty("languageCode"))
            if (!$util.isString(message.languageCode))
                return "languageCode: string expected";
        return null;
    };

    /**
     * Creates a RequestHeader message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RequestHeader
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RequestHeader} RequestHeader
     */
    RequestHeader.fromObject = function fromObject(object) {
        if (object instanceof $root.RequestHeader)
            return object;
        let message = new $root.RequestHeader();
        if (object.clientVersion != null) {
            if (typeof object.clientVersion !== "object")
                throw TypeError(".RequestHeader.clientVersion: object expected");
            message.clientVersion = $root.ClientVersion.fromObject(object.clientVersion);
        }
        if (object.clientIdentifier != null) {
            if (typeof object.clientIdentifier !== "object")
                throw TypeError(".RequestHeader.clientIdentifier: object expected");
            message.clientIdentifier = $root.ClientIdentifier.fromObject(object.clientIdentifier);
        }
        if (object.languageCode != null)
            message.languageCode = String(object.languageCode);
        return message;
    };

    /**
     * Creates a plain object from a RequestHeader message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RequestHeader
     * @static
     * @param {RequestHeader} message RequestHeader
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RequestHeader.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.clientVersion = null;
            object.clientIdentifier = null;
            object.languageCode = "";
        }
        if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
            object.clientVersion = $root.ClientVersion.toObject(message.clientVersion, options);
        if (message.clientIdentifier != null && message.hasOwnProperty("clientIdentifier"))
            object.clientIdentifier = $root.ClientIdentifier.toObject(message.clientIdentifier, options);
        if (message.languageCode != null && message.hasOwnProperty("languageCode"))
            object.languageCode = message.languageCode;
        return object;
    };

    /**
     * Converts this RequestHeader to JSON.
     * @function toJSON
     * @memberof RequestHeader
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RequestHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RequestHeader;
})();

/**
 * ResponseStatus enum.
 * @exports ResponseStatus
 * @enum {string}
 * @property {number} RESPONSE_STATUS_UNKNOWN=0 RESPONSE_STATUS_UNKNOWN value
 * @property {number} RESPONSE_STATUS_OK=1 RESPONSE_STATUS_OK value
 * @property {number} RESPONSE_STATUS_UNEXPECTED_ERROR=3 RESPONSE_STATUS_UNEXPECTED_ERROR value
 * @property {number} RESPONSE_STATUS_INVALID_REQUEST=4 RESPONSE_STATUS_INVALID_REQUEST value
 */
$root.ResponseStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "RESPONSE_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "RESPONSE_STATUS_OK"] = 1;
    values[valuesById[3] = "RESPONSE_STATUS_UNEXPECTED_ERROR"] = 3;
    values[valuesById[4] = "RESPONSE_STATUS_INVALID_REQUEST"] = 4;
    return values;
})();

export const ResponseHeader = $root.ResponseHeader = (() => {

    /**
     * Properties of a ResponseHeader.
     * @exports IResponseHeader
     * @interface IResponseHeader
     * @property {ResponseStatus|null} [status] ResponseHeader status
     * @property {string|null} [errorDescription] ResponseHeader errorDescription
     * @property {string|null} [debugUrl] ResponseHeader debugUrl
     * @property {string|null} [requestTraceId] ResponseHeader requestTraceId
     * @property {number|Long|null} [currentServerTime] ResponseHeader currentServerTime
     */

    /**
     * Constructs a new ResponseHeader.
     * @exports ResponseHeader
     * @classdesc Represents a ResponseHeader.
     * @implements IResponseHeader
     * @constructor
     * @param {IResponseHeader=} [properties] Properties to set
     */
    function ResponseHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResponseHeader status.
     * @member {ResponseStatus} status
     * @memberof ResponseHeader
     * @instance
     */
    ResponseHeader.prototype.status = 0;

    /**
     * ResponseHeader errorDescription.
     * @member {string} errorDescription
     * @memberof ResponseHeader
     * @instance
     */
    ResponseHeader.prototype.errorDescription = "";

    /**
     * ResponseHeader debugUrl.
     * @member {string} debugUrl
     * @memberof ResponseHeader
     * @instance
     */
    ResponseHeader.prototype.debugUrl = "";

    /**
     * ResponseHeader requestTraceId.
     * @member {string} requestTraceId
     * @memberof ResponseHeader
     * @instance
     */
    ResponseHeader.prototype.requestTraceId = "";

    /**
     * ResponseHeader currentServerTime.
     * @member {number|Long} currentServerTime
     * @memberof ResponseHeader
     * @instance
     */
    ResponseHeader.prototype.currentServerTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new ResponseHeader instance using the specified properties.
     * @function create
     * @memberof ResponseHeader
     * @static
     * @param {IResponseHeader=} [properties] Properties to set
     * @returns {ResponseHeader} ResponseHeader instance
     */
    ResponseHeader.create = function create(properties) {
        return new ResponseHeader(properties);
    };

    /**
     * Encodes the specified ResponseHeader message. Does not implicitly {@link ResponseHeader.verify|verify} messages.
     * @function encode
     * @memberof ResponseHeader
     * @static
     * @param {IResponseHeader} message ResponseHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseHeader.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.status != null && message.hasOwnProperty("status"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
        if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorDescription);
        if (message.debugUrl != null && message.hasOwnProperty("debugUrl"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.debugUrl);
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.requestTraceId);
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.currentServerTime);
        return writer;
    };

    /**
     * Encodes the specified ResponseHeader message, length delimited. Does not implicitly {@link ResponseHeader.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResponseHeader
     * @static
     * @param {IResponseHeader} message ResponseHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResponseHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResponseHeader message from the specified reader or buffer.
     * @function decode
     * @memberof ResponseHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResponseHeader} ResponseHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResponseHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.status = reader.int32();
                break;
            case 2:
                message.errorDescription = reader.string();
                break;
            case 3:
                message.debugUrl = reader.string();
                break;
            case 4:
                message.requestTraceId = reader.string();
                break;
            case 5:
                message.currentServerTime = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResponseHeader message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResponseHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResponseHeader} ResponseHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResponseHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResponseHeader message.
     * @function verify
     * @memberof ResponseHeader
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResponseHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.status != null && message.hasOwnProperty("status"))
            switch (message.status) {
            default:
                return "status: enum value expected";
            case 0:
            case 1:
            case 3:
            case 4:
                break;
            }
        if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
            if (!$util.isString(message.errorDescription))
                return "errorDescription: string expected";
        if (message.debugUrl != null && message.hasOwnProperty("debugUrl"))
            if (!$util.isString(message.debugUrl))
                return "debugUrl: string expected";
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            if (!$util.isString(message.requestTraceId))
                return "requestTraceId: string expected";
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            if (!$util.isInteger(message.currentServerTime) && !(message.currentServerTime && $util.isInteger(message.currentServerTime.low) && $util.isInteger(message.currentServerTime.high)))
                return "currentServerTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a ResponseHeader message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResponseHeader
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResponseHeader} ResponseHeader
     */
    ResponseHeader.fromObject = function fromObject(object) {
        if (object instanceof $root.ResponseHeader)
            return object;
        let message = new $root.ResponseHeader();
        switch (object.status) {
        case "RESPONSE_STATUS_UNKNOWN":
        case 0:
            message.status = 0;
            break;
        case "RESPONSE_STATUS_OK":
        case 1:
            message.status = 1;
            break;
        case "RESPONSE_STATUS_UNEXPECTED_ERROR":
        case 3:
            message.status = 3;
            break;
        case "RESPONSE_STATUS_INVALID_REQUEST":
        case 4:
            message.status = 4;
            break;
        }
        if (object.errorDescription != null)
            message.errorDescription = String(object.errorDescription);
        if (object.debugUrl != null)
            message.debugUrl = String(object.debugUrl);
        if (object.requestTraceId != null)
            message.requestTraceId = String(object.requestTraceId);
        if (object.currentServerTime != null)
            if ($util.Long)
                (message.currentServerTime = $util.Long.fromValue(object.currentServerTime)).unsigned = true;
            else if (typeof object.currentServerTime === "string")
                message.currentServerTime = parseInt(object.currentServerTime, 10);
            else if (typeof object.currentServerTime === "number")
                message.currentServerTime = object.currentServerTime;
            else if (typeof object.currentServerTime === "object")
                message.currentServerTime = new $util.LongBits(object.currentServerTime.low >>> 0, object.currentServerTime.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a ResponseHeader message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResponseHeader
     * @static
     * @param {ResponseHeader} message ResponseHeader
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResponseHeader.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.status = options.enums === String ? "RESPONSE_STATUS_UNKNOWN" : 0;
            object.errorDescription = "";
            object.debugUrl = "";
            object.requestTraceId = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.currentServerTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.currentServerTime = options.longs === String ? "0" : 0;
        }
        if (message.status != null && message.hasOwnProperty("status"))
            object.status = options.enums === String ? $root.ResponseStatus[message.status] : message.status;
        if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
            object.errorDescription = message.errorDescription;
        if (message.debugUrl != null && message.hasOwnProperty("debugUrl"))
            object.debugUrl = message.debugUrl;
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            object.requestTraceId = message.requestTraceId;
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            if (typeof message.currentServerTime === "number")
                object.currentServerTime = options.longs === String ? String(message.currentServerTime) : message.currentServerTime;
            else
                object.currentServerTime = options.longs === String ? $util.Long.prototype.toString.call(message.currentServerTime) : options.longs === Number ? new $util.LongBits(message.currentServerTime.low >>> 0, message.currentServerTime.high >>> 0).toNumber(true) : message.currentServerTime;
        return object;
    };

    /**
     * Converts this ResponseHeader to JSON.
     * @function toJSON
     * @memberof ResponseHeader
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResponseHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ResponseHeader;
})();

export const Entity = $root.Entity = (() => {

    /**
     * Properties of an Entity.
     * @exports IEntity
     * @interface IEntity
     * @property {IParticipantId|null} [id] Entity id
     * @property {IPresence|null} [presence] Entity presence
     * @property {IEntityProperties|null} [properties] Entity properties
     * @property {ParticipantType|null} [entityType] Entity entityType
     * @property {Entity.PastHangoutState|null} [hadPastHangoutState] Entity hadPastHangoutState
     */

    /**
     * Constructs a new Entity.
     * @exports Entity
     * @classdesc Represents an Entity.
     * @implements IEntity
     * @constructor
     * @param {IEntity=} [properties] Properties to set
     */
    function Entity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Entity id.
     * @member {IParticipantId|null|undefined} id
     * @memberof Entity
     * @instance
     */
    Entity.prototype.id = null;

    /**
     * Entity presence.
     * @member {IPresence|null|undefined} presence
     * @memberof Entity
     * @instance
     */
    Entity.prototype.presence = null;

    /**
     * Entity properties.
     * @member {IEntityProperties|null|undefined} properties
     * @memberof Entity
     * @instance
     */
    Entity.prototype.properties = null;

    /**
     * Entity entityType.
     * @member {ParticipantType} entityType
     * @memberof Entity
     * @instance
     */
    Entity.prototype.entityType = 0;

    /**
     * Entity hadPastHangoutState.
     * @member {Entity.PastHangoutState} hadPastHangoutState
     * @memberof Entity
     * @instance
     */
    Entity.prototype.hadPastHangoutState = 0;

    /**
     * Creates a new Entity instance using the specified properties.
     * @function create
     * @memberof Entity
     * @static
     * @param {IEntity=} [properties] Properties to set
     * @returns {Entity} Entity instance
     */
    Entity.create = function create(properties) {
        return new Entity(properties);
    };

    /**
     * Encodes the specified Entity message. Does not implicitly {@link Entity.verify|verify} messages.
     * @function encode
     * @memberof Entity
     * @static
     * @param {IEntity} message Entity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Entity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.presence != null && message.hasOwnProperty("presence"))
            $root.Presence.encode(message.presence, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.id != null && message.hasOwnProperty("id"))
            $root.ParticipantId.encode(message.id, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.properties != null && message.hasOwnProperty("properties"))
            $root.EntityProperties.encode(message.properties, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.entityType != null && message.hasOwnProperty("entityType"))
            writer.uint32(/* id 13, wireType 0 =*/104).int32(message.entityType);
        if (message.hadPastHangoutState != null && message.hasOwnProperty("hadPastHangoutState"))
            writer.uint32(/* id 16, wireType 0 =*/128).int32(message.hadPastHangoutState);
        return writer;
    };

    /**
     * Encodes the specified Entity message, length delimited. Does not implicitly {@link Entity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Entity
     * @static
     * @param {IEntity} message Entity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Entity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an Entity message from the specified reader or buffer.
     * @function decode
     * @memberof Entity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Entity} Entity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Entity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Entity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 9:
                message.id = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 8:
                message.presence = $root.Presence.decode(reader, reader.uint32());
                break;
            case 10:
                message.properties = $root.EntityProperties.decode(reader, reader.uint32());
                break;
            case 13:
                message.entityType = reader.int32();
                break;
            case 16:
                message.hadPastHangoutState = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an Entity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Entity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Entity} Entity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Entity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an Entity message.
     * @function verify
     * @memberof Entity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Entity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id")) {
            let error = $root.ParticipantId.verify(message.id);
            if (error)
                return "id." + error;
        }
        if (message.presence != null && message.hasOwnProperty("presence")) {
            let error = $root.Presence.verify(message.presence);
            if (error)
                return "presence." + error;
        }
        if (message.properties != null && message.hasOwnProperty("properties")) {
            let error = $root.EntityProperties.verify(message.properties);
            if (error)
                return "properties." + error;
        }
        if (message.entityType != null && message.hasOwnProperty("entityType"))
            switch (message.entityType) {
            default:
                return "entityType: enum value expected";
            case 0:
            case 2:
            case 3:
                break;
            }
        if (message.hadPastHangoutState != null && message.hasOwnProperty("hadPastHangoutState"))
            switch (message.hadPastHangoutState) {
            default:
                return "hadPastHangoutState: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates an Entity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Entity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Entity} Entity
     */
    Entity.fromObject = function fromObject(object) {
        if (object instanceof $root.Entity)
            return object;
        let message = new $root.Entity();
        if (object.id != null) {
            if (typeof object.id !== "object")
                throw TypeError(".Entity.id: object expected");
            message.id = $root.ParticipantId.fromObject(object.id);
        }
        if (object.presence != null) {
            if (typeof object.presence !== "object")
                throw TypeError(".Entity.presence: object expected");
            message.presence = $root.Presence.fromObject(object.presence);
        }
        if (object.properties != null) {
            if (typeof object.properties !== "object")
                throw TypeError(".Entity.properties: object expected");
            message.properties = $root.EntityProperties.fromObject(object.properties);
        }
        switch (object.entityType) {
        case "PARTICIPANT_TYPE_UNKNOWN":
        case 0:
            message.entityType = 0;
            break;
        case "PARTICIPANT_TYPE_GAIA":
        case 2:
            message.entityType = 2;
            break;
        case "PARTICIPANT_TYPE_GOOGLE_VOICE":
        case 3:
            message.entityType = 3;
            break;
        }
        switch (object.hadPastHangoutState) {
        case "PAST_HANGOUT_STATE_UNKNOWN":
        case 0:
            message.hadPastHangoutState = 0;
            break;
        case "PAST_HANGOUT_STATE_HAD_PAST_HANGOUT":
        case 1:
            message.hadPastHangoutState = 1;
            break;
        case "PAST_HANGOUT_STATE_NO_PAST_HANGOUT":
        case 2:
            message.hadPastHangoutState = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from an Entity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Entity
     * @static
     * @param {Entity} message Entity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Entity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.presence = null;
            object.id = null;
            object.properties = null;
            object.entityType = options.enums === String ? "PARTICIPANT_TYPE_UNKNOWN" : 0;
            object.hadPastHangoutState = options.enums === String ? "PAST_HANGOUT_STATE_UNKNOWN" : 0;
        }
        if (message.presence != null && message.hasOwnProperty("presence"))
            object.presence = $root.Presence.toObject(message.presence, options);
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = $root.ParticipantId.toObject(message.id, options);
        if (message.properties != null && message.hasOwnProperty("properties"))
            object.properties = $root.EntityProperties.toObject(message.properties, options);
        if (message.entityType != null && message.hasOwnProperty("entityType"))
            object.entityType = options.enums === String ? $root.ParticipantType[message.entityType] : message.entityType;
        if (message.hadPastHangoutState != null && message.hasOwnProperty("hadPastHangoutState"))
            object.hadPastHangoutState = options.enums === String ? $root.Entity.PastHangoutState[message.hadPastHangoutState] : message.hadPastHangoutState;
        return object;
    };

    /**
     * Converts this Entity to JSON.
     * @function toJSON
     * @memberof Entity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Entity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * PastHangoutState enum.
     * @name Entity.PastHangoutState
     * @enum {string}
     * @property {number} PAST_HANGOUT_STATE_UNKNOWN=0 PAST_HANGOUT_STATE_UNKNOWN value
     * @property {number} PAST_HANGOUT_STATE_HAD_PAST_HANGOUT=1 PAST_HANGOUT_STATE_HAD_PAST_HANGOUT value
     * @property {number} PAST_HANGOUT_STATE_NO_PAST_HANGOUT=2 PAST_HANGOUT_STATE_NO_PAST_HANGOUT value
     */
    Entity.PastHangoutState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PAST_HANGOUT_STATE_UNKNOWN"] = 0;
        values[valuesById[1] = "PAST_HANGOUT_STATE_HAD_PAST_HANGOUT"] = 1;
        values[valuesById[2] = "PAST_HANGOUT_STATE_NO_PAST_HANGOUT"] = 2;
        return values;
    })();

    return Entity;
})();

export const EntityProperties = $root.EntityProperties = (() => {

    /**
     * Properties of an EntityProperties.
     * @exports IEntityProperties
     * @interface IEntityProperties
     * @property {ProfileType|null} [type] EntityProperties type
     * @property {string|null} [displayName] EntityProperties displayName
     * @property {string|null} [firstName] EntityProperties firstName
     * @property {string|null} [photoUrl] EntityProperties photoUrl
     * @property {Array.<string>|null} [email] EntityProperties email
     * @property {Array.<string>|null} [phone] EntityProperties phone
     * @property {boolean|null} [inUsersDomain] EntityProperties inUsersDomain
     * @property {Gender|null} [gender] EntityProperties gender
     * @property {PhotoUrlStatus|null} [photoUrlStatus] EntityProperties photoUrlStatus
     * @property {string|null} [canonicalEmail] EntityProperties canonicalEmail
     */

    /**
     * Constructs a new EntityProperties.
     * @exports EntityProperties
     * @classdesc Represents an EntityProperties.
     * @implements IEntityProperties
     * @constructor
     * @param {IEntityProperties=} [properties] Properties to set
     */
    function EntityProperties(properties) {
        this.email = [];
        this.phone = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EntityProperties type.
     * @member {ProfileType} type
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.type = 0;

    /**
     * EntityProperties displayName.
     * @member {string} displayName
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.displayName = "";

    /**
     * EntityProperties firstName.
     * @member {string} firstName
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.firstName = "";

    /**
     * EntityProperties photoUrl.
     * @member {string} photoUrl
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.photoUrl = "";

    /**
     * EntityProperties email.
     * @member {Array.<string>} email
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.email = $util.emptyArray;

    /**
     * EntityProperties phone.
     * @member {Array.<string>} phone
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.phone = $util.emptyArray;

    /**
     * EntityProperties inUsersDomain.
     * @member {boolean} inUsersDomain
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.inUsersDomain = false;

    /**
     * EntityProperties gender.
     * @member {Gender} gender
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.gender = 0;

    /**
     * EntityProperties photoUrlStatus.
     * @member {PhotoUrlStatus} photoUrlStatus
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.photoUrlStatus = 0;

    /**
     * EntityProperties canonicalEmail.
     * @member {string} canonicalEmail
     * @memberof EntityProperties
     * @instance
     */
    EntityProperties.prototype.canonicalEmail = "";

    /**
     * Creates a new EntityProperties instance using the specified properties.
     * @function create
     * @memberof EntityProperties
     * @static
     * @param {IEntityProperties=} [properties] Properties to set
     * @returns {EntityProperties} EntityProperties instance
     */
    EntityProperties.create = function create(properties) {
        return new EntityProperties(properties);
    };

    /**
     * Encodes the specified EntityProperties message. Does not implicitly {@link EntityProperties.verify|verify} messages.
     * @function encode
     * @memberof EntityProperties
     * @static
     * @param {IEntityProperties} message EntityProperties message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityProperties.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
        if (message.firstName != null && message.hasOwnProperty("firstName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.firstName);
        if (message.photoUrl != null && message.hasOwnProperty("photoUrl"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.photoUrl);
        if (message.email != null && message.email.length)
            for (let i = 0; i < message.email.length; ++i)
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.email[i]);
        if (message.phone != null && message.phone.length)
            for (let i = 0; i < message.phone.length; ++i)
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.phone[i]);
        if (message.inUsersDomain != null && message.hasOwnProperty("inUsersDomain"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.inUsersDomain);
        if (message.gender != null && message.hasOwnProperty("gender"))
            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gender);
        if (message.photoUrlStatus != null && message.hasOwnProperty("photoUrlStatus"))
            writer.uint32(/* id 12, wireType 0 =*/96).int32(message.photoUrlStatus);
        if (message.canonicalEmail != null && message.hasOwnProperty("canonicalEmail"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.canonicalEmail);
        return writer;
    };

    /**
     * Encodes the specified EntityProperties message, length delimited. Does not implicitly {@link EntityProperties.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EntityProperties
     * @static
     * @param {IEntityProperties} message EntityProperties message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityProperties.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EntityProperties message from the specified reader or buffer.
     * @function decode
     * @memberof EntityProperties
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EntityProperties} EntityProperties
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityProperties.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EntityProperties();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.displayName = reader.string();
                break;
            case 3:
                message.firstName = reader.string();
                break;
            case 4:
                message.photoUrl = reader.string();
                break;
            case 5:
                if (!(message.email && message.email.length))
                    message.email = [];
                message.email.push(reader.string());
                break;
            case 6:
                if (!(message.phone && message.phone.length))
                    message.phone = [];
                message.phone.push(reader.string());
                break;
            case 10:
                message.inUsersDomain = reader.bool();
                break;
            case 11:
                message.gender = reader.int32();
                break;
            case 12:
                message.photoUrlStatus = reader.int32();
                break;
            case 15:
                message.canonicalEmail = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EntityProperties message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EntityProperties
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EntityProperties} EntityProperties
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityProperties.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EntityProperties message.
     * @function verify
     * @memberof EntityProperties
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EntityProperties.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            if (!$util.isString(message.displayName))
                return "displayName: string expected";
        if (message.firstName != null && message.hasOwnProperty("firstName"))
            if (!$util.isString(message.firstName))
                return "firstName: string expected";
        if (message.photoUrl != null && message.hasOwnProperty("photoUrl"))
            if (!$util.isString(message.photoUrl))
                return "photoUrl: string expected";
        if (message.email != null && message.hasOwnProperty("email")) {
            if (!Array.isArray(message.email))
                return "email: array expected";
            for (let i = 0; i < message.email.length; ++i)
                if (!$util.isString(message.email[i]))
                    return "email: string[] expected";
        }
        if (message.phone != null && message.hasOwnProperty("phone")) {
            if (!Array.isArray(message.phone))
                return "phone: array expected";
            for (let i = 0; i < message.phone.length; ++i)
                if (!$util.isString(message.phone[i]))
                    return "phone: string[] expected";
        }
        if (message.inUsersDomain != null && message.hasOwnProperty("inUsersDomain"))
            if (typeof message.inUsersDomain !== "boolean")
                return "inUsersDomain: boolean expected";
        if (message.gender != null && message.hasOwnProperty("gender"))
            switch (message.gender) {
            default:
                return "gender: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.photoUrlStatus != null && message.hasOwnProperty("photoUrlStatus"))
            switch (message.photoUrlStatus) {
            default:
                return "photoUrlStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.canonicalEmail != null && message.hasOwnProperty("canonicalEmail"))
            if (!$util.isString(message.canonicalEmail))
                return "canonicalEmail: string expected";
        return null;
    };

    /**
     * Creates an EntityProperties message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EntityProperties
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EntityProperties} EntityProperties
     */
    EntityProperties.fromObject = function fromObject(object) {
        if (object instanceof $root.EntityProperties)
            return object;
        let message = new $root.EntityProperties();
        switch (object.type) {
        case "PROFILE_TYPE_NONE":
        case 0:
            message.type = 0;
            break;
        case "PROFILE_TYPE_ES_USER":
        case 1:
            message.type = 1;
            break;
        }
        if (object.displayName != null)
            message.displayName = String(object.displayName);
        if (object.firstName != null)
            message.firstName = String(object.firstName);
        if (object.photoUrl != null)
            message.photoUrl = String(object.photoUrl);
        if (object.email) {
            if (!Array.isArray(object.email))
                throw TypeError(".EntityProperties.email: array expected");
            message.email = [];
            for (let i = 0; i < object.email.length; ++i)
                message.email[i] = String(object.email[i]);
        }
        if (object.phone) {
            if (!Array.isArray(object.phone))
                throw TypeError(".EntityProperties.phone: array expected");
            message.phone = [];
            for (let i = 0; i < object.phone.length; ++i)
                message.phone[i] = String(object.phone[i]);
        }
        if (object.inUsersDomain != null)
            message.inUsersDomain = Boolean(object.inUsersDomain);
        switch (object.gender) {
        case "GENDER_UNKNOWN":
        case 0:
            message.gender = 0;
            break;
        case "GENDER_MALE":
        case 1:
            message.gender = 1;
            break;
        case "GENDER_FEMALE":
        case 2:
            message.gender = 2;
            break;
        }
        switch (object.photoUrlStatus) {
        case "PHOTO_URL_STATUS_UNKNOWN":
        case 0:
            message.photoUrlStatus = 0;
            break;
        case "PHOTO_URL_STATUS_PLACEHOLDER":
        case 1:
            message.photoUrlStatus = 1;
            break;
        case "PHOTO_URL_STATUS_USER_PHOTO":
        case 2:
            message.photoUrlStatus = 2;
            break;
        }
        if (object.canonicalEmail != null)
            message.canonicalEmail = String(object.canonicalEmail);
        return message;
    };

    /**
     * Creates a plain object from an EntityProperties message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EntityProperties
     * @static
     * @param {EntityProperties} message EntityProperties
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EntityProperties.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.email = [];
            object.phone = [];
        }
        if (options.defaults) {
            object.type = options.enums === String ? "PROFILE_TYPE_NONE" : 0;
            object.displayName = "";
            object.firstName = "";
            object.photoUrl = "";
            object.inUsersDomain = false;
            object.gender = options.enums === String ? "GENDER_UNKNOWN" : 0;
            object.photoUrlStatus = options.enums === String ? "PHOTO_URL_STATUS_UNKNOWN" : 0;
            object.canonicalEmail = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.ProfileType[message.type] : message.type;
        if (message.displayName != null && message.hasOwnProperty("displayName"))
            object.displayName = message.displayName;
        if (message.firstName != null && message.hasOwnProperty("firstName"))
            object.firstName = message.firstName;
        if (message.photoUrl != null && message.hasOwnProperty("photoUrl"))
            object.photoUrl = message.photoUrl;
        if (message.email && message.email.length) {
            object.email = [];
            for (let j = 0; j < message.email.length; ++j)
                object.email[j] = message.email[j];
        }
        if (message.phone && message.phone.length) {
            object.phone = [];
            for (let j = 0; j < message.phone.length; ++j)
                object.phone[j] = message.phone[j];
        }
        if (message.inUsersDomain != null && message.hasOwnProperty("inUsersDomain"))
            object.inUsersDomain = message.inUsersDomain;
        if (message.gender != null && message.hasOwnProperty("gender"))
            object.gender = options.enums === String ? $root.Gender[message.gender] : message.gender;
        if (message.photoUrlStatus != null && message.hasOwnProperty("photoUrlStatus"))
            object.photoUrlStatus = options.enums === String ? $root.PhotoUrlStatus[message.photoUrlStatus] : message.photoUrlStatus;
        if (message.canonicalEmail != null && message.hasOwnProperty("canonicalEmail"))
            object.canonicalEmail = message.canonicalEmail;
        return object;
    };

    /**
     * Converts this EntityProperties to JSON.
     * @function toJSON
     * @memberof EntityProperties
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EntityProperties.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EntityProperties;
})();

/**
 * PhotoUrlStatus enum.
 * @exports PhotoUrlStatus
 * @enum {string}
 * @property {number} PHOTO_URL_STATUS_UNKNOWN=0 PHOTO_URL_STATUS_UNKNOWN value
 * @property {number} PHOTO_URL_STATUS_PLACEHOLDER=1 PHOTO_URL_STATUS_PLACEHOLDER value
 * @property {number} PHOTO_URL_STATUS_USER_PHOTO=2 PHOTO_URL_STATUS_USER_PHOTO value
 */
$root.PhotoUrlStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PHOTO_URL_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "PHOTO_URL_STATUS_PLACEHOLDER"] = 1;
    values[valuesById[2] = "PHOTO_URL_STATUS_USER_PHOTO"] = 2;
    return values;
})();

/**
 * Gender enum.
 * @exports Gender
 * @enum {string}
 * @property {number} GENDER_UNKNOWN=0 GENDER_UNKNOWN value
 * @property {number} GENDER_MALE=1 GENDER_MALE value
 * @property {number} GENDER_FEMALE=2 GENDER_FEMALE value
 */
$root.Gender = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "GENDER_UNKNOWN"] = 0;
    values[valuesById[1] = "GENDER_MALE"] = 1;
    values[valuesById[2] = "GENDER_FEMALE"] = 2;
    return values;
})();

/**
 * ProfileType enum.
 * @exports ProfileType
 * @enum {string}
 * @property {number} PROFILE_TYPE_NONE=0 PROFILE_TYPE_NONE value
 * @property {number} PROFILE_TYPE_ES_USER=1 PROFILE_TYPE_ES_USER value
 */
$root.ProfileType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PROFILE_TYPE_NONE"] = 0;
    values[valuesById[1] = "PROFILE_TYPE_ES_USER"] = 1;
    return values;
})();

export const ConversationState = $root.ConversationState = (() => {

    /**
     * Properties of a ConversationState.
     * @exports IConversationState
     * @interface IConversationState
     * @property {IConversationId|null} [conversationId] ConversationState conversationId
     * @property {IConversation|null} [conversation] ConversationState conversation
     * @property {Array.<IEvent>|null} [event] ConversationState event
     * @property {IEventContinuationToken|null} [eventContinuationToken] ConversationState eventContinuationToken
     */

    /**
     * Constructs a new ConversationState.
     * @exports ConversationState
     * @classdesc Represents a ConversationState.
     * @implements IConversationState
     * @constructor
     * @param {IConversationState=} [properties] Properties to set
     */
    function ConversationState(properties) {
        this.event = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationState conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof ConversationState
     * @instance
     */
    ConversationState.prototype.conversationId = null;

    /**
     * ConversationState conversation.
     * @member {IConversation|null|undefined} conversation
     * @memberof ConversationState
     * @instance
     */
    ConversationState.prototype.conversation = null;

    /**
     * ConversationState event.
     * @member {Array.<IEvent>} event
     * @memberof ConversationState
     * @instance
     */
    ConversationState.prototype.event = $util.emptyArray;

    /**
     * ConversationState eventContinuationToken.
     * @member {IEventContinuationToken|null|undefined} eventContinuationToken
     * @memberof ConversationState
     * @instance
     */
    ConversationState.prototype.eventContinuationToken = null;

    /**
     * Creates a new ConversationState instance using the specified properties.
     * @function create
     * @memberof ConversationState
     * @static
     * @param {IConversationState=} [properties] Properties to set
     * @returns {ConversationState} ConversationState instance
     */
    ConversationState.create = function create(properties) {
        return new ConversationState(properties);
    };

    /**
     * Encodes the specified ConversationState message. Does not implicitly {@link ConversationState.verify|verify} messages.
     * @function encode
     * @memberof ConversationState
     * @static
     * @param {IConversationState} message ConversationState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            $root.Conversation.encode(message.conversation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.event != null && message.event.length)
            for (let i = 0; i < message.event.length; ++i)
                $root.Event.encode(message.event[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken"))
            $root.EventContinuationToken.encode(message.eventContinuationToken, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConversationState message, length delimited. Does not implicitly {@link ConversationState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationState
     * @static
     * @param {IConversationState} message ConversationState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationState message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationState} ConversationState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversation = $root.Conversation.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.event && message.event.length))
                    message.event = [];
                message.event.push($root.Event.decode(reader, reader.uint32()));
                break;
            case 5:
                message.eventContinuationToken = $root.EventContinuationToken.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationState} ConversationState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationState message.
     * @function verify
     * @memberof ConversationState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.conversation != null && message.hasOwnProperty("conversation")) {
            let error = $root.Conversation.verify(message.conversation);
            if (error)
                return "conversation." + error;
        }
        if (message.event != null && message.hasOwnProperty("event")) {
            if (!Array.isArray(message.event))
                return "event: array expected";
            for (let i = 0; i < message.event.length; ++i) {
                let error = $root.Event.verify(message.event[i]);
                if (error)
                    return "event." + error;
            }
        }
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken")) {
            let error = $root.EventContinuationToken.verify(message.eventContinuationToken);
            if (error)
                return "eventContinuationToken." + error;
        }
        return null;
    };

    /**
     * Creates a ConversationState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationState} ConversationState
     */
    ConversationState.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationState)
            return object;
        let message = new $root.ConversationState();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".ConversationState.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.conversation != null) {
            if (typeof object.conversation !== "object")
                throw TypeError(".ConversationState.conversation: object expected");
            message.conversation = $root.Conversation.fromObject(object.conversation);
        }
        if (object.event) {
            if (!Array.isArray(object.event))
                throw TypeError(".ConversationState.event: array expected");
            message.event = [];
            for (let i = 0; i < object.event.length; ++i) {
                if (typeof object.event[i] !== "object")
                    throw TypeError(".ConversationState.event: object expected");
                message.event[i] = $root.Event.fromObject(object.event[i]);
            }
        }
        if (object.eventContinuationToken != null) {
            if (typeof object.eventContinuationToken !== "object")
                throw TypeError(".ConversationState.eventContinuationToken: object expected");
            message.eventContinuationToken = $root.EventContinuationToken.fromObject(object.eventContinuationToken);
        }
        return message;
    };

    /**
     * Creates a plain object from a ConversationState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationState
     * @static
     * @param {ConversationState} message ConversationState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.event = [];
        if (options.defaults) {
            object.conversationId = null;
            object.conversation = null;
            object.eventContinuationToken = null;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            object.conversation = $root.Conversation.toObject(message.conversation, options);
        if (message.event && message.event.length) {
            object.event = [];
            for (let j = 0; j < message.event.length; ++j)
                object.event[j] = $root.Event.toObject(message.event[j], options);
        }
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken"))
            object.eventContinuationToken = $root.EventContinuationToken.toObject(message.eventContinuationToken, options);
        return object;
    };

    /**
     * Converts this ConversationState to JSON.
     * @function toJSON
     * @memberof ConversationState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationState;
})();

export const EventContinuationToken = $root.EventContinuationToken = (() => {

    /**
     * Properties of an EventContinuationToken.
     * @exports IEventContinuationToken
     * @interface IEventContinuationToken
     * @property {string|null} [eventId] EventContinuationToken eventId
     * @property {Uint8Array|null} [storageContinuationToken] EventContinuationToken storageContinuationToken
     * @property {number|Long|null} [eventTimestamp] EventContinuationToken eventTimestamp
     */

    /**
     * Constructs a new EventContinuationToken.
     * @exports EventContinuationToken
     * @classdesc Represents an EventContinuationToken.
     * @implements IEventContinuationToken
     * @constructor
     * @param {IEventContinuationToken=} [properties] Properties to set
     */
    function EventContinuationToken(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EventContinuationToken eventId.
     * @member {string} eventId
     * @memberof EventContinuationToken
     * @instance
     */
    EventContinuationToken.prototype.eventId = "";

    /**
     * EventContinuationToken storageContinuationToken.
     * @member {Uint8Array} storageContinuationToken
     * @memberof EventContinuationToken
     * @instance
     */
    EventContinuationToken.prototype.storageContinuationToken = $util.newBuffer([]);

    /**
     * EventContinuationToken eventTimestamp.
     * @member {number|Long} eventTimestamp
     * @memberof EventContinuationToken
     * @instance
     */
    EventContinuationToken.prototype.eventTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new EventContinuationToken instance using the specified properties.
     * @function create
     * @memberof EventContinuationToken
     * @static
     * @param {IEventContinuationToken=} [properties] Properties to set
     * @returns {EventContinuationToken} EventContinuationToken instance
     */
    EventContinuationToken.create = function create(properties) {
        return new EventContinuationToken(properties);
    };

    /**
     * Encodes the specified EventContinuationToken message. Does not implicitly {@link EventContinuationToken.verify|verify} messages.
     * @function encode
     * @memberof EventContinuationToken
     * @static
     * @param {IEventContinuationToken} message EventContinuationToken message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventContinuationToken.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eventId);
        if (message.storageContinuationToken != null && message.hasOwnProperty("storageContinuationToken"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.storageContinuationToken);
        if (message.eventTimestamp != null && message.hasOwnProperty("eventTimestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.eventTimestamp);
        return writer;
    };

    /**
     * Encodes the specified EventContinuationToken message, length delimited. Does not implicitly {@link EventContinuationToken.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EventContinuationToken
     * @static
     * @param {IEventContinuationToken} message EventContinuationToken message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventContinuationToken.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EventContinuationToken message from the specified reader or buffer.
     * @function decode
     * @memberof EventContinuationToken
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EventContinuationToken} EventContinuationToken
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventContinuationToken.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EventContinuationToken();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.eventId = reader.string();
                break;
            case 2:
                message.storageContinuationToken = reader.bytes();
                break;
            case 3:
                message.eventTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EventContinuationToken message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EventContinuationToken
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EventContinuationToken} EventContinuationToken
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventContinuationToken.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EventContinuationToken message.
     * @function verify
     * @memberof EventContinuationToken
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EventContinuationToken.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            if (!$util.isString(message.eventId))
                return "eventId: string expected";
        if (message.storageContinuationToken != null && message.hasOwnProperty("storageContinuationToken"))
            if (!(message.storageContinuationToken && typeof message.storageContinuationToken.length === "number" || $util.isString(message.storageContinuationToken)))
                return "storageContinuationToken: buffer expected";
        if (message.eventTimestamp != null && message.hasOwnProperty("eventTimestamp"))
            if (!$util.isInteger(message.eventTimestamp) && !(message.eventTimestamp && $util.isInteger(message.eventTimestamp.low) && $util.isInteger(message.eventTimestamp.high)))
                return "eventTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates an EventContinuationToken message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EventContinuationToken
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EventContinuationToken} EventContinuationToken
     */
    EventContinuationToken.fromObject = function fromObject(object) {
        if (object instanceof $root.EventContinuationToken)
            return object;
        let message = new $root.EventContinuationToken();
        if (object.eventId != null)
            message.eventId = String(object.eventId);
        if (object.storageContinuationToken != null)
            if (typeof object.storageContinuationToken === "string")
                $util.base64.decode(object.storageContinuationToken, message.storageContinuationToken = $util.newBuffer($util.base64.length(object.storageContinuationToken)), 0);
            else if (object.storageContinuationToken.length)
                message.storageContinuationToken = object.storageContinuationToken;
        if (object.eventTimestamp != null)
            if ($util.Long)
                (message.eventTimestamp = $util.Long.fromValue(object.eventTimestamp)).unsigned = true;
            else if (typeof object.eventTimestamp === "string")
                message.eventTimestamp = parseInt(object.eventTimestamp, 10);
            else if (typeof object.eventTimestamp === "number")
                message.eventTimestamp = object.eventTimestamp;
            else if (typeof object.eventTimestamp === "object")
                message.eventTimestamp = new $util.LongBits(object.eventTimestamp.low >>> 0, object.eventTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from an EventContinuationToken message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EventContinuationToken
     * @static
     * @param {EventContinuationToken} message EventContinuationToken
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EventContinuationToken.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.eventId = "";
            if (options.bytes === String)
                object.storageContinuationToken = "";
            else {
                object.storageContinuationToken = [];
                if (options.bytes !== Array)
                    object.storageContinuationToken = $util.newBuffer(object.storageContinuationToken);
            }
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.eventTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.eventTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.eventId != null && message.hasOwnProperty("eventId"))
            object.eventId = message.eventId;
        if (message.storageContinuationToken != null && message.hasOwnProperty("storageContinuationToken"))
            object.storageContinuationToken = options.bytes === String ? $util.base64.encode(message.storageContinuationToken, 0, message.storageContinuationToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.storageContinuationToken) : message.storageContinuationToken;
        if (message.eventTimestamp != null && message.hasOwnProperty("eventTimestamp"))
            if (typeof message.eventTimestamp === "number")
                object.eventTimestamp = options.longs === String ? String(message.eventTimestamp) : message.eventTimestamp;
            else
                object.eventTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.eventTimestamp) : options.longs === Number ? new $util.LongBits(message.eventTimestamp.low >>> 0, message.eventTimestamp.high >>> 0).toNumber(true) : message.eventTimestamp;
        return object;
    };

    /**
     * Converts this EventContinuationToken to JSON.
     * @function toJSON
     * @memberof EventContinuationToken
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EventContinuationToken.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EventContinuationToken;
})();

export const EntityLookupSpec = $root.EntityLookupSpec = (() => {

    /**
     * Properties of an EntityLookupSpec.
     * @exports IEntityLookupSpec
     * @interface IEntityLookupSpec
     * @property {string|null} [gaiaId] EntityLookupSpec gaiaId
     * @property {string|null} [email] EntityLookupSpec email
     * @property {string|null} [phone] EntityLookupSpec phone
     * @property {boolean|null} [createOffnetworkGaia] EntityLookupSpec createOffnetworkGaia
     */

    /**
     * Constructs a new EntityLookupSpec.
     * @exports EntityLookupSpec
     * @classdesc Represents an EntityLookupSpec.
     * @implements IEntityLookupSpec
     * @constructor
     * @param {IEntityLookupSpec=} [properties] Properties to set
     */
    function EntityLookupSpec(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EntityLookupSpec gaiaId.
     * @member {string} gaiaId
     * @memberof EntityLookupSpec
     * @instance
     */
    EntityLookupSpec.prototype.gaiaId = "";

    /**
     * EntityLookupSpec email.
     * @member {string} email
     * @memberof EntityLookupSpec
     * @instance
     */
    EntityLookupSpec.prototype.email = "";

    /**
     * EntityLookupSpec phone.
     * @member {string} phone
     * @memberof EntityLookupSpec
     * @instance
     */
    EntityLookupSpec.prototype.phone = "";

    /**
     * EntityLookupSpec createOffnetworkGaia.
     * @member {boolean} createOffnetworkGaia
     * @memberof EntityLookupSpec
     * @instance
     */
    EntityLookupSpec.prototype.createOffnetworkGaia = false;

    /**
     * Creates a new EntityLookupSpec instance using the specified properties.
     * @function create
     * @memberof EntityLookupSpec
     * @static
     * @param {IEntityLookupSpec=} [properties] Properties to set
     * @returns {EntityLookupSpec} EntityLookupSpec instance
     */
    EntityLookupSpec.create = function create(properties) {
        return new EntityLookupSpec(properties);
    };

    /**
     * Encodes the specified EntityLookupSpec message. Does not implicitly {@link EntityLookupSpec.verify|verify} messages.
     * @function encode
     * @memberof EntityLookupSpec
     * @static
     * @param {IEntityLookupSpec} message EntityLookupSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityLookupSpec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.gaiaId);
        if (message.email != null && message.hasOwnProperty("email"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
        if (message.phone != null && message.hasOwnProperty("phone"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.phone);
        if (message.createOffnetworkGaia != null && message.hasOwnProperty("createOffnetworkGaia"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.createOffnetworkGaia);
        return writer;
    };

    /**
     * Encodes the specified EntityLookupSpec message, length delimited. Does not implicitly {@link EntityLookupSpec.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EntityLookupSpec
     * @static
     * @param {IEntityLookupSpec} message EntityLookupSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityLookupSpec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EntityLookupSpec message from the specified reader or buffer.
     * @function decode
     * @memberof EntityLookupSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EntityLookupSpec} EntityLookupSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityLookupSpec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EntityLookupSpec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.gaiaId = reader.string();
                break;
            case 3:
                message.email = reader.string();
                break;
            case 4:
                message.phone = reader.string();
                break;
            case 6:
                message.createOffnetworkGaia = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EntityLookupSpec message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EntityLookupSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EntityLookupSpec} EntityLookupSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityLookupSpec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EntityLookupSpec message.
     * @function verify
     * @memberof EntityLookupSpec
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EntityLookupSpec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            if (!$util.isString(message.gaiaId))
                return "gaiaId: string expected";
        if (message.email != null && message.hasOwnProperty("email"))
            if (!$util.isString(message.email))
                return "email: string expected";
        if (message.phone != null && message.hasOwnProperty("phone"))
            if (!$util.isString(message.phone))
                return "phone: string expected";
        if (message.createOffnetworkGaia != null && message.hasOwnProperty("createOffnetworkGaia"))
            if (typeof message.createOffnetworkGaia !== "boolean")
                return "createOffnetworkGaia: boolean expected";
        return null;
    };

    /**
     * Creates an EntityLookupSpec message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EntityLookupSpec
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EntityLookupSpec} EntityLookupSpec
     */
    EntityLookupSpec.fromObject = function fromObject(object) {
        if (object instanceof $root.EntityLookupSpec)
            return object;
        let message = new $root.EntityLookupSpec();
        if (object.gaiaId != null)
            message.gaiaId = String(object.gaiaId);
        if (object.email != null)
            message.email = String(object.email);
        if (object.phone != null)
            message.phone = String(object.phone);
        if (object.createOffnetworkGaia != null)
            message.createOffnetworkGaia = Boolean(object.createOffnetworkGaia);
        return message;
    };

    /**
     * Creates a plain object from an EntityLookupSpec message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EntityLookupSpec
     * @static
     * @param {EntityLookupSpec} message EntityLookupSpec
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EntityLookupSpec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.gaiaId = "";
            object.email = "";
            object.phone = "";
            object.createOffnetworkGaia = false;
        }
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            object.gaiaId = message.gaiaId;
        if (message.email != null && message.hasOwnProperty("email"))
            object.email = message.email;
        if (message.phone != null && message.hasOwnProperty("phone"))
            object.phone = message.phone;
        if (message.createOffnetworkGaia != null && message.hasOwnProperty("createOffnetworkGaia"))
            object.createOffnetworkGaia = message.createOffnetworkGaia;
        return object;
    };

    /**
     * Converts this EntityLookupSpec to JSON.
     * @function toJSON
     * @memberof EntityLookupSpec
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EntityLookupSpec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EntityLookupSpec;
})();

/**
 * ConfigurationBitType enum.
 * @exports ConfigurationBitType
 * @enum {string}
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN=0 CONFIGURATION_BIT_TYPE_UNKNOWN value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_1=1 CONFIGURATION_BIT_TYPE_UNKNOWN_1 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_2=2 CONFIGURATION_BIT_TYPE_UNKNOWN_2 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_3=3 CONFIGURATION_BIT_TYPE_UNKNOWN_3 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_4=4 CONFIGURATION_BIT_TYPE_UNKNOWN_4 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_5=5 CONFIGURATION_BIT_TYPE_UNKNOWN_5 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_6=6 CONFIGURATION_BIT_TYPE_UNKNOWN_6 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_7=7 CONFIGURATION_BIT_TYPE_UNKNOWN_7 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_8=8 CONFIGURATION_BIT_TYPE_UNKNOWN_8 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_9=9 CONFIGURATION_BIT_TYPE_UNKNOWN_9 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_10=10 CONFIGURATION_BIT_TYPE_UNKNOWN_10 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_11=11 CONFIGURATION_BIT_TYPE_UNKNOWN_11 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_12=12 CONFIGURATION_BIT_TYPE_UNKNOWN_12 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_13=13 CONFIGURATION_BIT_TYPE_UNKNOWN_13 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_14=14 CONFIGURATION_BIT_TYPE_UNKNOWN_14 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_15=15 CONFIGURATION_BIT_TYPE_UNKNOWN_15 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_16=16 CONFIGURATION_BIT_TYPE_UNKNOWN_16 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_17=17 CONFIGURATION_BIT_TYPE_UNKNOWN_17 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_18=18 CONFIGURATION_BIT_TYPE_UNKNOWN_18 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_19=19 CONFIGURATION_BIT_TYPE_UNKNOWN_19 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_20=20 CONFIGURATION_BIT_TYPE_UNKNOWN_20 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_21=21 CONFIGURATION_BIT_TYPE_UNKNOWN_21 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_22=22 CONFIGURATION_BIT_TYPE_UNKNOWN_22 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_23=23 CONFIGURATION_BIT_TYPE_UNKNOWN_23 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_24=24 CONFIGURATION_BIT_TYPE_UNKNOWN_24 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_25=25 CONFIGURATION_BIT_TYPE_UNKNOWN_25 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_26=26 CONFIGURATION_BIT_TYPE_UNKNOWN_26 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_27=27 CONFIGURATION_BIT_TYPE_UNKNOWN_27 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_28=28 CONFIGURATION_BIT_TYPE_UNKNOWN_28 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_29=29 CONFIGURATION_BIT_TYPE_UNKNOWN_29 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_30=30 CONFIGURATION_BIT_TYPE_UNKNOWN_30 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_31=31 CONFIGURATION_BIT_TYPE_UNKNOWN_31 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_32=32 CONFIGURATION_BIT_TYPE_UNKNOWN_32 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_33=33 CONFIGURATION_BIT_TYPE_UNKNOWN_33 value
 * @property {number} CONFIGURATION_BIT_TYPE_DESKTOP_AUTO_EMOJI_CONVERSION_ENABLED=34 CONFIGURATION_BIT_TYPE_DESKTOP_AUTO_EMOJI_CONVERSION_ENABLED value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_35=35 CONFIGURATION_BIT_TYPE_UNKNOWN_35 value
 * @property {number} CONFIGURATION_BIT_TYPE_UNKNOWN_36=36 CONFIGURATION_BIT_TYPE_UNKNOWN_36 value
 * @property {number} CONFIGURATION_BIT_TYPE_DESKTOP_COMPACT_MODE_ENABLED=38 CONFIGURATION_BIT_TYPE_DESKTOP_COMPACT_MODE_ENABLED value
 */
$root.ConfigurationBitType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CONFIGURATION_BIT_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "CONFIGURATION_BIT_TYPE_UNKNOWN_1"] = 1;
    values[valuesById[2] = "CONFIGURATION_BIT_TYPE_UNKNOWN_2"] = 2;
    values[valuesById[3] = "CONFIGURATION_BIT_TYPE_UNKNOWN_3"] = 3;
    values[valuesById[4] = "CONFIGURATION_BIT_TYPE_UNKNOWN_4"] = 4;
    values[valuesById[5] = "CONFIGURATION_BIT_TYPE_UNKNOWN_5"] = 5;
    values[valuesById[6] = "CONFIGURATION_BIT_TYPE_UNKNOWN_6"] = 6;
    values[valuesById[7] = "CONFIGURATION_BIT_TYPE_UNKNOWN_7"] = 7;
    values[valuesById[8] = "CONFIGURATION_BIT_TYPE_UNKNOWN_8"] = 8;
    values[valuesById[9] = "CONFIGURATION_BIT_TYPE_UNKNOWN_9"] = 9;
    values[valuesById[10] = "CONFIGURATION_BIT_TYPE_UNKNOWN_10"] = 10;
    values[valuesById[11] = "CONFIGURATION_BIT_TYPE_UNKNOWN_11"] = 11;
    values[valuesById[12] = "CONFIGURATION_BIT_TYPE_UNKNOWN_12"] = 12;
    values[valuesById[13] = "CONFIGURATION_BIT_TYPE_UNKNOWN_13"] = 13;
    values[valuesById[14] = "CONFIGURATION_BIT_TYPE_UNKNOWN_14"] = 14;
    values[valuesById[15] = "CONFIGURATION_BIT_TYPE_UNKNOWN_15"] = 15;
    values[valuesById[16] = "CONFIGURATION_BIT_TYPE_UNKNOWN_16"] = 16;
    values[valuesById[17] = "CONFIGURATION_BIT_TYPE_UNKNOWN_17"] = 17;
    values[valuesById[18] = "CONFIGURATION_BIT_TYPE_UNKNOWN_18"] = 18;
    values[valuesById[19] = "CONFIGURATION_BIT_TYPE_UNKNOWN_19"] = 19;
    values[valuesById[20] = "CONFIGURATION_BIT_TYPE_UNKNOWN_20"] = 20;
    values[valuesById[21] = "CONFIGURATION_BIT_TYPE_UNKNOWN_21"] = 21;
    values[valuesById[22] = "CONFIGURATION_BIT_TYPE_UNKNOWN_22"] = 22;
    values[valuesById[23] = "CONFIGURATION_BIT_TYPE_UNKNOWN_23"] = 23;
    values[valuesById[24] = "CONFIGURATION_BIT_TYPE_UNKNOWN_24"] = 24;
    values[valuesById[25] = "CONFIGURATION_BIT_TYPE_UNKNOWN_25"] = 25;
    values[valuesById[26] = "CONFIGURATION_BIT_TYPE_UNKNOWN_26"] = 26;
    values[valuesById[27] = "CONFIGURATION_BIT_TYPE_UNKNOWN_27"] = 27;
    values[valuesById[28] = "CONFIGURATION_BIT_TYPE_UNKNOWN_28"] = 28;
    values[valuesById[29] = "CONFIGURATION_BIT_TYPE_UNKNOWN_29"] = 29;
    values[valuesById[30] = "CONFIGURATION_BIT_TYPE_UNKNOWN_30"] = 30;
    values[valuesById[31] = "CONFIGURATION_BIT_TYPE_UNKNOWN_31"] = 31;
    values[valuesById[32] = "CONFIGURATION_BIT_TYPE_UNKNOWN_32"] = 32;
    values[valuesById[33] = "CONFIGURATION_BIT_TYPE_UNKNOWN_33"] = 33;
    values[valuesById[34] = "CONFIGURATION_BIT_TYPE_DESKTOP_AUTO_EMOJI_CONVERSION_ENABLED"] = 34;
    values[valuesById[35] = "CONFIGURATION_BIT_TYPE_UNKNOWN_35"] = 35;
    values[valuesById[36] = "CONFIGURATION_BIT_TYPE_UNKNOWN_36"] = 36;
    values[valuesById[38] = "CONFIGURATION_BIT_TYPE_DESKTOP_COMPACT_MODE_ENABLED"] = 38;
    return values;
})();

export const ConfigurationBit = $root.ConfigurationBit = (() => {

    /**
     * Properties of a ConfigurationBit.
     * @exports IConfigurationBit
     * @interface IConfigurationBit
     * @property {ConfigurationBitType|null} [configurationBitType] ConfigurationBit configurationBitType
     * @property {boolean|null} [value] ConfigurationBit value
     */

    /**
     * Constructs a new ConfigurationBit.
     * @exports ConfigurationBit
     * @classdesc Represents a ConfigurationBit.
     * @implements IConfigurationBit
     * @constructor
     * @param {IConfigurationBit=} [properties] Properties to set
     */
    function ConfigurationBit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConfigurationBit configurationBitType.
     * @member {ConfigurationBitType} configurationBitType
     * @memberof ConfigurationBit
     * @instance
     */
    ConfigurationBit.prototype.configurationBitType = 0;

    /**
     * ConfigurationBit value.
     * @member {boolean} value
     * @memberof ConfigurationBit
     * @instance
     */
    ConfigurationBit.prototype.value = false;

    /**
     * Creates a new ConfigurationBit instance using the specified properties.
     * @function create
     * @memberof ConfigurationBit
     * @static
     * @param {IConfigurationBit=} [properties] Properties to set
     * @returns {ConfigurationBit} ConfigurationBit instance
     */
    ConfigurationBit.create = function create(properties) {
        return new ConfigurationBit(properties);
    };

    /**
     * Encodes the specified ConfigurationBit message. Does not implicitly {@link ConfigurationBit.verify|verify} messages.
     * @function encode
     * @memberof ConfigurationBit
     * @static
     * @param {IConfigurationBit} message ConfigurationBit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConfigurationBit.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.configurationBitType != null && message.hasOwnProperty("configurationBitType"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.configurationBitType);
        if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
        return writer;
    };

    /**
     * Encodes the specified ConfigurationBit message, length delimited. Does not implicitly {@link ConfigurationBit.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConfigurationBit
     * @static
     * @param {IConfigurationBit} message ConfigurationBit message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConfigurationBit.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConfigurationBit message from the specified reader or buffer.
     * @function decode
     * @memberof ConfigurationBit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConfigurationBit} ConfigurationBit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConfigurationBit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConfigurationBit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.configurationBitType = reader.int32();
                break;
            case 2:
                message.value = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConfigurationBit message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConfigurationBit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConfigurationBit} ConfigurationBit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConfigurationBit.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConfigurationBit message.
     * @function verify
     * @memberof ConfigurationBit
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConfigurationBit.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.configurationBitType != null && message.hasOwnProperty("configurationBitType"))
            switch (message.configurationBitType) {
            default:
                return "configurationBitType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 38:
                break;
            }
        if (message.value != null && message.hasOwnProperty("value"))
            if (typeof message.value !== "boolean")
                return "value: boolean expected";
        return null;
    };

    /**
     * Creates a ConfigurationBit message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConfigurationBit
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConfigurationBit} ConfigurationBit
     */
    ConfigurationBit.fromObject = function fromObject(object) {
        if (object instanceof $root.ConfigurationBit)
            return object;
        let message = new $root.ConfigurationBit();
        switch (object.configurationBitType) {
        case "CONFIGURATION_BIT_TYPE_UNKNOWN":
        case 0:
            message.configurationBitType = 0;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_1":
        case 1:
            message.configurationBitType = 1;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_2":
        case 2:
            message.configurationBitType = 2;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_3":
        case 3:
            message.configurationBitType = 3;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_4":
        case 4:
            message.configurationBitType = 4;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_5":
        case 5:
            message.configurationBitType = 5;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_6":
        case 6:
            message.configurationBitType = 6;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_7":
        case 7:
            message.configurationBitType = 7;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_8":
        case 8:
            message.configurationBitType = 8;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_9":
        case 9:
            message.configurationBitType = 9;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_10":
        case 10:
            message.configurationBitType = 10;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_11":
        case 11:
            message.configurationBitType = 11;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_12":
        case 12:
            message.configurationBitType = 12;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_13":
        case 13:
            message.configurationBitType = 13;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_14":
        case 14:
            message.configurationBitType = 14;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_15":
        case 15:
            message.configurationBitType = 15;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_16":
        case 16:
            message.configurationBitType = 16;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_17":
        case 17:
            message.configurationBitType = 17;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_18":
        case 18:
            message.configurationBitType = 18;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_19":
        case 19:
            message.configurationBitType = 19;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_20":
        case 20:
            message.configurationBitType = 20;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_21":
        case 21:
            message.configurationBitType = 21;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_22":
        case 22:
            message.configurationBitType = 22;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_23":
        case 23:
            message.configurationBitType = 23;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_24":
        case 24:
            message.configurationBitType = 24;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_25":
        case 25:
            message.configurationBitType = 25;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_26":
        case 26:
            message.configurationBitType = 26;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_27":
        case 27:
            message.configurationBitType = 27;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_28":
        case 28:
            message.configurationBitType = 28;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_29":
        case 29:
            message.configurationBitType = 29;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_30":
        case 30:
            message.configurationBitType = 30;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_31":
        case 31:
            message.configurationBitType = 31;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_32":
        case 32:
            message.configurationBitType = 32;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_33":
        case 33:
            message.configurationBitType = 33;
            break;
        case "CONFIGURATION_BIT_TYPE_DESKTOP_AUTO_EMOJI_CONVERSION_ENABLED":
        case 34:
            message.configurationBitType = 34;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_35":
        case 35:
            message.configurationBitType = 35;
            break;
        case "CONFIGURATION_BIT_TYPE_UNKNOWN_36":
        case 36:
            message.configurationBitType = 36;
            break;
        case "CONFIGURATION_BIT_TYPE_DESKTOP_COMPACT_MODE_ENABLED":
        case 38:
            message.configurationBitType = 38;
            break;
        }
        if (object.value != null)
            message.value = Boolean(object.value);
        return message;
    };

    /**
     * Creates a plain object from a ConfigurationBit message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConfigurationBit
     * @static
     * @param {ConfigurationBit} message ConfigurationBit
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConfigurationBit.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.configurationBitType = options.enums === String ? "CONFIGURATION_BIT_TYPE_UNKNOWN" : 0;
            object.value = false;
        }
        if (message.configurationBitType != null && message.hasOwnProperty("configurationBitType"))
            object.configurationBitType = options.enums === String ? $root.ConfigurationBitType[message.configurationBitType] : message.configurationBitType;
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
        return object;
    };

    /**
     * Converts this ConfigurationBit to JSON.
     * @function toJSON
     * @memberof ConfigurationBit
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConfigurationBit.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConfigurationBit;
})();

/**
 * RichPresenceType enum.
 * @exports RichPresenceType
 * @enum {string}
 * @property {number} RICH_PRESENCE_TYPE_UNKNOWN=0 RICH_PRESENCE_TYPE_UNKNOWN value
 * @property {number} RICH_PRESENCE_TYPE_IN_CALL_STATE=1 RICH_PRESENCE_TYPE_IN_CALL_STATE value
 * @property {number} RICH_PRESENCE_TYPE_UNKNOWN_3=3 RICH_PRESENCE_TYPE_UNKNOWN_3 value
 * @property {number} RICH_PRESENCE_TYPE_UNKNOWN_4=4 RICH_PRESENCE_TYPE_UNKNOWN_4 value
 * @property {number} RICH_PRESENCE_TYPE_UNKNOWN_5=5 RICH_PRESENCE_TYPE_UNKNOWN_5 value
 * @property {number} RICH_PRESENCE_TYPE_DEVICE=2 RICH_PRESENCE_TYPE_DEVICE value
 * @property {number} RICH_PRESENCE_TYPE_LAST_SEEN=6 RICH_PRESENCE_TYPE_LAST_SEEN value
 */
$root.RichPresenceType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "RICH_PRESENCE_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "RICH_PRESENCE_TYPE_IN_CALL_STATE"] = 1;
    values[valuesById[3] = "RICH_PRESENCE_TYPE_UNKNOWN_3"] = 3;
    values[valuesById[4] = "RICH_PRESENCE_TYPE_UNKNOWN_4"] = 4;
    values[valuesById[5] = "RICH_PRESENCE_TYPE_UNKNOWN_5"] = 5;
    values[valuesById[2] = "RICH_PRESENCE_TYPE_DEVICE"] = 2;
    values[valuesById[6] = "RICH_PRESENCE_TYPE_LAST_SEEN"] = 6;
    return values;
})();

export const RichPresenceState = $root.RichPresenceState = (() => {

    /**
     * Properties of a RichPresenceState.
     * @exports IRichPresenceState
     * @interface IRichPresenceState
     * @property {Array.<IRichPresenceEnabledState>|null} [getRichPresenceEnabledState] RichPresenceState getRichPresenceEnabledState
     */

    /**
     * Constructs a new RichPresenceState.
     * @exports RichPresenceState
     * @classdesc Represents a RichPresenceState.
     * @implements IRichPresenceState
     * @constructor
     * @param {IRichPresenceState=} [properties] Properties to set
     */
    function RichPresenceState(properties) {
        this.getRichPresenceEnabledState = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RichPresenceState getRichPresenceEnabledState.
     * @member {Array.<IRichPresenceEnabledState>} getRichPresenceEnabledState
     * @memberof RichPresenceState
     * @instance
     */
    RichPresenceState.prototype.getRichPresenceEnabledState = $util.emptyArray;

    /**
     * Creates a new RichPresenceState instance using the specified properties.
     * @function create
     * @memberof RichPresenceState
     * @static
     * @param {IRichPresenceState=} [properties] Properties to set
     * @returns {RichPresenceState} RichPresenceState instance
     */
    RichPresenceState.create = function create(properties) {
        return new RichPresenceState(properties);
    };

    /**
     * Encodes the specified RichPresenceState message. Does not implicitly {@link RichPresenceState.verify|verify} messages.
     * @function encode
     * @memberof RichPresenceState
     * @static
     * @param {IRichPresenceState} message RichPresenceState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.getRichPresenceEnabledState != null && message.getRichPresenceEnabledState.length)
            for (let i = 0; i < message.getRichPresenceEnabledState.length; ++i)
                $root.RichPresenceEnabledState.encode(message.getRichPresenceEnabledState[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RichPresenceState message, length delimited. Does not implicitly {@link RichPresenceState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RichPresenceState
     * @static
     * @param {IRichPresenceState} message RichPresenceState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RichPresenceState message from the specified reader or buffer.
     * @function decode
     * @memberof RichPresenceState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RichPresenceState} RichPresenceState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RichPresenceState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 3:
                if (!(message.getRichPresenceEnabledState && message.getRichPresenceEnabledState.length))
                    message.getRichPresenceEnabledState = [];
                message.getRichPresenceEnabledState.push($root.RichPresenceEnabledState.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RichPresenceState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RichPresenceState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RichPresenceState} RichPresenceState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RichPresenceState message.
     * @function verify
     * @memberof RichPresenceState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RichPresenceState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.getRichPresenceEnabledState != null && message.hasOwnProperty("getRichPresenceEnabledState")) {
            if (!Array.isArray(message.getRichPresenceEnabledState))
                return "getRichPresenceEnabledState: array expected";
            for (let i = 0; i < message.getRichPresenceEnabledState.length; ++i) {
                let error = $root.RichPresenceEnabledState.verify(message.getRichPresenceEnabledState[i]);
                if (error)
                    return "getRichPresenceEnabledState." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RichPresenceState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RichPresenceState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RichPresenceState} RichPresenceState
     */
    RichPresenceState.fromObject = function fromObject(object) {
        if (object instanceof $root.RichPresenceState)
            return object;
        let message = new $root.RichPresenceState();
        if (object.getRichPresenceEnabledState) {
            if (!Array.isArray(object.getRichPresenceEnabledState))
                throw TypeError(".RichPresenceState.getRichPresenceEnabledState: array expected");
            message.getRichPresenceEnabledState = [];
            for (let i = 0; i < object.getRichPresenceEnabledState.length; ++i) {
                if (typeof object.getRichPresenceEnabledState[i] !== "object")
                    throw TypeError(".RichPresenceState.getRichPresenceEnabledState: object expected");
                message.getRichPresenceEnabledState[i] = $root.RichPresenceEnabledState.fromObject(object.getRichPresenceEnabledState[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RichPresenceState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RichPresenceState
     * @static
     * @param {RichPresenceState} message RichPresenceState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RichPresenceState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.getRichPresenceEnabledState = [];
        if (message.getRichPresenceEnabledState && message.getRichPresenceEnabledState.length) {
            object.getRichPresenceEnabledState = [];
            for (let j = 0; j < message.getRichPresenceEnabledState.length; ++j)
                object.getRichPresenceEnabledState[j] = $root.RichPresenceEnabledState.toObject(message.getRichPresenceEnabledState[j], options);
        }
        return object;
    };

    /**
     * Converts this RichPresenceState to JSON.
     * @function toJSON
     * @memberof RichPresenceState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RichPresenceState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RichPresenceState;
})();

export const RichPresenceEnabledState = $root.RichPresenceEnabledState = (() => {

    /**
     * Properties of a RichPresenceEnabledState.
     * @exports IRichPresenceEnabledState
     * @interface IRichPresenceEnabledState
     * @property {RichPresenceType|null} [type] RichPresenceEnabledState type
     * @property {boolean|null} [enabled] RichPresenceEnabledState enabled
     */

    /**
     * Constructs a new RichPresenceEnabledState.
     * @exports RichPresenceEnabledState
     * @classdesc Represents a RichPresenceEnabledState.
     * @implements IRichPresenceEnabledState
     * @constructor
     * @param {IRichPresenceEnabledState=} [properties] Properties to set
     */
    function RichPresenceEnabledState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RichPresenceEnabledState type.
     * @member {RichPresenceType} type
     * @memberof RichPresenceEnabledState
     * @instance
     */
    RichPresenceEnabledState.prototype.type = 0;

    /**
     * RichPresenceEnabledState enabled.
     * @member {boolean} enabled
     * @memberof RichPresenceEnabledState
     * @instance
     */
    RichPresenceEnabledState.prototype.enabled = false;

    /**
     * Creates a new RichPresenceEnabledState instance using the specified properties.
     * @function create
     * @memberof RichPresenceEnabledState
     * @static
     * @param {IRichPresenceEnabledState=} [properties] Properties to set
     * @returns {RichPresenceEnabledState} RichPresenceEnabledState instance
     */
    RichPresenceEnabledState.create = function create(properties) {
        return new RichPresenceEnabledState(properties);
    };

    /**
     * Encodes the specified RichPresenceEnabledState message. Does not implicitly {@link RichPresenceEnabledState.verify|verify} messages.
     * @function encode
     * @memberof RichPresenceEnabledState
     * @static
     * @param {IRichPresenceEnabledState} message RichPresenceEnabledState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceEnabledState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.enabled != null && message.hasOwnProperty("enabled"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);
        return writer;
    };

    /**
     * Encodes the specified RichPresenceEnabledState message, length delimited. Does not implicitly {@link RichPresenceEnabledState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RichPresenceEnabledState
     * @static
     * @param {IRichPresenceEnabledState} message RichPresenceEnabledState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceEnabledState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RichPresenceEnabledState message from the specified reader or buffer.
     * @function decode
     * @memberof RichPresenceEnabledState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RichPresenceEnabledState} RichPresenceEnabledState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceEnabledState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RichPresenceEnabledState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 2:
                message.enabled = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RichPresenceEnabledState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RichPresenceEnabledState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RichPresenceEnabledState} RichPresenceEnabledState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceEnabledState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RichPresenceEnabledState message.
     * @function verify
     * @memberof RichPresenceEnabledState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RichPresenceEnabledState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 3:
            case 4:
            case 5:
            case 2:
            case 6:
                break;
            }
        if (message.enabled != null && message.hasOwnProperty("enabled"))
            if (typeof message.enabled !== "boolean")
                return "enabled: boolean expected";
        return null;
    };

    /**
     * Creates a RichPresenceEnabledState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RichPresenceEnabledState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RichPresenceEnabledState} RichPresenceEnabledState
     */
    RichPresenceEnabledState.fromObject = function fromObject(object) {
        if (object instanceof $root.RichPresenceEnabledState)
            return object;
        let message = new $root.RichPresenceEnabledState();
        switch (object.type) {
        case "RICH_PRESENCE_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "RICH_PRESENCE_TYPE_IN_CALL_STATE":
        case 1:
            message.type = 1;
            break;
        case "RICH_PRESENCE_TYPE_UNKNOWN_3":
        case 3:
            message.type = 3;
            break;
        case "RICH_PRESENCE_TYPE_UNKNOWN_4":
        case 4:
            message.type = 4;
            break;
        case "RICH_PRESENCE_TYPE_UNKNOWN_5":
        case 5:
            message.type = 5;
            break;
        case "RICH_PRESENCE_TYPE_DEVICE":
        case 2:
            message.type = 2;
            break;
        case "RICH_PRESENCE_TYPE_LAST_SEEN":
        case 6:
            message.type = 6;
            break;
        }
        if (object.enabled != null)
            message.enabled = Boolean(object.enabled);
        return message;
    };

    /**
     * Creates a plain object from a RichPresenceEnabledState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RichPresenceEnabledState
     * @static
     * @param {RichPresenceEnabledState} message RichPresenceEnabledState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RichPresenceEnabledState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "RICH_PRESENCE_TYPE_UNKNOWN" : 0;
            object.enabled = false;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.RichPresenceType[message.type] : message.type;
        if (message.enabled != null && message.hasOwnProperty("enabled"))
            object.enabled = message.enabled;
        return object;
    };

    /**
     * Converts this RichPresenceEnabledState to JSON.
     * @function toJSON
     * @memberof RichPresenceEnabledState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RichPresenceEnabledState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RichPresenceEnabledState;
})();

/**
 * FieldMask enum.
 * @exports FieldMask
 * @enum {string}
 * @property {number} FIELD_MASK_REACHABLE=1 FIELD_MASK_REACHABLE value
 * @property {number} FIELD_MASK_AVAILABLE=2 FIELD_MASK_AVAILABLE value
 * @property {number} FIELD_MASK_MOOD=3 FIELD_MASK_MOOD value
 * @property {number} FIELD_MASK_IN_CALL=6 FIELD_MASK_IN_CALL value
 * @property {number} FIELD_MASK_DEVICE=7 FIELD_MASK_DEVICE value
 * @property {number} FIELD_MASK_LAST_SEEN=10 FIELD_MASK_LAST_SEEN value
 */
$root.FieldMask = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "FIELD_MASK_REACHABLE"] = 1;
    values[valuesById[2] = "FIELD_MASK_AVAILABLE"] = 2;
    values[valuesById[3] = "FIELD_MASK_MOOD"] = 3;
    values[valuesById[6] = "FIELD_MASK_IN_CALL"] = 6;
    values[valuesById[7] = "FIELD_MASK_DEVICE"] = 7;
    values[valuesById[10] = "FIELD_MASK_LAST_SEEN"] = 10;
    return values;
})();

export const DesktopOffSetting = $root.DesktopOffSetting = (() => {

    /**
     * Properties of a DesktopOffSetting.
     * @exports IDesktopOffSetting
     * @interface IDesktopOffSetting
     * @property {boolean|null} [desktopOff] DesktopOffSetting desktopOff
     */

    /**
     * Constructs a new DesktopOffSetting.
     * @exports DesktopOffSetting
     * @classdesc Represents a DesktopOffSetting.
     * @implements IDesktopOffSetting
     * @constructor
     * @param {IDesktopOffSetting=} [properties] Properties to set
     */
    function DesktopOffSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DesktopOffSetting desktopOff.
     * @member {boolean} desktopOff
     * @memberof DesktopOffSetting
     * @instance
     */
    DesktopOffSetting.prototype.desktopOff = false;

    /**
     * Creates a new DesktopOffSetting instance using the specified properties.
     * @function create
     * @memberof DesktopOffSetting
     * @static
     * @param {IDesktopOffSetting=} [properties] Properties to set
     * @returns {DesktopOffSetting} DesktopOffSetting instance
     */
    DesktopOffSetting.create = function create(properties) {
        return new DesktopOffSetting(properties);
    };

    /**
     * Encodes the specified DesktopOffSetting message. Does not implicitly {@link DesktopOffSetting.verify|verify} messages.
     * @function encode
     * @memberof DesktopOffSetting
     * @static
     * @param {IDesktopOffSetting} message DesktopOffSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopOffSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.desktopOff);
        return writer;
    };

    /**
     * Encodes the specified DesktopOffSetting message, length delimited. Does not implicitly {@link DesktopOffSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DesktopOffSetting
     * @static
     * @param {IDesktopOffSetting} message DesktopOffSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopOffSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DesktopOffSetting message from the specified reader or buffer.
     * @function decode
     * @memberof DesktopOffSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DesktopOffSetting} DesktopOffSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopOffSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DesktopOffSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.desktopOff = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DesktopOffSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DesktopOffSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DesktopOffSetting} DesktopOffSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopOffSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DesktopOffSetting message.
     * @function verify
     * @memberof DesktopOffSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DesktopOffSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            if (typeof message.desktopOff !== "boolean")
                return "desktopOff: boolean expected";
        return null;
    };

    /**
     * Creates a DesktopOffSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DesktopOffSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DesktopOffSetting} DesktopOffSetting
     */
    DesktopOffSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.DesktopOffSetting)
            return object;
        let message = new $root.DesktopOffSetting();
        if (object.desktopOff != null)
            message.desktopOff = Boolean(object.desktopOff);
        return message;
    };

    /**
     * Creates a plain object from a DesktopOffSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DesktopOffSetting
     * @static
     * @param {DesktopOffSetting} message DesktopOffSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DesktopOffSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.desktopOff = false;
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            object.desktopOff = message.desktopOff;
        return object;
    };

    /**
     * Converts this DesktopOffSetting to JSON.
     * @function toJSON
     * @memberof DesktopOffSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DesktopOffSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DesktopOffSetting;
})();

export const DesktopOffState = $root.DesktopOffState = (() => {

    /**
     * Properties of a DesktopOffState.
     * @exports IDesktopOffState
     * @interface IDesktopOffState
     * @property {boolean|null} [desktopOff] DesktopOffState desktopOff
     * @property {number|Long|null} [version] DesktopOffState version
     */

    /**
     * Constructs a new DesktopOffState.
     * @exports DesktopOffState
     * @classdesc Represents a DesktopOffState.
     * @implements IDesktopOffState
     * @constructor
     * @param {IDesktopOffState=} [properties] Properties to set
     */
    function DesktopOffState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DesktopOffState desktopOff.
     * @member {boolean} desktopOff
     * @memberof DesktopOffState
     * @instance
     */
    DesktopOffState.prototype.desktopOff = false;

    /**
     * DesktopOffState version.
     * @member {number|Long} version
     * @memberof DesktopOffState
     * @instance
     */
    DesktopOffState.prototype.version = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DesktopOffState instance using the specified properties.
     * @function create
     * @memberof DesktopOffState
     * @static
     * @param {IDesktopOffState=} [properties] Properties to set
     * @returns {DesktopOffState} DesktopOffState instance
     */
    DesktopOffState.create = function create(properties) {
        return new DesktopOffState(properties);
    };

    /**
     * Encodes the specified DesktopOffState message. Does not implicitly {@link DesktopOffState.verify|verify} messages.
     * @function encode
     * @memberof DesktopOffState
     * @static
     * @param {IDesktopOffState} message DesktopOffState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopOffState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.desktopOff);
        if (message.version != null && message.hasOwnProperty("version"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.version);
        return writer;
    };

    /**
     * Encodes the specified DesktopOffState message, length delimited. Does not implicitly {@link DesktopOffState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DesktopOffState
     * @static
     * @param {IDesktopOffState} message DesktopOffState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopOffState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DesktopOffState message from the specified reader or buffer.
     * @function decode
     * @memberof DesktopOffState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DesktopOffState} DesktopOffState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopOffState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DesktopOffState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.desktopOff = reader.bool();
                break;
            case 2:
                message.version = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DesktopOffState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DesktopOffState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DesktopOffState} DesktopOffState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopOffState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DesktopOffState message.
     * @function verify
     * @memberof DesktopOffState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DesktopOffState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            if (typeof message.desktopOff !== "boolean")
                return "desktopOff: boolean expected";
        if (message.version != null && message.hasOwnProperty("version"))
            if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                return "version: integer|Long expected";
        return null;
    };

    /**
     * Creates a DesktopOffState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DesktopOffState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DesktopOffState} DesktopOffState
     */
    DesktopOffState.fromObject = function fromObject(object) {
        if (object instanceof $root.DesktopOffState)
            return object;
        let message = new $root.DesktopOffState();
        if (object.desktopOff != null)
            message.desktopOff = Boolean(object.desktopOff);
        if (object.version != null)
            if ($util.Long)
                (message.version = $util.Long.fromValue(object.version)).unsigned = true;
            else if (typeof object.version === "string")
                message.version = parseInt(object.version, 10);
            else if (typeof object.version === "number")
                message.version = object.version;
            else if (typeof object.version === "object")
                message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DesktopOffState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DesktopOffState
     * @static
     * @param {DesktopOffState} message DesktopOffState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DesktopOffState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.desktopOff = false;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.version = options.longs === String ? "0" : 0;
        }
        if (message.desktopOff != null && message.hasOwnProperty("desktopOff"))
            object.desktopOff = message.desktopOff;
        if (message.version != null && message.hasOwnProperty("version"))
            if (typeof message.version === "number")
                object.version = options.longs === String ? String(message.version) : message.version;
            else
                object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber(true) : message.version;
        return object;
    };

    /**
     * Converts this DesktopOffState to JSON.
     * @function toJSON
     * @memberof DesktopOffState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DesktopOffState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DesktopOffState;
})();

export const DndSetting = $root.DndSetting = (() => {

    /**
     * Properties of a DndSetting.
     * @exports IDndSetting
     * @interface IDndSetting
     * @property {boolean|null} [doNotDisturb] DndSetting doNotDisturb
     * @property {number|Long|null} [timeoutSecs] DndSetting timeoutSecs
     */

    /**
     * Constructs a new DndSetting.
     * @exports DndSetting
     * @classdesc Represents a DndSetting.
     * @implements IDndSetting
     * @constructor
     * @param {IDndSetting=} [properties] Properties to set
     */
    function DndSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DndSetting doNotDisturb.
     * @member {boolean} doNotDisturb
     * @memberof DndSetting
     * @instance
     */
    DndSetting.prototype.doNotDisturb = false;

    /**
     * DndSetting timeoutSecs.
     * @member {number|Long} timeoutSecs
     * @memberof DndSetting
     * @instance
     */
    DndSetting.prototype.timeoutSecs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DndSetting instance using the specified properties.
     * @function create
     * @memberof DndSetting
     * @static
     * @param {IDndSetting=} [properties] Properties to set
     * @returns {DndSetting} DndSetting instance
     */
    DndSetting.create = function create(properties) {
        return new DndSetting(properties);
    };

    /**
     * Encodes the specified DndSetting message. Does not implicitly {@link DndSetting.verify|verify} messages.
     * @function encode
     * @memberof DndSetting
     * @static
     * @param {IDndSetting} message DndSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DndSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.doNotDisturb);
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timeoutSecs);
        return writer;
    };

    /**
     * Encodes the specified DndSetting message, length delimited. Does not implicitly {@link DndSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DndSetting
     * @static
     * @param {IDndSetting} message DndSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DndSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DndSetting message from the specified reader or buffer.
     * @function decode
     * @memberof DndSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DndSetting} DndSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DndSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DndSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.doNotDisturb = reader.bool();
                break;
            case 2:
                message.timeoutSecs = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DndSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DndSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DndSetting} DndSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DndSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DndSetting message.
     * @function verify
     * @memberof DndSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DndSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            if (typeof message.doNotDisturb !== "boolean")
                return "doNotDisturb: boolean expected";
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (!$util.isInteger(message.timeoutSecs) && !(message.timeoutSecs && $util.isInteger(message.timeoutSecs.low) && $util.isInteger(message.timeoutSecs.high)))
                return "timeoutSecs: integer|Long expected";
        return null;
    };

    /**
     * Creates a DndSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DndSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DndSetting} DndSetting
     */
    DndSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.DndSetting)
            return object;
        let message = new $root.DndSetting();
        if (object.doNotDisturb != null)
            message.doNotDisturb = Boolean(object.doNotDisturb);
        if (object.timeoutSecs != null)
            if ($util.Long)
                (message.timeoutSecs = $util.Long.fromValue(object.timeoutSecs)).unsigned = true;
            else if (typeof object.timeoutSecs === "string")
                message.timeoutSecs = parseInt(object.timeoutSecs, 10);
            else if (typeof object.timeoutSecs === "number")
                message.timeoutSecs = object.timeoutSecs;
            else if (typeof object.timeoutSecs === "object")
                message.timeoutSecs = new $util.LongBits(object.timeoutSecs.low >>> 0, object.timeoutSecs.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DndSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DndSetting
     * @static
     * @param {DndSetting} message DndSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DndSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.doNotDisturb = false;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timeoutSecs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timeoutSecs = options.longs === String ? "0" : 0;
        }
        if (message.doNotDisturb != null && message.hasOwnProperty("doNotDisturb"))
            object.doNotDisturb = message.doNotDisturb;
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (typeof message.timeoutSecs === "number")
                object.timeoutSecs = options.longs === String ? String(message.timeoutSecs) : message.timeoutSecs;
            else
                object.timeoutSecs = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutSecs) : options.longs === Number ? new $util.LongBits(message.timeoutSecs.low >>> 0, message.timeoutSecs.high >>> 0).toNumber(true) : message.timeoutSecs;
        return object;
    };

    /**
     * Converts this DndSetting to JSON.
     * @function toJSON
     * @memberof DndSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DndSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DndSetting;
})();

export const PresenceStateSetting = $root.PresenceStateSetting = (() => {

    /**
     * Properties of a PresenceStateSetting.
     * @exports IPresenceStateSetting
     * @interface IPresenceStateSetting
     * @property {number|Long|null} [timeoutSecs] PresenceStateSetting timeoutSecs
     * @property {ClientPresenceStateType|null} [type] PresenceStateSetting type
     */

    /**
     * Constructs a new PresenceStateSetting.
     * @exports PresenceStateSetting
     * @classdesc Represents a PresenceStateSetting.
     * @implements IPresenceStateSetting
     * @constructor
     * @param {IPresenceStateSetting=} [properties] Properties to set
     */
    function PresenceStateSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PresenceStateSetting timeoutSecs.
     * @member {number|Long} timeoutSecs
     * @memberof PresenceStateSetting
     * @instance
     */
    PresenceStateSetting.prototype.timeoutSecs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * PresenceStateSetting type.
     * @member {ClientPresenceStateType} type
     * @memberof PresenceStateSetting
     * @instance
     */
    PresenceStateSetting.prototype.type = 0;

    /**
     * Creates a new PresenceStateSetting instance using the specified properties.
     * @function create
     * @memberof PresenceStateSetting
     * @static
     * @param {IPresenceStateSetting=} [properties] Properties to set
     * @returns {PresenceStateSetting} PresenceStateSetting instance
     */
    PresenceStateSetting.create = function create(properties) {
        return new PresenceStateSetting(properties);
    };

    /**
     * Encodes the specified PresenceStateSetting message. Does not implicitly {@link PresenceStateSetting.verify|verify} messages.
     * @function encode
     * @memberof PresenceStateSetting
     * @static
     * @param {IPresenceStateSetting} message PresenceStateSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceStateSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timeoutSecs);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified PresenceStateSetting message, length delimited. Does not implicitly {@link PresenceStateSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PresenceStateSetting
     * @static
     * @param {IPresenceStateSetting} message PresenceStateSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceStateSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PresenceStateSetting message from the specified reader or buffer.
     * @function decode
     * @memberof PresenceStateSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PresenceStateSetting} PresenceStateSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceStateSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PresenceStateSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.timeoutSecs = reader.uint64();
                break;
            case 2:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PresenceStateSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PresenceStateSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PresenceStateSetting} PresenceStateSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceStateSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PresenceStateSetting message.
     * @function verify
     * @memberof PresenceStateSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PresenceStateSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (!$util.isInteger(message.timeoutSecs) && !(message.timeoutSecs && $util.isInteger(message.timeoutSecs.low) && $util.isInteger(message.timeoutSecs.high)))
                return "timeoutSecs: integer|Long expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 30:
            case 40:
                break;
            }
        return null;
    };

    /**
     * Creates a PresenceStateSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PresenceStateSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PresenceStateSetting} PresenceStateSetting
     */
    PresenceStateSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.PresenceStateSetting)
            return object;
        let message = new $root.PresenceStateSetting();
        if (object.timeoutSecs != null)
            if ($util.Long)
                (message.timeoutSecs = $util.Long.fromValue(object.timeoutSecs)).unsigned = true;
            else if (typeof object.timeoutSecs === "string")
                message.timeoutSecs = parseInt(object.timeoutSecs, 10);
            else if (typeof object.timeoutSecs === "number")
                message.timeoutSecs = object.timeoutSecs;
            else if (typeof object.timeoutSecs === "object")
                message.timeoutSecs = new $util.LongBits(object.timeoutSecs.low >>> 0, object.timeoutSecs.high >>> 0).toNumber(true);
        switch (object.type) {
        case "CLIENT_PRESENCE_STATE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "CLIENT_PRESENCE_STATE_NONE":
        case 1:
            message.type = 1;
            break;
        case "CLIENT_PRESENCE_STATE_DESKTOP_IDLE":
        case 30:
            message.type = 30;
            break;
        case "CLIENT_PRESENCE_STATE_DESKTOP_ACTIVE":
        case 40:
            message.type = 40;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a PresenceStateSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PresenceStateSetting
     * @static
     * @param {PresenceStateSetting} message PresenceStateSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PresenceStateSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timeoutSecs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timeoutSecs = options.longs === String ? "0" : 0;
            object.type = options.enums === String ? "CLIENT_PRESENCE_STATE_UNKNOWN" : 0;
        }
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (typeof message.timeoutSecs === "number")
                object.timeoutSecs = options.longs === String ? String(message.timeoutSecs) : message.timeoutSecs;
            else
                object.timeoutSecs = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutSecs) : options.longs === Number ? new $util.LongBits(message.timeoutSecs.low >>> 0, message.timeoutSecs.high >>> 0).toNumber(true) : message.timeoutSecs;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.ClientPresenceStateType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this PresenceStateSetting to JSON.
     * @function toJSON
     * @memberof PresenceStateSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PresenceStateSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PresenceStateSetting;
})();

export const MoodMessage = $root.MoodMessage = (() => {

    /**
     * Properties of a MoodMessage.
     * @exports IMoodMessage
     * @interface IMoodMessage
     * @property {IMoodContent|null} [moodContent] MoodMessage moodContent
     */

    /**
     * Constructs a new MoodMessage.
     * @exports MoodMessage
     * @classdesc Represents a MoodMessage.
     * @implements IMoodMessage
     * @constructor
     * @param {IMoodMessage=} [properties] Properties to set
     */
    function MoodMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoodMessage moodContent.
     * @member {IMoodContent|null|undefined} moodContent
     * @memberof MoodMessage
     * @instance
     */
    MoodMessage.prototype.moodContent = null;

    /**
     * Creates a new MoodMessage instance using the specified properties.
     * @function create
     * @memberof MoodMessage
     * @static
     * @param {IMoodMessage=} [properties] Properties to set
     * @returns {MoodMessage} MoodMessage instance
     */
    MoodMessage.create = function create(properties) {
        return new MoodMessage(properties);
    };

    /**
     * Encodes the specified MoodMessage message. Does not implicitly {@link MoodMessage.verify|verify} messages.
     * @function encode
     * @memberof MoodMessage
     * @static
     * @param {IMoodMessage} message MoodMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.moodContent != null && message.hasOwnProperty("moodContent"))
            $root.MoodContent.encode(message.moodContent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MoodMessage message, length delimited. Does not implicitly {@link MoodMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoodMessage
     * @static
     * @param {IMoodMessage} message MoodMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoodMessage message from the specified reader or buffer.
     * @function decode
     * @memberof MoodMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoodMessage} MoodMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoodMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.moodContent = $root.MoodContent.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MoodMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoodMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoodMessage} MoodMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoodMessage message.
     * @function verify
     * @memberof MoodMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoodMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.moodContent != null && message.hasOwnProperty("moodContent")) {
            let error = $root.MoodContent.verify(message.moodContent);
            if (error)
                return "moodContent." + error;
        }
        return null;
    };

    /**
     * Creates a MoodMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoodMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoodMessage} MoodMessage
     */
    MoodMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.MoodMessage)
            return object;
        let message = new $root.MoodMessage();
        if (object.moodContent != null) {
            if (typeof object.moodContent !== "object")
                throw TypeError(".MoodMessage.moodContent: object expected");
            message.moodContent = $root.MoodContent.fromObject(object.moodContent);
        }
        return message;
    };

    /**
     * Creates a plain object from a MoodMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoodMessage
     * @static
     * @param {MoodMessage} message MoodMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoodMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.moodContent = null;
        if (message.moodContent != null && message.hasOwnProperty("moodContent"))
            object.moodContent = $root.MoodContent.toObject(message.moodContent, options);
        return object;
    };

    /**
     * Converts this MoodMessage to JSON.
     * @function toJSON
     * @memberof MoodMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoodMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MoodMessage;
})();

export const MoodContent = $root.MoodContent = (() => {

    /**
     * Properties of a MoodContent.
     * @exports IMoodContent
     * @interface IMoodContent
     * @property {Array.<ISegment>|null} [segment] MoodContent segment
     */

    /**
     * Constructs a new MoodContent.
     * @exports MoodContent
     * @classdesc Represents a MoodContent.
     * @implements IMoodContent
     * @constructor
     * @param {IMoodContent=} [properties] Properties to set
     */
    function MoodContent(properties) {
        this.segment = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoodContent segment.
     * @member {Array.<ISegment>} segment
     * @memberof MoodContent
     * @instance
     */
    MoodContent.prototype.segment = $util.emptyArray;

    /**
     * Creates a new MoodContent instance using the specified properties.
     * @function create
     * @memberof MoodContent
     * @static
     * @param {IMoodContent=} [properties] Properties to set
     * @returns {MoodContent} MoodContent instance
     */
    MoodContent.create = function create(properties) {
        return new MoodContent(properties);
    };

    /**
     * Encodes the specified MoodContent message. Does not implicitly {@link MoodContent.verify|verify} messages.
     * @function encode
     * @memberof MoodContent
     * @static
     * @param {IMoodContent} message MoodContent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodContent.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.segment != null && message.segment.length)
            for (let i = 0; i < message.segment.length; ++i)
                $root.Segment.encode(message.segment[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MoodContent message, length delimited. Does not implicitly {@link MoodContent.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoodContent
     * @static
     * @param {IMoodContent} message MoodContent message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodContent.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoodContent message from the specified reader or buffer.
     * @function decode
     * @memberof MoodContent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoodContent} MoodContent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodContent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoodContent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.segment && message.segment.length))
                    message.segment = [];
                message.segment.push($root.Segment.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MoodContent message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoodContent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoodContent} MoodContent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodContent.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoodContent message.
     * @function verify
     * @memberof MoodContent
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoodContent.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.segment != null && message.hasOwnProperty("segment")) {
            if (!Array.isArray(message.segment))
                return "segment: array expected";
            for (let i = 0; i < message.segment.length; ++i) {
                let error = $root.Segment.verify(message.segment[i]);
                if (error)
                    return "segment." + error;
            }
        }
        return null;
    };

    /**
     * Creates a MoodContent message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoodContent
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoodContent} MoodContent
     */
    MoodContent.fromObject = function fromObject(object) {
        if (object instanceof $root.MoodContent)
            return object;
        let message = new $root.MoodContent();
        if (object.segment) {
            if (!Array.isArray(object.segment))
                throw TypeError(".MoodContent.segment: array expected");
            message.segment = [];
            for (let i = 0; i < object.segment.length; ++i) {
                if (typeof object.segment[i] !== "object")
                    throw TypeError(".MoodContent.segment: object expected");
                message.segment[i] = $root.Segment.fromObject(object.segment[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a MoodContent message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoodContent
     * @static
     * @param {MoodContent} message MoodContent
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoodContent.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.segment = [];
        if (message.segment && message.segment.length) {
            object.segment = [];
            for (let j = 0; j < message.segment.length; ++j)
                object.segment[j] = $root.Segment.toObject(message.segment[j], options);
        }
        return object;
    };

    /**
     * Converts this MoodContent to JSON.
     * @function toJSON
     * @memberof MoodContent
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoodContent.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MoodContent;
})();

export const MoodSetting = $root.MoodSetting = (() => {

    /**
     * Properties of a MoodSetting.
     * @exports IMoodSetting
     * @interface IMoodSetting
     * @property {IMoodMessage|null} [moodMessage] MoodSetting moodMessage
     */

    /**
     * Constructs a new MoodSetting.
     * @exports MoodSetting
     * @classdesc Represents a MoodSetting.
     * @implements IMoodSetting
     * @constructor
     * @param {IMoodSetting=} [properties] Properties to set
     */
    function MoodSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoodSetting moodMessage.
     * @member {IMoodMessage|null|undefined} moodMessage
     * @memberof MoodSetting
     * @instance
     */
    MoodSetting.prototype.moodMessage = null;

    /**
     * Creates a new MoodSetting instance using the specified properties.
     * @function create
     * @memberof MoodSetting
     * @static
     * @param {IMoodSetting=} [properties] Properties to set
     * @returns {MoodSetting} MoodSetting instance
     */
    MoodSetting.create = function create(properties) {
        return new MoodSetting(properties);
    };

    /**
     * Encodes the specified MoodSetting message. Does not implicitly {@link MoodSetting.verify|verify} messages.
     * @function encode
     * @memberof MoodSetting
     * @static
     * @param {IMoodSetting} message MoodSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage"))
            $root.MoodMessage.encode(message.moodMessage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MoodSetting message, length delimited. Does not implicitly {@link MoodSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoodSetting
     * @static
     * @param {IMoodSetting} message MoodSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoodSetting message from the specified reader or buffer.
     * @function decode
     * @memberof MoodSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoodSetting} MoodSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoodSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.moodMessage = $root.MoodMessage.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MoodSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoodSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoodSetting} MoodSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoodSetting message.
     * @function verify
     * @memberof MoodSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoodSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage")) {
            let error = $root.MoodMessage.verify(message.moodMessage);
            if (error)
                return "moodMessage." + error;
        }
        return null;
    };

    /**
     * Creates a MoodSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoodSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoodSetting} MoodSetting
     */
    MoodSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.MoodSetting)
            return object;
        let message = new $root.MoodSetting();
        if (object.moodMessage != null) {
            if (typeof object.moodMessage !== "object")
                throw TypeError(".MoodSetting.moodMessage: object expected");
            message.moodMessage = $root.MoodMessage.fromObject(object.moodMessage);
        }
        return message;
    };

    /**
     * Creates a plain object from a MoodSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoodSetting
     * @static
     * @param {MoodSetting} message MoodSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoodSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.moodMessage = null;
        if (message.moodMessage != null && message.hasOwnProperty("moodMessage"))
            object.moodMessage = $root.MoodMessage.toObject(message.moodMessage, options);
        return object;
    };

    /**
     * Converts this MoodSetting to JSON.
     * @function toJSON
     * @memberof MoodSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoodSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MoodSetting;
})();

export const MoodState = $root.MoodState = (() => {

    /**
     * Properties of a MoodState.
     * @exports IMoodState
     * @interface IMoodState
     * @property {IMoodSetting|null} [moodSetting] MoodState moodSetting
     */

    /**
     * Constructs a new MoodState.
     * @exports MoodState
     * @classdesc Represents a MoodState.
     * @implements IMoodState
     * @constructor
     * @param {IMoodState=} [properties] Properties to set
     */
    function MoodState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoodState moodSetting.
     * @member {IMoodSetting|null|undefined} moodSetting
     * @memberof MoodState
     * @instance
     */
    MoodState.prototype.moodSetting = null;

    /**
     * Creates a new MoodState instance using the specified properties.
     * @function create
     * @memberof MoodState
     * @static
     * @param {IMoodState=} [properties] Properties to set
     * @returns {MoodState} MoodState instance
     */
    MoodState.create = function create(properties) {
        return new MoodState(properties);
    };

    /**
     * Encodes the specified MoodState message. Does not implicitly {@link MoodState.verify|verify} messages.
     * @function encode
     * @memberof MoodState
     * @static
     * @param {IMoodState} message MoodState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting"))
            $root.MoodSetting.encode(message.moodSetting, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified MoodState message, length delimited. Does not implicitly {@link MoodState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoodState
     * @static
     * @param {IMoodState} message MoodState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoodState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoodState message from the specified reader or buffer.
     * @function decode
     * @memberof MoodState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoodState} MoodState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoodState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 4:
                message.moodSetting = $root.MoodSetting.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MoodState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoodState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoodState} MoodState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoodState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoodState message.
     * @function verify
     * @memberof MoodState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoodState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting")) {
            let error = $root.MoodSetting.verify(message.moodSetting);
            if (error)
                return "moodSetting." + error;
        }
        return null;
    };

    /**
     * Creates a MoodState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoodState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoodState} MoodState
     */
    MoodState.fromObject = function fromObject(object) {
        if (object instanceof $root.MoodState)
            return object;
        let message = new $root.MoodState();
        if (object.moodSetting != null) {
            if (typeof object.moodSetting !== "object")
                throw TypeError(".MoodState.moodSetting: object expected");
            message.moodSetting = $root.MoodSetting.fromObject(object.moodSetting);
        }
        return message;
    };

    /**
     * Creates a plain object from a MoodState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoodState
     * @static
     * @param {MoodState} message MoodState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoodState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.moodSetting = null;
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting"))
            object.moodSetting = $root.MoodSetting.toObject(message.moodSetting, options);
        return object;
    };

    /**
     * Converts this MoodState to JSON.
     * @function toJSON
     * @memberof MoodState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoodState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return MoodState;
})();

/**
 * DeleteType enum.
 * @exports DeleteType
 * @enum {string}
 * @property {number} DELETE_TYPE_UNKNOWN=0 DELETE_TYPE_UNKNOWN value
 * @property {number} DELETE_TYPE_UPPER_BOUND=1 DELETE_TYPE_UPPER_BOUND value
 */
$root.DeleteType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "DELETE_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "DELETE_TYPE_UPPER_BOUND"] = 1;
    return values;
})();

export const DeleteAction = $root.DeleteAction = (() => {

    /**
     * Properties of a DeleteAction.
     * @exports IDeleteAction
     * @interface IDeleteAction
     * @property {number|Long|null} [deleteActionTimestamp] DeleteAction deleteActionTimestamp
     * @property {number|Long|null} [deleteUpperBoundTimestamp] DeleteAction deleteUpperBoundTimestamp
     * @property {DeleteType|null} [deleteType] DeleteAction deleteType
     */

    /**
     * Constructs a new DeleteAction.
     * @exports DeleteAction
     * @classdesc Represents a DeleteAction.
     * @implements IDeleteAction
     * @constructor
     * @param {IDeleteAction=} [properties] Properties to set
     */
    function DeleteAction(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteAction deleteActionTimestamp.
     * @member {number|Long} deleteActionTimestamp
     * @memberof DeleteAction
     * @instance
     */
    DeleteAction.prototype.deleteActionTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * DeleteAction deleteUpperBoundTimestamp.
     * @member {number|Long} deleteUpperBoundTimestamp
     * @memberof DeleteAction
     * @instance
     */
    DeleteAction.prototype.deleteUpperBoundTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * DeleteAction deleteType.
     * @member {DeleteType} deleteType
     * @memberof DeleteAction
     * @instance
     */
    DeleteAction.prototype.deleteType = 0;

    /**
     * Creates a new DeleteAction instance using the specified properties.
     * @function create
     * @memberof DeleteAction
     * @static
     * @param {IDeleteAction=} [properties] Properties to set
     * @returns {DeleteAction} DeleteAction instance
     */
    DeleteAction.create = function create(properties) {
        return new DeleteAction(properties);
    };

    /**
     * Encodes the specified DeleteAction message. Does not implicitly {@link DeleteAction.verify|verify} messages.
     * @function encode
     * @memberof DeleteAction
     * @static
     * @param {IDeleteAction} message DeleteAction message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteAction.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.deleteActionTimestamp != null && message.hasOwnProperty("deleteActionTimestamp"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.deleteActionTimestamp);
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.deleteUpperBoundTimestamp);
        if (message.deleteType != null && message.hasOwnProperty("deleteType"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.deleteType);
        return writer;
    };

    /**
     * Encodes the specified DeleteAction message, length delimited. Does not implicitly {@link DeleteAction.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteAction
     * @static
     * @param {IDeleteAction} message DeleteAction message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteAction.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteAction message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteAction
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteAction} DeleteAction
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteAction.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteAction();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.deleteActionTimestamp = reader.uint64();
                break;
            case 2:
                message.deleteUpperBoundTimestamp = reader.uint64();
                break;
            case 3:
                message.deleteType = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteAction message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteAction
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteAction} DeleteAction
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteAction.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteAction message.
     * @function verify
     * @memberof DeleteAction
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteAction.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.deleteActionTimestamp != null && message.hasOwnProperty("deleteActionTimestamp"))
            if (!$util.isInteger(message.deleteActionTimestamp) && !(message.deleteActionTimestamp && $util.isInteger(message.deleteActionTimestamp.low) && $util.isInteger(message.deleteActionTimestamp.high)))
                return "deleteActionTimestamp: integer|Long expected";
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            if (!$util.isInteger(message.deleteUpperBoundTimestamp) && !(message.deleteUpperBoundTimestamp && $util.isInteger(message.deleteUpperBoundTimestamp.low) && $util.isInteger(message.deleteUpperBoundTimestamp.high)))
                return "deleteUpperBoundTimestamp: integer|Long expected";
        if (message.deleteType != null && message.hasOwnProperty("deleteType"))
            switch (message.deleteType) {
            default:
                return "deleteType: enum value expected";
            case 0:
            case 1:
                break;
            }
        return null;
    };

    /**
     * Creates a DeleteAction message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteAction
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteAction} DeleteAction
     */
    DeleteAction.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteAction)
            return object;
        let message = new $root.DeleteAction();
        if (object.deleteActionTimestamp != null)
            if ($util.Long)
                (message.deleteActionTimestamp = $util.Long.fromValue(object.deleteActionTimestamp)).unsigned = true;
            else if (typeof object.deleteActionTimestamp === "string")
                message.deleteActionTimestamp = parseInt(object.deleteActionTimestamp, 10);
            else if (typeof object.deleteActionTimestamp === "number")
                message.deleteActionTimestamp = object.deleteActionTimestamp;
            else if (typeof object.deleteActionTimestamp === "object")
                message.deleteActionTimestamp = new $util.LongBits(object.deleteActionTimestamp.low >>> 0, object.deleteActionTimestamp.high >>> 0).toNumber(true);
        if (object.deleteUpperBoundTimestamp != null)
            if ($util.Long)
                (message.deleteUpperBoundTimestamp = $util.Long.fromValue(object.deleteUpperBoundTimestamp)).unsigned = true;
            else if (typeof object.deleteUpperBoundTimestamp === "string")
                message.deleteUpperBoundTimestamp = parseInt(object.deleteUpperBoundTimestamp, 10);
            else if (typeof object.deleteUpperBoundTimestamp === "number")
                message.deleteUpperBoundTimestamp = object.deleteUpperBoundTimestamp;
            else if (typeof object.deleteUpperBoundTimestamp === "object")
                message.deleteUpperBoundTimestamp = new $util.LongBits(object.deleteUpperBoundTimestamp.low >>> 0, object.deleteUpperBoundTimestamp.high >>> 0).toNumber(true);
        switch (object.deleteType) {
        case "DELETE_TYPE_UNKNOWN":
        case 0:
            message.deleteType = 0;
            break;
        case "DELETE_TYPE_UPPER_BOUND":
        case 1:
            message.deleteType = 1;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a DeleteAction message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteAction
     * @static
     * @param {DeleteAction} message DeleteAction
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteAction.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.deleteActionTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.deleteActionTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.deleteUpperBoundTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.deleteUpperBoundTimestamp = options.longs === String ? "0" : 0;
            object.deleteType = options.enums === String ? "DELETE_TYPE_UNKNOWN" : 0;
        }
        if (message.deleteActionTimestamp != null && message.hasOwnProperty("deleteActionTimestamp"))
            if (typeof message.deleteActionTimestamp === "number")
                object.deleteActionTimestamp = options.longs === String ? String(message.deleteActionTimestamp) : message.deleteActionTimestamp;
            else
                object.deleteActionTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.deleteActionTimestamp) : options.longs === Number ? new $util.LongBits(message.deleteActionTimestamp.low >>> 0, message.deleteActionTimestamp.high >>> 0).toNumber(true) : message.deleteActionTimestamp;
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            if (typeof message.deleteUpperBoundTimestamp === "number")
                object.deleteUpperBoundTimestamp = options.longs === String ? String(message.deleteUpperBoundTimestamp) : message.deleteUpperBoundTimestamp;
            else
                object.deleteUpperBoundTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.deleteUpperBoundTimestamp) : options.longs === Number ? new $util.LongBits(message.deleteUpperBoundTimestamp.low >>> 0, message.deleteUpperBoundTimestamp.high >>> 0).toNumber(true) : message.deleteUpperBoundTimestamp;
        if (message.deleteType != null && message.hasOwnProperty("deleteType"))
            object.deleteType = options.enums === String ? $root.DeleteType[message.deleteType] : message.deleteType;
        return object;
    };

    /**
     * Converts this DeleteAction to JSON.
     * @function toJSON
     * @memberof DeleteAction
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteAction.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteAction;
})();

export const InviteeID = $root.InviteeID = (() => {

    /**
     * Properties of an InviteeID.
     * @exports IInviteeID
     * @interface IInviteeID
     * @property {string|null} [gaiaId] InviteeID gaiaId
     * @property {string|null} [fallbackName] InviteeID fallbackName
     */

    /**
     * Constructs a new InviteeID.
     * @exports InviteeID
     * @classdesc Represents an InviteeID.
     * @implements IInviteeID
     * @constructor
     * @param {IInviteeID=} [properties] Properties to set
     */
    function InviteeID(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * InviteeID gaiaId.
     * @member {string} gaiaId
     * @memberof InviteeID
     * @instance
     */
    InviteeID.prototype.gaiaId = "";

    /**
     * InviteeID fallbackName.
     * @member {string} fallbackName
     * @memberof InviteeID
     * @instance
     */
    InviteeID.prototype.fallbackName = "";

    /**
     * Creates a new InviteeID instance using the specified properties.
     * @function create
     * @memberof InviteeID
     * @static
     * @param {IInviteeID=} [properties] Properties to set
     * @returns {InviteeID} InviteeID instance
     */
    InviteeID.create = function create(properties) {
        return new InviteeID(properties);
    };

    /**
     * Encodes the specified InviteeID message. Does not implicitly {@link InviteeID.verify|verify} messages.
     * @function encode
     * @memberof InviteeID
     * @static
     * @param {IInviteeID} message InviteeID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InviteeID.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.gaiaId);
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.fallbackName);
        return writer;
    };

    /**
     * Encodes the specified InviteeID message, length delimited. Does not implicitly {@link InviteeID.verify|verify} messages.
     * @function encodeDelimited
     * @memberof InviteeID
     * @static
     * @param {IInviteeID} message InviteeID message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    InviteeID.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an InviteeID message from the specified reader or buffer.
     * @function decode
     * @memberof InviteeID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {InviteeID} InviteeID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InviteeID.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.InviteeID();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.gaiaId = reader.string();
                break;
            case 4:
                message.fallbackName = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an InviteeID message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof InviteeID
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {InviteeID} InviteeID
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    InviteeID.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an InviteeID message.
     * @function verify
     * @memberof InviteeID
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    InviteeID.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            if (!$util.isString(message.gaiaId))
                return "gaiaId: string expected";
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            if (!$util.isString(message.fallbackName))
                return "fallbackName: string expected";
        return null;
    };

    /**
     * Creates an InviteeID message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof InviteeID
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {InviteeID} InviteeID
     */
    InviteeID.fromObject = function fromObject(object) {
        if (object instanceof $root.InviteeID)
            return object;
        let message = new $root.InviteeID();
        if (object.gaiaId != null)
            message.gaiaId = String(object.gaiaId);
        if (object.fallbackName != null)
            message.fallbackName = String(object.fallbackName);
        return message;
    };

    /**
     * Creates a plain object from an InviteeID message. Also converts values to other types if specified.
     * @function toObject
     * @memberof InviteeID
     * @static
     * @param {InviteeID} message InviteeID
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    InviteeID.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.gaiaId = "";
            object.fallbackName = "";
        }
        if (message.gaiaId != null && message.hasOwnProperty("gaiaId"))
            object.gaiaId = message.gaiaId;
        if (message.fallbackName != null && message.hasOwnProperty("fallbackName"))
            object.fallbackName = message.fallbackName;
        return object;
    };

    /**
     * Converts this InviteeID to JSON.
     * @function toJSON
     * @memberof InviteeID
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    InviteeID.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return InviteeID;
})();

/**
 * SyncFilter enum.
 * @exports SyncFilter
 * @enum {string}
 * @property {number} SYNC_FILTER_UNKNOWN=0 SYNC_FILTER_UNKNOWN value
 * @property {number} SYNC_FILTER_INBOX=1 SYNC_FILTER_INBOX value
 * @property {number} SYNC_FILTER_ARCHIVED=2 SYNC_FILTER_ARCHIVED value
 */
$root.SyncFilter = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SYNC_FILTER_UNKNOWN"] = 0;
    values[valuesById[1] = "SYNC_FILTER_INBOX"] = 1;
    values[valuesById[2] = "SYNC_FILTER_ARCHIVED"] = 2;
    return values;
})();

export const Country = $root.Country = (() => {

    /**
     * Properties of a Country.
     * @exports ICountry
     * @interface ICountry
     * @property {string|null} [regionCode] Country regionCode
     * @property {number|Long|null} [countryCode] Country countryCode
     */

    /**
     * Constructs a new Country.
     * @exports Country
     * @classdesc Represents a Country.
     * @implements ICountry
     * @constructor
     * @param {ICountry=} [properties] Properties to set
     */
    function Country(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Country regionCode.
     * @member {string} regionCode
     * @memberof Country
     * @instance
     */
    Country.prototype.regionCode = "";

    /**
     * Country countryCode.
     * @member {number|Long} countryCode
     * @memberof Country
     * @instance
     */
    Country.prototype.countryCode = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new Country instance using the specified properties.
     * @function create
     * @memberof Country
     * @static
     * @param {ICountry=} [properties] Properties to set
     * @returns {Country} Country instance
     */
    Country.create = function create(properties) {
        return new Country(properties);
    };

    /**
     * Encodes the specified Country message. Does not implicitly {@link Country.verify|verify} messages.
     * @function encode
     * @memberof Country
     * @static
     * @param {ICountry} message Country message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Country.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.regionCode);
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.countryCode);
        return writer;
    };

    /**
     * Encodes the specified Country message, length delimited. Does not implicitly {@link Country.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Country
     * @static
     * @param {ICountry} message Country message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Country.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Country message from the specified reader or buffer.
     * @function decode
     * @memberof Country
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Country} Country
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Country.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Country();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.regionCode = reader.string();
                break;
            case 2:
                message.countryCode = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Country message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Country
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Country} Country
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Country.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Country message.
     * @function verify
     * @memberof Country
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Country.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            if (!$util.isString(message.regionCode))
                return "regionCode: string expected";
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            if (!$util.isInteger(message.countryCode) && !(message.countryCode && $util.isInteger(message.countryCode.low) && $util.isInteger(message.countryCode.high)))
                return "countryCode: integer|Long expected";
        return null;
    };

    /**
     * Creates a Country message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Country
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Country} Country
     */
    Country.fromObject = function fromObject(object) {
        if (object instanceof $root.Country)
            return object;
        let message = new $root.Country();
        if (object.regionCode != null)
            message.regionCode = String(object.regionCode);
        if (object.countryCode != null)
            if ($util.Long)
                (message.countryCode = $util.Long.fromValue(object.countryCode)).unsigned = true;
            else if (typeof object.countryCode === "string")
                message.countryCode = parseInt(object.countryCode, 10);
            else if (typeof object.countryCode === "number")
                message.countryCode = object.countryCode;
            else if (typeof object.countryCode === "object")
                message.countryCode = new $util.LongBits(object.countryCode.low >>> 0, object.countryCode.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a Country message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Country
     * @static
     * @param {Country} message Country
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Country.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.regionCode = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.countryCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.countryCode = options.longs === String ? "0" : 0;
        }
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            object.regionCode = message.regionCode;
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            if (typeof message.countryCode === "number")
                object.countryCode = options.longs === String ? String(message.countryCode) : message.countryCode;
            else
                object.countryCode = options.longs === String ? $util.Long.prototype.toString.call(message.countryCode) : options.longs === Number ? new $util.LongBits(message.countryCode.low >>> 0, message.countryCode.high >>> 0).toNumber(true) : message.countryCode;
        return object;
    };

    /**
     * Converts this Country to JSON.
     * @function toJSON
     * @memberof Country
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Country.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Country;
})();

/**
 * SoundState enum.
 * @exports SoundState
 * @enum {string}
 * @property {number} SOUND_STATE_UNKNOWN=0 SOUND_STATE_UNKNOWN value
 * @property {number} SOUND_STATE_ON=1 SOUND_STATE_ON value
 * @property {number} SOUND_STATE_OFF=2 SOUND_STATE_OFF value
 */
$root.SoundState = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SOUND_STATE_UNKNOWN"] = 0;
    values[valuesById[1] = "SOUND_STATE_ON"] = 1;
    values[valuesById[2] = "SOUND_STATE_OFF"] = 2;
    return values;
})();

export const DesktopSoundSetting = $root.DesktopSoundSetting = (() => {

    /**
     * Properties of a DesktopSoundSetting.
     * @exports IDesktopSoundSetting
     * @interface IDesktopSoundSetting
     * @property {SoundState|null} [desktopSoundState] DesktopSoundSetting desktopSoundState
     * @property {SoundState|null} [desktopRingSoundState] DesktopSoundSetting desktopRingSoundState
     */

    /**
     * Constructs a new DesktopSoundSetting.
     * @exports DesktopSoundSetting
     * @classdesc Represents a DesktopSoundSetting.
     * @implements IDesktopSoundSetting
     * @constructor
     * @param {IDesktopSoundSetting=} [properties] Properties to set
     */
    function DesktopSoundSetting(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DesktopSoundSetting desktopSoundState.
     * @member {SoundState} desktopSoundState
     * @memberof DesktopSoundSetting
     * @instance
     */
    DesktopSoundSetting.prototype.desktopSoundState = 0;

    /**
     * DesktopSoundSetting desktopRingSoundState.
     * @member {SoundState} desktopRingSoundState
     * @memberof DesktopSoundSetting
     * @instance
     */
    DesktopSoundSetting.prototype.desktopRingSoundState = 0;

    /**
     * Creates a new DesktopSoundSetting instance using the specified properties.
     * @function create
     * @memberof DesktopSoundSetting
     * @static
     * @param {IDesktopSoundSetting=} [properties] Properties to set
     * @returns {DesktopSoundSetting} DesktopSoundSetting instance
     */
    DesktopSoundSetting.create = function create(properties) {
        return new DesktopSoundSetting(properties);
    };

    /**
     * Encodes the specified DesktopSoundSetting message. Does not implicitly {@link DesktopSoundSetting.verify|verify} messages.
     * @function encode
     * @memberof DesktopSoundSetting
     * @static
     * @param {IDesktopSoundSetting} message DesktopSoundSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopSoundSetting.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.desktopSoundState != null && message.hasOwnProperty("desktopSoundState"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.desktopSoundState);
        if (message.desktopRingSoundState != null && message.hasOwnProperty("desktopRingSoundState"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.desktopRingSoundState);
        return writer;
    };

    /**
     * Encodes the specified DesktopSoundSetting message, length delimited. Does not implicitly {@link DesktopSoundSetting.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DesktopSoundSetting
     * @static
     * @param {IDesktopSoundSetting} message DesktopSoundSetting message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DesktopSoundSetting.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DesktopSoundSetting message from the specified reader or buffer.
     * @function decode
     * @memberof DesktopSoundSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DesktopSoundSetting} DesktopSoundSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopSoundSetting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DesktopSoundSetting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.desktopSoundState = reader.int32();
                break;
            case 2:
                message.desktopRingSoundState = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DesktopSoundSetting message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DesktopSoundSetting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DesktopSoundSetting} DesktopSoundSetting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DesktopSoundSetting.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DesktopSoundSetting message.
     * @function verify
     * @memberof DesktopSoundSetting
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DesktopSoundSetting.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.desktopSoundState != null && message.hasOwnProperty("desktopSoundState"))
            switch (message.desktopSoundState) {
            default:
                return "desktopSoundState: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.desktopRingSoundState != null && message.hasOwnProperty("desktopRingSoundState"))
            switch (message.desktopRingSoundState) {
            default:
                return "desktopRingSoundState: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a DesktopSoundSetting message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DesktopSoundSetting
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DesktopSoundSetting} DesktopSoundSetting
     */
    DesktopSoundSetting.fromObject = function fromObject(object) {
        if (object instanceof $root.DesktopSoundSetting)
            return object;
        let message = new $root.DesktopSoundSetting();
        switch (object.desktopSoundState) {
        case "SOUND_STATE_UNKNOWN":
        case 0:
            message.desktopSoundState = 0;
            break;
        case "SOUND_STATE_ON":
        case 1:
            message.desktopSoundState = 1;
            break;
        case "SOUND_STATE_OFF":
        case 2:
            message.desktopSoundState = 2;
            break;
        }
        switch (object.desktopRingSoundState) {
        case "SOUND_STATE_UNKNOWN":
        case 0:
            message.desktopRingSoundState = 0;
            break;
        case "SOUND_STATE_ON":
        case 1:
            message.desktopRingSoundState = 1;
            break;
        case "SOUND_STATE_OFF":
        case 2:
            message.desktopRingSoundState = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a DesktopSoundSetting message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DesktopSoundSetting
     * @static
     * @param {DesktopSoundSetting} message DesktopSoundSetting
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DesktopSoundSetting.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.desktopSoundState = options.enums === String ? "SOUND_STATE_UNKNOWN" : 0;
            object.desktopRingSoundState = options.enums === String ? "SOUND_STATE_UNKNOWN" : 0;
        }
        if (message.desktopSoundState != null && message.hasOwnProperty("desktopSoundState"))
            object.desktopSoundState = options.enums === String ? $root.SoundState[message.desktopSoundState] : message.desktopSoundState;
        if (message.desktopRingSoundState != null && message.hasOwnProperty("desktopRingSoundState"))
            object.desktopRingSoundState = options.enums === String ? $root.SoundState[message.desktopRingSoundState] : message.desktopRingSoundState;
        return object;
    };

    /**
     * Converts this DesktopSoundSetting to JSON.
     * @function toJSON
     * @memberof DesktopSoundSetting
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DesktopSoundSetting.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DesktopSoundSetting;
})();

/**
 * CallerIdSettingsMask enum.
 * @exports CallerIdSettingsMask
 * @enum {string}
 * @property {number} CALLER_ID_SETTINGS_MASK_UNKNOWN=0 CALLER_ID_SETTINGS_MASK_UNKNOWN value
 * @property {number} CALLER_ID_SETTINGS_MASK_PROVIDED=1 CALLER_ID_SETTINGS_MASK_PROVIDED value
 */
$root.CallerIdSettingsMask = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "CALLER_ID_SETTINGS_MASK_UNKNOWN"] = 0;
    values[valuesById[1] = "CALLER_ID_SETTINGS_MASK_PROVIDED"] = 1;
    return values;
})();

export const PhoneData = $root.PhoneData = (() => {

    /**
     * Properties of a PhoneData.
     * @exports IPhoneData
     * @interface IPhoneData
     * @property {Array.<IPhone>|null} [phone] PhoneData phone
     * @property {CallerIdSettingsMask|null} [callerIdSettingsMask] PhoneData callerIdSettingsMask
     */

    /**
     * Constructs a new PhoneData.
     * @exports PhoneData
     * @classdesc Represents a PhoneData.
     * @implements IPhoneData
     * @constructor
     * @param {IPhoneData=} [properties] Properties to set
     */
    function PhoneData(properties) {
        this.phone = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PhoneData phone.
     * @member {Array.<IPhone>} phone
     * @memberof PhoneData
     * @instance
     */
    PhoneData.prototype.phone = $util.emptyArray;

    /**
     * PhoneData callerIdSettingsMask.
     * @member {CallerIdSettingsMask} callerIdSettingsMask
     * @memberof PhoneData
     * @instance
     */
    PhoneData.prototype.callerIdSettingsMask = 0;

    /**
     * Creates a new PhoneData instance using the specified properties.
     * @function create
     * @memberof PhoneData
     * @static
     * @param {IPhoneData=} [properties] Properties to set
     * @returns {PhoneData} PhoneData instance
     */
    PhoneData.create = function create(properties) {
        return new PhoneData(properties);
    };

    /**
     * Encodes the specified PhoneData message. Does not implicitly {@link PhoneData.verify|verify} messages.
     * @function encode
     * @memberof PhoneData
     * @static
     * @param {IPhoneData} message PhoneData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PhoneData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.phone != null && message.phone.length)
            for (let i = 0; i < message.phone.length; ++i)
                $root.Phone.encode(message.phone[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.callerIdSettingsMask != null && message.hasOwnProperty("callerIdSettingsMask"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callerIdSettingsMask);
        return writer;
    };

    /**
     * Encodes the specified PhoneData message, length delimited. Does not implicitly {@link PhoneData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PhoneData
     * @static
     * @param {IPhoneData} message PhoneData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PhoneData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PhoneData message from the specified reader or buffer.
     * @function decode
     * @memberof PhoneData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PhoneData} PhoneData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PhoneData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PhoneData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.phone && message.phone.length))
                    message.phone = [];
                message.phone.push($root.Phone.decode(reader, reader.uint32()));
                break;
            case 3:
                message.callerIdSettingsMask = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PhoneData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PhoneData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PhoneData} PhoneData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PhoneData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PhoneData message.
     * @function verify
     * @memberof PhoneData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PhoneData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.phone != null && message.hasOwnProperty("phone")) {
            if (!Array.isArray(message.phone))
                return "phone: array expected";
            for (let i = 0; i < message.phone.length; ++i) {
                let error = $root.Phone.verify(message.phone[i]);
                if (error)
                    return "phone." + error;
            }
        }
        if (message.callerIdSettingsMask != null && message.hasOwnProperty("callerIdSettingsMask"))
            switch (message.callerIdSettingsMask) {
            default:
                return "callerIdSettingsMask: enum value expected";
            case 0:
            case 1:
                break;
            }
        return null;
    };

    /**
     * Creates a PhoneData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PhoneData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PhoneData} PhoneData
     */
    PhoneData.fromObject = function fromObject(object) {
        if (object instanceof $root.PhoneData)
            return object;
        let message = new $root.PhoneData();
        if (object.phone) {
            if (!Array.isArray(object.phone))
                throw TypeError(".PhoneData.phone: array expected");
            message.phone = [];
            for (let i = 0; i < object.phone.length; ++i) {
                if (typeof object.phone[i] !== "object")
                    throw TypeError(".PhoneData.phone: object expected");
                message.phone[i] = $root.Phone.fromObject(object.phone[i]);
            }
        }
        switch (object.callerIdSettingsMask) {
        case "CALLER_ID_SETTINGS_MASK_UNKNOWN":
        case 0:
            message.callerIdSettingsMask = 0;
            break;
        case "CALLER_ID_SETTINGS_MASK_PROVIDED":
        case 1:
            message.callerIdSettingsMask = 1;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a PhoneData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PhoneData
     * @static
     * @param {PhoneData} message PhoneData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PhoneData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.phone = [];
        if (options.defaults)
            object.callerIdSettingsMask = options.enums === String ? "CALLER_ID_SETTINGS_MASK_UNKNOWN" : 0;
        if (message.phone && message.phone.length) {
            object.phone = [];
            for (let j = 0; j < message.phone.length; ++j)
                object.phone[j] = $root.Phone.toObject(message.phone[j], options);
        }
        if (message.callerIdSettingsMask != null && message.hasOwnProperty("callerIdSettingsMask"))
            object.callerIdSettingsMask = options.enums === String ? $root.CallerIdSettingsMask[message.callerIdSettingsMask] : message.callerIdSettingsMask;
        return object;
    };

    /**
     * Converts this PhoneData to JSON.
     * @function toJSON
     * @memberof PhoneData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PhoneData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PhoneData;
})();

/**
 * PhoneVerificationStatus enum.
 * @exports PhoneVerificationStatus
 * @enum {string}
 * @property {number} PHONE_VERIFICATION_STATUS_UNKNOWN=0 PHONE_VERIFICATION_STATUS_UNKNOWN value
 * @property {number} PHONE_VERIFICATION_STATUS_VERIFIED=1 PHONE_VERIFICATION_STATUS_VERIFIED value
 */
$root.PhoneVerificationStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PHONE_VERIFICATION_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "PHONE_VERIFICATION_STATUS_VERIFIED"] = 1;
    return values;
})();

/**
 * PhoneDiscoverabilityStatus enum.
 * @exports PhoneDiscoverabilityStatus
 * @enum {string}
 * @property {number} PHONE_DISCOVERABILITY_STATUS_UNKNOWN=0 PHONE_DISCOVERABILITY_STATUS_UNKNOWN value
 * @property {number} PHONE_DISCOVERABILITY_STATUS_OPTED_IN_BUT_NOT_DISCOVERABLE=2 PHONE_DISCOVERABILITY_STATUS_OPTED_IN_BUT_NOT_DISCOVERABLE value
 */
$root.PhoneDiscoverabilityStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PHONE_DISCOVERABILITY_STATUS_UNKNOWN"] = 0;
    values[valuesById[2] = "PHONE_DISCOVERABILITY_STATUS_OPTED_IN_BUT_NOT_DISCOVERABLE"] = 2;
    return values;
})();

export const Phone = $root.Phone = (() => {

    /**
     * Properties of a Phone.
     * @exports IPhone
     * @interface IPhone
     * @property {IPhoneNumber|null} [phoneNumber] Phone phoneNumber
     * @property {boolean|null} [googleVoice] Phone googleVoice
     * @property {PhoneVerificationStatus|null} [verificationStatus] Phone verificationStatus
     * @property {boolean|null} [discoverable] Phone discoverable
     * @property {PhoneDiscoverabilityStatus|null} [discoverabilityStatus] Phone discoverabilityStatus
     * @property {boolean|null} [primary] Phone primary
     */

    /**
     * Constructs a new Phone.
     * @exports Phone
     * @classdesc Represents a Phone.
     * @implements IPhone
     * @constructor
     * @param {IPhone=} [properties] Properties to set
     */
    function Phone(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Phone phoneNumber.
     * @member {IPhoneNumber|null|undefined} phoneNumber
     * @memberof Phone
     * @instance
     */
    Phone.prototype.phoneNumber = null;

    /**
     * Phone googleVoice.
     * @member {boolean} googleVoice
     * @memberof Phone
     * @instance
     */
    Phone.prototype.googleVoice = false;

    /**
     * Phone verificationStatus.
     * @member {PhoneVerificationStatus} verificationStatus
     * @memberof Phone
     * @instance
     */
    Phone.prototype.verificationStatus = 0;

    /**
     * Phone discoverable.
     * @member {boolean} discoverable
     * @memberof Phone
     * @instance
     */
    Phone.prototype.discoverable = false;

    /**
     * Phone discoverabilityStatus.
     * @member {PhoneDiscoverabilityStatus} discoverabilityStatus
     * @memberof Phone
     * @instance
     */
    Phone.prototype.discoverabilityStatus = 0;

    /**
     * Phone primary.
     * @member {boolean} primary
     * @memberof Phone
     * @instance
     */
    Phone.prototype.primary = false;

    /**
     * Creates a new Phone instance using the specified properties.
     * @function create
     * @memberof Phone
     * @static
     * @param {IPhone=} [properties] Properties to set
     * @returns {Phone} Phone instance
     */
    Phone.create = function create(properties) {
        return new Phone(properties);
    };

    /**
     * Encodes the specified Phone message. Does not implicitly {@link Phone.verify|verify} messages.
     * @function encode
     * @memberof Phone
     * @static
     * @param {IPhone} message Phone message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Phone.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            $root.PhoneNumber.encode(message.phoneNumber, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.googleVoice != null && message.hasOwnProperty("googleVoice"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.googleVoice);
        if (message.verificationStatus != null && message.hasOwnProperty("verificationStatus"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.verificationStatus);
        if (message.discoverable != null && message.hasOwnProperty("discoverable"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.discoverable);
        if (message.discoverabilityStatus != null && message.hasOwnProperty("discoverabilityStatus"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.discoverabilityStatus);
        if (message.primary != null && message.hasOwnProperty("primary"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.primary);
        return writer;
    };

    /**
     * Encodes the specified Phone message, length delimited. Does not implicitly {@link Phone.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Phone
     * @static
     * @param {IPhone} message Phone message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Phone.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Phone message from the specified reader or buffer.
     * @function decode
     * @memberof Phone
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Phone} Phone
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Phone.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Phone();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.phoneNumber = $root.PhoneNumber.decode(reader, reader.uint32());
                break;
            case 2:
                message.googleVoice = reader.bool();
                break;
            case 3:
                message.verificationStatus = reader.int32();
                break;
            case 4:
                message.discoverable = reader.bool();
                break;
            case 5:
                message.discoverabilityStatus = reader.int32();
                break;
            case 6:
                message.primary = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Phone message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Phone
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Phone} Phone
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Phone.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Phone message.
     * @function verify
     * @memberof Phone
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Phone.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber")) {
            let error = $root.PhoneNumber.verify(message.phoneNumber);
            if (error)
                return "phoneNumber." + error;
        }
        if (message.googleVoice != null && message.hasOwnProperty("googleVoice"))
            if (typeof message.googleVoice !== "boolean")
                return "googleVoice: boolean expected";
        if (message.verificationStatus != null && message.hasOwnProperty("verificationStatus"))
            switch (message.verificationStatus) {
            default:
                return "verificationStatus: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.discoverable != null && message.hasOwnProperty("discoverable"))
            if (typeof message.discoverable !== "boolean")
                return "discoverable: boolean expected";
        if (message.discoverabilityStatus != null && message.hasOwnProperty("discoverabilityStatus"))
            switch (message.discoverabilityStatus) {
            default:
                return "discoverabilityStatus: enum value expected";
            case 0:
            case 2:
                break;
            }
        if (message.primary != null && message.hasOwnProperty("primary"))
            if (typeof message.primary !== "boolean")
                return "primary: boolean expected";
        return null;
    };

    /**
     * Creates a Phone message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Phone
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Phone} Phone
     */
    Phone.fromObject = function fromObject(object) {
        if (object instanceof $root.Phone)
            return object;
        let message = new $root.Phone();
        if (object.phoneNumber != null) {
            if (typeof object.phoneNumber !== "object")
                throw TypeError(".Phone.phoneNumber: object expected");
            message.phoneNumber = $root.PhoneNumber.fromObject(object.phoneNumber);
        }
        if (object.googleVoice != null)
            message.googleVoice = Boolean(object.googleVoice);
        switch (object.verificationStatus) {
        case "PHONE_VERIFICATION_STATUS_UNKNOWN":
        case 0:
            message.verificationStatus = 0;
            break;
        case "PHONE_VERIFICATION_STATUS_VERIFIED":
        case 1:
            message.verificationStatus = 1;
            break;
        }
        if (object.discoverable != null)
            message.discoverable = Boolean(object.discoverable);
        switch (object.discoverabilityStatus) {
        case "PHONE_DISCOVERABILITY_STATUS_UNKNOWN":
        case 0:
            message.discoverabilityStatus = 0;
            break;
        case "PHONE_DISCOVERABILITY_STATUS_OPTED_IN_BUT_NOT_DISCOVERABLE":
        case 2:
            message.discoverabilityStatus = 2;
            break;
        }
        if (object.primary != null)
            message.primary = Boolean(object.primary);
        return message;
    };

    /**
     * Creates a plain object from a Phone message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Phone
     * @static
     * @param {Phone} message Phone
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Phone.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.phoneNumber = null;
            object.googleVoice = false;
            object.verificationStatus = options.enums === String ? "PHONE_VERIFICATION_STATUS_UNKNOWN" : 0;
            object.discoverable = false;
            object.discoverabilityStatus = options.enums === String ? "PHONE_DISCOVERABILITY_STATUS_UNKNOWN" : 0;
            object.primary = false;
        }
        if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
            object.phoneNumber = $root.PhoneNumber.toObject(message.phoneNumber, options);
        if (message.googleVoice != null && message.hasOwnProperty("googleVoice"))
            object.googleVoice = message.googleVoice;
        if (message.verificationStatus != null && message.hasOwnProperty("verificationStatus"))
            object.verificationStatus = options.enums === String ? $root.PhoneVerificationStatus[message.verificationStatus] : message.verificationStatus;
        if (message.discoverable != null && message.hasOwnProperty("discoverable"))
            object.discoverable = message.discoverable;
        if (message.discoverabilityStatus != null && message.hasOwnProperty("discoverabilityStatus"))
            object.discoverabilityStatus = options.enums === String ? $root.PhoneDiscoverabilityStatus[message.discoverabilityStatus] : message.discoverabilityStatus;
        if (message.primary != null && message.hasOwnProperty("primary"))
            object.primary = message.primary;
        return object;
    };

    /**
     * Converts this Phone to JSON.
     * @function toJSON
     * @memberof Phone
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Phone.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Phone;
})();

/**
 * PhoneValidationResult enum.
 * @exports PhoneValidationResult
 * @enum {string}
 * @property {number} PHONE_VALIDATION_RESULT_IS_POSSIBLE=0 PHONE_VALIDATION_RESULT_IS_POSSIBLE value
 */
$root.PhoneValidationResult = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PHONE_VALIDATION_RESULT_IS_POSSIBLE"] = 0;
    return values;
})();

export const I18nData = $root.I18nData = (() => {

    /**
     * Properties of a I18nData.
     * @exports II18nData
     * @interface II18nData
     * @property {string|null} [nationalNumber] I18nData nationalNumber
     * @property {string|null} [internationalNumber] I18nData internationalNumber
     * @property {number|Long|null} [countryCode] I18nData countryCode
     * @property {string|null} [regionCode] I18nData regionCode
     * @property {boolean|null} [isValid] I18nData isValid
     * @property {PhoneValidationResult|null} [validationResult] I18nData validationResult
     */

    /**
     * Constructs a new I18nData.
     * @exports I18nData
     * @classdesc Represents a I18nData.
     * @implements II18nData
     * @constructor
     * @param {II18nData=} [properties] Properties to set
     */
    function I18nData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * I18nData nationalNumber.
     * @member {string} nationalNumber
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.nationalNumber = "";

    /**
     * I18nData internationalNumber.
     * @member {string} internationalNumber
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.internationalNumber = "";

    /**
     * I18nData countryCode.
     * @member {number|Long} countryCode
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.countryCode = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * I18nData regionCode.
     * @member {string} regionCode
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.regionCode = "";

    /**
     * I18nData isValid.
     * @member {boolean} isValid
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.isValid = false;

    /**
     * I18nData validationResult.
     * @member {PhoneValidationResult} validationResult
     * @memberof I18nData
     * @instance
     */
    I18nData.prototype.validationResult = 0;

    /**
     * Creates a new I18nData instance using the specified properties.
     * @function create
     * @memberof I18nData
     * @static
     * @param {II18nData=} [properties] Properties to set
     * @returns {I18nData} I18nData instance
     */
    I18nData.create = function create(properties) {
        return new I18nData(properties);
    };

    /**
     * Encodes the specified I18nData message. Does not implicitly {@link I18nData.verify|verify} messages.
     * @function encode
     * @memberof I18nData
     * @static
     * @param {II18nData} message I18nData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    I18nData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.nationalNumber != null && message.hasOwnProperty("nationalNumber"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.nationalNumber);
        if (message.internationalNumber != null && message.hasOwnProperty("internationalNumber"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.internationalNumber);
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.countryCode);
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.regionCode);
        if (message.isValid != null && message.hasOwnProperty("isValid"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isValid);
        if (message.validationResult != null && message.hasOwnProperty("validationResult"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.validationResult);
        return writer;
    };

    /**
     * Encodes the specified I18nData message, length delimited. Does not implicitly {@link I18nData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof I18nData
     * @static
     * @param {II18nData} message I18nData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    I18nData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a I18nData message from the specified reader or buffer.
     * @function decode
     * @memberof I18nData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {I18nData} I18nData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    I18nData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.I18nData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.nationalNumber = reader.string();
                break;
            case 2:
                message.internationalNumber = reader.string();
                break;
            case 3:
                message.countryCode = reader.uint64();
                break;
            case 4:
                message.regionCode = reader.string();
                break;
            case 5:
                message.isValid = reader.bool();
                break;
            case 6:
                message.validationResult = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a I18nData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof I18nData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {I18nData} I18nData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    I18nData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a I18nData message.
     * @function verify
     * @memberof I18nData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    I18nData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.nationalNumber != null && message.hasOwnProperty("nationalNumber"))
            if (!$util.isString(message.nationalNumber))
                return "nationalNumber: string expected";
        if (message.internationalNumber != null && message.hasOwnProperty("internationalNumber"))
            if (!$util.isString(message.internationalNumber))
                return "internationalNumber: string expected";
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            if (!$util.isInteger(message.countryCode) && !(message.countryCode && $util.isInteger(message.countryCode.low) && $util.isInteger(message.countryCode.high)))
                return "countryCode: integer|Long expected";
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            if (!$util.isString(message.regionCode))
                return "regionCode: string expected";
        if (message.isValid != null && message.hasOwnProperty("isValid"))
            if (typeof message.isValid !== "boolean")
                return "isValid: boolean expected";
        if (message.validationResult != null && message.hasOwnProperty("validationResult"))
            switch (message.validationResult) {
            default:
                return "validationResult: enum value expected";
            case 0:
                break;
            }
        return null;
    };

    /**
     * Creates a I18nData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof I18nData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {I18nData} I18nData
     */
    I18nData.fromObject = function fromObject(object) {
        if (object instanceof $root.I18nData)
            return object;
        let message = new $root.I18nData();
        if (object.nationalNumber != null)
            message.nationalNumber = String(object.nationalNumber);
        if (object.internationalNumber != null)
            message.internationalNumber = String(object.internationalNumber);
        if (object.countryCode != null)
            if ($util.Long)
                (message.countryCode = $util.Long.fromValue(object.countryCode)).unsigned = true;
            else if (typeof object.countryCode === "string")
                message.countryCode = parseInt(object.countryCode, 10);
            else if (typeof object.countryCode === "number")
                message.countryCode = object.countryCode;
            else if (typeof object.countryCode === "object")
                message.countryCode = new $util.LongBits(object.countryCode.low >>> 0, object.countryCode.high >>> 0).toNumber(true);
        if (object.regionCode != null)
            message.regionCode = String(object.regionCode);
        if (object.isValid != null)
            message.isValid = Boolean(object.isValid);
        switch (object.validationResult) {
        case "PHONE_VALIDATION_RESULT_IS_POSSIBLE":
        case 0:
            message.validationResult = 0;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a I18nData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof I18nData
     * @static
     * @param {I18nData} message I18nData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    I18nData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.nationalNumber = "";
            object.internationalNumber = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.countryCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.countryCode = options.longs === String ? "0" : 0;
            object.regionCode = "";
            object.isValid = false;
            object.validationResult = options.enums === String ? "PHONE_VALIDATION_RESULT_IS_POSSIBLE" : 0;
        }
        if (message.nationalNumber != null && message.hasOwnProperty("nationalNumber"))
            object.nationalNumber = message.nationalNumber;
        if (message.internationalNumber != null && message.hasOwnProperty("internationalNumber"))
            object.internationalNumber = message.internationalNumber;
        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
            if (typeof message.countryCode === "number")
                object.countryCode = options.longs === String ? String(message.countryCode) : message.countryCode;
            else
                object.countryCode = options.longs === String ? $util.Long.prototype.toString.call(message.countryCode) : options.longs === Number ? new $util.LongBits(message.countryCode.low >>> 0, message.countryCode.high >>> 0).toNumber(true) : message.countryCode;
        if (message.regionCode != null && message.hasOwnProperty("regionCode"))
            object.regionCode = message.regionCode;
        if (message.isValid != null && message.hasOwnProperty("isValid"))
            object.isValid = message.isValid;
        if (message.validationResult != null && message.hasOwnProperty("validationResult"))
            object.validationResult = options.enums === String ? $root.PhoneValidationResult[message.validationResult] : message.validationResult;
        return object;
    };

    /**
     * Converts this I18nData to JSON.
     * @function toJSON
     * @memberof I18nData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    I18nData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return I18nData;
})();

export const PhoneNumber = $root.PhoneNumber = (() => {

    /**
     * Properties of a PhoneNumber.
     * @exports IPhoneNumber
     * @interface IPhoneNumber
     * @property {string|null} [e164] PhoneNumber e164
     * @property {II18nData|null} [i18nData] PhoneNumber i18nData
     */

    /**
     * Constructs a new PhoneNumber.
     * @exports PhoneNumber
     * @classdesc Represents a PhoneNumber.
     * @implements IPhoneNumber
     * @constructor
     * @param {IPhoneNumber=} [properties] Properties to set
     */
    function PhoneNumber(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PhoneNumber e164.
     * @member {string} e164
     * @memberof PhoneNumber
     * @instance
     */
    PhoneNumber.prototype.e164 = "";

    /**
     * PhoneNumber i18nData.
     * @member {II18nData|null|undefined} i18nData
     * @memberof PhoneNumber
     * @instance
     */
    PhoneNumber.prototype.i18nData = null;

    /**
     * Creates a new PhoneNumber instance using the specified properties.
     * @function create
     * @memberof PhoneNumber
     * @static
     * @param {IPhoneNumber=} [properties] Properties to set
     * @returns {PhoneNumber} PhoneNumber instance
     */
    PhoneNumber.create = function create(properties) {
        return new PhoneNumber(properties);
    };

    /**
     * Encodes the specified PhoneNumber message. Does not implicitly {@link PhoneNumber.verify|verify} messages.
     * @function encode
     * @memberof PhoneNumber
     * @static
     * @param {IPhoneNumber} message PhoneNumber message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PhoneNumber.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.e164 != null && message.hasOwnProperty("e164"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.e164);
        if (message.i18nData != null && message.hasOwnProperty("i18nData"))
            $root.I18nData.encode(message.i18nData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PhoneNumber message, length delimited. Does not implicitly {@link PhoneNumber.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PhoneNumber
     * @static
     * @param {IPhoneNumber} message PhoneNumber message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PhoneNumber.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PhoneNumber message from the specified reader or buffer.
     * @function decode
     * @memberof PhoneNumber
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PhoneNumber} PhoneNumber
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PhoneNumber.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PhoneNumber();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.e164 = reader.string();
                break;
            case 2:
                message.i18nData = $root.I18nData.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PhoneNumber message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PhoneNumber
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PhoneNumber} PhoneNumber
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PhoneNumber.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PhoneNumber message.
     * @function verify
     * @memberof PhoneNumber
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PhoneNumber.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.e164 != null && message.hasOwnProperty("e164"))
            if (!$util.isString(message.e164))
                return "e164: string expected";
        if (message.i18nData != null && message.hasOwnProperty("i18nData")) {
            let error = $root.I18nData.verify(message.i18nData);
            if (error)
                return "i18nData." + error;
        }
        return null;
    };

    /**
     * Creates a PhoneNumber message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PhoneNumber
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PhoneNumber} PhoneNumber
     */
    PhoneNumber.fromObject = function fromObject(object) {
        if (object instanceof $root.PhoneNumber)
            return object;
        let message = new $root.PhoneNumber();
        if (object.e164 != null)
            message.e164 = String(object.e164);
        if (object.i18nData != null) {
            if (typeof object.i18nData !== "object")
                throw TypeError(".PhoneNumber.i18nData: object expected");
            message.i18nData = $root.I18nData.fromObject(object.i18nData);
        }
        return message;
    };

    /**
     * Creates a plain object from a PhoneNumber message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PhoneNumber
     * @static
     * @param {PhoneNumber} message PhoneNumber
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PhoneNumber.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.e164 = "";
            object.i18nData = null;
        }
        if (message.e164 != null && message.hasOwnProperty("e164"))
            object.e164 = message.e164;
        if (message.i18nData != null && message.hasOwnProperty("i18nData"))
            object.i18nData = $root.I18nData.toObject(message.i18nData, options);
        return object;
    };

    /**
     * Converts this PhoneNumber to JSON.
     * @function toJSON
     * @memberof PhoneNumber
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PhoneNumber.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PhoneNumber;
})();

export const SuggestedContactGroupHash = $root.SuggestedContactGroupHash = (() => {

    /**
     * Properties of a SuggestedContactGroupHash.
     * @exports ISuggestedContactGroupHash
     * @interface ISuggestedContactGroupHash
     * @property {number|Long|null} [maxResults] SuggestedContactGroupHash maxResults
     * @property {Uint8Array|null} [hash] SuggestedContactGroupHash hash
     */

    /**
     * Constructs a new SuggestedContactGroupHash.
     * @exports SuggestedContactGroupHash
     * @classdesc Represents a SuggestedContactGroupHash.
     * @implements ISuggestedContactGroupHash
     * @constructor
     * @param {ISuggestedContactGroupHash=} [properties] Properties to set
     */
    function SuggestedContactGroupHash(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SuggestedContactGroupHash maxResults.
     * @member {number|Long} maxResults
     * @memberof SuggestedContactGroupHash
     * @instance
     */
    SuggestedContactGroupHash.prototype.maxResults = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SuggestedContactGroupHash hash.
     * @member {Uint8Array} hash
     * @memberof SuggestedContactGroupHash
     * @instance
     */
    SuggestedContactGroupHash.prototype.hash = $util.newBuffer([]);

    /**
     * Creates a new SuggestedContactGroupHash instance using the specified properties.
     * @function create
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {ISuggestedContactGroupHash=} [properties] Properties to set
     * @returns {SuggestedContactGroupHash} SuggestedContactGroupHash instance
     */
    SuggestedContactGroupHash.create = function create(properties) {
        return new SuggestedContactGroupHash(properties);
    };

    /**
     * Encodes the specified SuggestedContactGroupHash message. Does not implicitly {@link SuggestedContactGroupHash.verify|verify} messages.
     * @function encode
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {ISuggestedContactGroupHash} message SuggestedContactGroupHash message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContactGroupHash.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.maxResults != null && message.hasOwnProperty("maxResults"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.maxResults);
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
        return writer;
    };

    /**
     * Encodes the specified SuggestedContactGroupHash message, length delimited. Does not implicitly {@link SuggestedContactGroupHash.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {ISuggestedContactGroupHash} message SuggestedContactGroupHash message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContactGroupHash.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SuggestedContactGroupHash message from the specified reader or buffer.
     * @function decode
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SuggestedContactGroupHash} SuggestedContactGroupHash
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContactGroupHash.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SuggestedContactGroupHash();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.maxResults = reader.uint64();
                break;
            case 2:
                message.hash = reader.bytes();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SuggestedContactGroupHash message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SuggestedContactGroupHash} SuggestedContactGroupHash
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContactGroupHash.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SuggestedContactGroupHash message.
     * @function verify
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SuggestedContactGroupHash.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.maxResults != null && message.hasOwnProperty("maxResults"))
            if (!$util.isInteger(message.maxResults) && !(message.maxResults && $util.isInteger(message.maxResults.low) && $util.isInteger(message.maxResults.high)))
                return "maxResults: integer|Long expected";
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                return "hash: buffer expected";
        return null;
    };

    /**
     * Creates a SuggestedContactGroupHash message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SuggestedContactGroupHash} SuggestedContactGroupHash
     */
    SuggestedContactGroupHash.fromObject = function fromObject(object) {
        if (object instanceof $root.SuggestedContactGroupHash)
            return object;
        let message = new $root.SuggestedContactGroupHash();
        if (object.maxResults != null)
            if ($util.Long)
                (message.maxResults = $util.Long.fromValue(object.maxResults)).unsigned = true;
            else if (typeof object.maxResults === "string")
                message.maxResults = parseInt(object.maxResults, 10);
            else if (typeof object.maxResults === "number")
                message.maxResults = object.maxResults;
            else if (typeof object.maxResults === "object")
                message.maxResults = new $util.LongBits(object.maxResults.low >>> 0, object.maxResults.high >>> 0).toNumber(true);
        if (object.hash != null)
            if (typeof object.hash === "string")
                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
            else if (object.hash.length)
                message.hash = object.hash;
        return message;
    };

    /**
     * Creates a plain object from a SuggestedContactGroupHash message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SuggestedContactGroupHash
     * @static
     * @param {SuggestedContactGroupHash} message SuggestedContactGroupHash
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SuggestedContactGroupHash.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxResults = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxResults = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.hash = "";
            else {
                object.hash = [];
                if (options.bytes !== Array)
                    object.hash = $util.newBuffer(object.hash);
            }
        }
        if (message.maxResults != null && message.hasOwnProperty("maxResults"))
            if (typeof message.maxResults === "number")
                object.maxResults = options.longs === String ? String(message.maxResults) : message.maxResults;
            else
                object.maxResults = options.longs === String ? $util.Long.prototype.toString.call(message.maxResults) : options.longs === Number ? new $util.LongBits(message.maxResults.low >>> 0, message.maxResults.high >>> 0).toNumber(true) : message.maxResults;
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
        return object;
    };

    /**
     * Converts this SuggestedContactGroupHash to JSON.
     * @function toJSON
     * @memberof SuggestedContactGroupHash
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SuggestedContactGroupHash.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SuggestedContactGroupHash;
})();

export const SuggestedContact = $root.SuggestedContact = (() => {

    /**
     * Properties of a SuggestedContact.
     * @exports ISuggestedContact
     * @interface ISuggestedContact
     * @property {IEntity|null} [entity] SuggestedContact entity
     * @property {InvitationStatus|null} [invitationStatus] SuggestedContact invitationStatus
     */

    /**
     * Constructs a new SuggestedContact.
     * @exports SuggestedContact
     * @classdesc Represents a SuggestedContact.
     * @implements ISuggestedContact
     * @constructor
     * @param {ISuggestedContact=} [properties] Properties to set
     */
    function SuggestedContact(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SuggestedContact entity.
     * @member {IEntity|null|undefined} entity
     * @memberof SuggestedContact
     * @instance
     */
    SuggestedContact.prototype.entity = null;

    /**
     * SuggestedContact invitationStatus.
     * @member {InvitationStatus} invitationStatus
     * @memberof SuggestedContact
     * @instance
     */
    SuggestedContact.prototype.invitationStatus = 0;

    /**
     * Creates a new SuggestedContact instance using the specified properties.
     * @function create
     * @memberof SuggestedContact
     * @static
     * @param {ISuggestedContact=} [properties] Properties to set
     * @returns {SuggestedContact} SuggestedContact instance
     */
    SuggestedContact.create = function create(properties) {
        return new SuggestedContact(properties);
    };

    /**
     * Encodes the specified SuggestedContact message. Does not implicitly {@link SuggestedContact.verify|verify} messages.
     * @function encode
     * @memberof SuggestedContact
     * @static
     * @param {ISuggestedContact} message SuggestedContact message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContact.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.entity != null && message.hasOwnProperty("entity"))
            $root.Entity.encode(message.entity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.invitationStatus);
        return writer;
    };

    /**
     * Encodes the specified SuggestedContact message, length delimited. Does not implicitly {@link SuggestedContact.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SuggestedContact
     * @static
     * @param {ISuggestedContact} message SuggestedContact message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContact.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SuggestedContact message from the specified reader or buffer.
     * @function decode
     * @memberof SuggestedContact
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SuggestedContact} SuggestedContact
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContact.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SuggestedContact();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.entity = $root.Entity.decode(reader, reader.uint32());
                break;
            case 2:
                message.invitationStatus = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SuggestedContact message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SuggestedContact
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SuggestedContact} SuggestedContact
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContact.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SuggestedContact message.
     * @function verify
     * @memberof SuggestedContact
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SuggestedContact.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.entity != null && message.hasOwnProperty("entity")) {
            let error = $root.Entity.verify(message.entity);
            if (error)
                return "entity." + error;
        }
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            switch (message.invitationStatus) {
            default:
                return "invitationStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a SuggestedContact message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SuggestedContact
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SuggestedContact} SuggestedContact
     */
    SuggestedContact.fromObject = function fromObject(object) {
        if (object instanceof $root.SuggestedContact)
            return object;
        let message = new $root.SuggestedContact();
        if (object.entity != null) {
            if (typeof object.entity !== "object")
                throw TypeError(".SuggestedContact.entity: object expected");
            message.entity = $root.Entity.fromObject(object.entity);
        }
        switch (object.invitationStatus) {
        case "INVITATION_STATUS_UNKNOWN":
        case 0:
            message.invitationStatus = 0;
            break;
        case "INVITATION_STATUS_PENDING":
        case 1:
            message.invitationStatus = 1;
            break;
        case "INVITATION_STATUS_ACCEPTED":
        case 2:
            message.invitationStatus = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SuggestedContact message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SuggestedContact
     * @static
     * @param {SuggestedContact} message SuggestedContact
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SuggestedContact.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.entity = null;
            object.invitationStatus = options.enums === String ? "INVITATION_STATUS_UNKNOWN" : 0;
        }
        if (message.entity != null && message.hasOwnProperty("entity"))
            object.entity = $root.Entity.toObject(message.entity, options);
        if (message.invitationStatus != null && message.hasOwnProperty("invitationStatus"))
            object.invitationStatus = options.enums === String ? $root.InvitationStatus[message.invitationStatus] : message.invitationStatus;
        return object;
    };

    /**
     * Converts this SuggestedContact to JSON.
     * @function toJSON
     * @memberof SuggestedContact
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SuggestedContact.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SuggestedContact;
})();

export const SuggestedContactGroup = $root.SuggestedContactGroup = (() => {

    /**
     * Properties of a SuggestedContactGroup.
     * @exports ISuggestedContactGroup
     * @interface ISuggestedContactGroup
     * @property {boolean|null} [hashMatched] SuggestedContactGroup hashMatched
     * @property {Uint8Array|null} [hash] SuggestedContactGroup hash
     * @property {Array.<ISuggestedContact>|null} [contact] SuggestedContactGroup contact
     */

    /**
     * Constructs a new SuggestedContactGroup.
     * @exports SuggestedContactGroup
     * @classdesc Represents a SuggestedContactGroup.
     * @implements ISuggestedContactGroup
     * @constructor
     * @param {ISuggestedContactGroup=} [properties] Properties to set
     */
    function SuggestedContactGroup(properties) {
        this.contact = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SuggestedContactGroup hashMatched.
     * @member {boolean} hashMatched
     * @memberof SuggestedContactGroup
     * @instance
     */
    SuggestedContactGroup.prototype.hashMatched = false;

    /**
     * SuggestedContactGroup hash.
     * @member {Uint8Array} hash
     * @memberof SuggestedContactGroup
     * @instance
     */
    SuggestedContactGroup.prototype.hash = $util.newBuffer([]);

    /**
     * SuggestedContactGroup contact.
     * @member {Array.<ISuggestedContact>} contact
     * @memberof SuggestedContactGroup
     * @instance
     */
    SuggestedContactGroup.prototype.contact = $util.emptyArray;

    /**
     * Creates a new SuggestedContactGroup instance using the specified properties.
     * @function create
     * @memberof SuggestedContactGroup
     * @static
     * @param {ISuggestedContactGroup=} [properties] Properties to set
     * @returns {SuggestedContactGroup} SuggestedContactGroup instance
     */
    SuggestedContactGroup.create = function create(properties) {
        return new SuggestedContactGroup(properties);
    };

    /**
     * Encodes the specified SuggestedContactGroup message. Does not implicitly {@link SuggestedContactGroup.verify|verify} messages.
     * @function encode
     * @memberof SuggestedContactGroup
     * @static
     * @param {ISuggestedContactGroup} message SuggestedContactGroup message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContactGroup.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.hashMatched != null && message.hasOwnProperty("hashMatched"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hashMatched);
        if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hash);
        if (message.contact != null && message.contact.length)
            for (let i = 0; i < message.contact.length; ++i)
                $root.SuggestedContact.encode(message.contact[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SuggestedContactGroup message, length delimited. Does not implicitly {@link SuggestedContactGroup.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SuggestedContactGroup
     * @static
     * @param {ISuggestedContactGroup} message SuggestedContactGroup message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SuggestedContactGroup.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SuggestedContactGroup message from the specified reader or buffer.
     * @function decode
     * @memberof SuggestedContactGroup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SuggestedContactGroup} SuggestedContactGroup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContactGroup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SuggestedContactGroup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.hashMatched = reader.bool();
                break;
            case 2:
                message.hash = reader.bytes();
                break;
            case 3:
                if (!(message.contact && message.contact.length))
                    message.contact = [];
                message.contact.push($root.SuggestedContact.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SuggestedContactGroup message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SuggestedContactGroup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SuggestedContactGroup} SuggestedContactGroup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SuggestedContactGroup.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SuggestedContactGroup message.
     * @function verify
     * @memberof SuggestedContactGroup
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SuggestedContactGroup.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.hashMatched != null && message.hasOwnProperty("hashMatched"))
            if (typeof message.hashMatched !== "boolean")
                return "hashMatched: boolean expected";
        if (message.hash != null && message.hasOwnProperty("hash"))
            if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                return "hash: buffer expected";
        if (message.contact != null && message.hasOwnProperty("contact")) {
            if (!Array.isArray(message.contact))
                return "contact: array expected";
            for (let i = 0; i < message.contact.length; ++i) {
                let error = $root.SuggestedContact.verify(message.contact[i]);
                if (error)
                    return "contact." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SuggestedContactGroup message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SuggestedContactGroup
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SuggestedContactGroup} SuggestedContactGroup
     */
    SuggestedContactGroup.fromObject = function fromObject(object) {
        if (object instanceof $root.SuggestedContactGroup)
            return object;
        let message = new $root.SuggestedContactGroup();
        if (object.hashMatched != null)
            message.hashMatched = Boolean(object.hashMatched);
        if (object.hash != null)
            if (typeof object.hash === "string")
                $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
            else if (object.hash.length)
                message.hash = object.hash;
        if (object.contact) {
            if (!Array.isArray(object.contact))
                throw TypeError(".SuggestedContactGroup.contact: array expected");
            message.contact = [];
            for (let i = 0; i < object.contact.length; ++i) {
                if (typeof object.contact[i] !== "object")
                    throw TypeError(".SuggestedContactGroup.contact: object expected");
                message.contact[i] = $root.SuggestedContact.fromObject(object.contact[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SuggestedContactGroup message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SuggestedContactGroup
     * @static
     * @param {SuggestedContactGroup} message SuggestedContactGroup
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SuggestedContactGroup.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.contact = [];
        if (options.defaults) {
            object.hashMatched = false;
            if (options.bytes === String)
                object.hash = "";
            else {
                object.hash = [];
                if (options.bytes !== Array)
                    object.hash = $util.newBuffer(object.hash);
            }
        }
        if (message.hashMatched != null && message.hasOwnProperty("hashMatched"))
            object.hashMatched = message.hashMatched;
        if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
        if (message.contact && message.contact.length) {
            object.contact = [];
            for (let j = 0; j < message.contact.length; ++j)
                object.contact[j] = $root.SuggestedContact.toObject(message.contact[j], options);
        }
        return object;
    };

    /**
     * Converts this SuggestedContactGroup to JSON.
     * @function toJSON
     * @memberof SuggestedContactGroup
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SuggestedContactGroup.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SuggestedContactGroup;
})();

export const GroupLinkSharingModification = $root.GroupLinkSharingModification = (() => {

    /**
     * Properties of a GroupLinkSharingModification.
     * @exports IGroupLinkSharingModification
     * @interface IGroupLinkSharingModification
     * @property {GroupLinkSharingStatus|null} [newStatus] GroupLinkSharingModification newStatus
     */

    /**
     * Constructs a new GroupLinkSharingModification.
     * @exports GroupLinkSharingModification
     * @classdesc Represents a GroupLinkSharingModification.
     * @implements IGroupLinkSharingModification
     * @constructor
     * @param {IGroupLinkSharingModification=} [properties] Properties to set
     */
    function GroupLinkSharingModification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GroupLinkSharingModification newStatus.
     * @member {GroupLinkSharingStatus} newStatus
     * @memberof GroupLinkSharingModification
     * @instance
     */
    GroupLinkSharingModification.prototype.newStatus = 0;

    /**
     * Creates a new GroupLinkSharingModification instance using the specified properties.
     * @function create
     * @memberof GroupLinkSharingModification
     * @static
     * @param {IGroupLinkSharingModification=} [properties] Properties to set
     * @returns {GroupLinkSharingModification} GroupLinkSharingModification instance
     */
    GroupLinkSharingModification.create = function create(properties) {
        return new GroupLinkSharingModification(properties);
    };

    /**
     * Encodes the specified GroupLinkSharingModification message. Does not implicitly {@link GroupLinkSharingModification.verify|verify} messages.
     * @function encode
     * @memberof GroupLinkSharingModification
     * @static
     * @param {IGroupLinkSharingModification} message GroupLinkSharingModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLinkSharingModification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.newStatus != null && message.hasOwnProperty("newStatus"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.newStatus);
        return writer;
    };

    /**
     * Encodes the specified GroupLinkSharingModification message, length delimited. Does not implicitly {@link GroupLinkSharingModification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GroupLinkSharingModification
     * @static
     * @param {IGroupLinkSharingModification} message GroupLinkSharingModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GroupLinkSharingModification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GroupLinkSharingModification message from the specified reader or buffer.
     * @function decode
     * @memberof GroupLinkSharingModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GroupLinkSharingModification} GroupLinkSharingModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLinkSharingModification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GroupLinkSharingModification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.newStatus = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GroupLinkSharingModification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GroupLinkSharingModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GroupLinkSharingModification} GroupLinkSharingModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GroupLinkSharingModification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GroupLinkSharingModification message.
     * @function verify
     * @memberof GroupLinkSharingModification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GroupLinkSharingModification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.newStatus != null && message.hasOwnProperty("newStatus"))
            switch (message.newStatus) {
            default:
                return "newStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a GroupLinkSharingModification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GroupLinkSharingModification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GroupLinkSharingModification} GroupLinkSharingModification
     */
    GroupLinkSharingModification.fromObject = function fromObject(object) {
        if (object instanceof $root.GroupLinkSharingModification)
            return object;
        let message = new $root.GroupLinkSharingModification();
        switch (object.newStatus) {
        case "GROUP_LINK_SHARING_STATUS_UNKNOWN":
        case 0:
            message.newStatus = 0;
            break;
        case "GROUP_LINK_SHARING_STATUS_ON":
        case 1:
            message.newStatus = 1;
            break;
        case "GROUP_LINK_SHARING_STATUS_OFF":
        case 2:
            message.newStatus = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a GroupLinkSharingModification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GroupLinkSharingModification
     * @static
     * @param {GroupLinkSharingModification} message GroupLinkSharingModification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GroupLinkSharingModification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.newStatus = options.enums === String ? "GROUP_LINK_SHARING_STATUS_UNKNOWN" : 0;
        if (message.newStatus != null && message.hasOwnProperty("newStatus"))
            object.newStatus = options.enums === String ? $root.GroupLinkSharingStatus[message.newStatus] : message.newStatus;
        return object;
    };

    /**
     * Converts this GroupLinkSharingModification to JSON.
     * @function toJSON
     * @memberof GroupLinkSharingModification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GroupLinkSharingModification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GroupLinkSharingModification;
})();

export const StateUpdate = $root.StateUpdate = (() => {

    /**
     * Properties of a StateUpdate.
     * @exports IStateUpdate
     * @interface IStateUpdate
     * @property {IStateUpdateHeader|null} [stateUpdateHeader] StateUpdate stateUpdateHeader
     * @property {IConversation|null} [conversation] StateUpdate conversation
     * @property {IConversationNotification|null} [conversationNotification] StateUpdate conversationNotification
     * @property {IEventNotification|null} [eventNotification] StateUpdate eventNotification
     * @property {ISetFocusNotification|null} [focusNotification] StateUpdate focusNotification
     * @property {ISetTypingNotification|null} [typingNotification] StateUpdate typingNotification
     * @property {ISetConversationNotificationLevelNotification|null} [notificationLevelNotification] StateUpdate notificationLevelNotification
     * @property {IReplyToInviteNotification|null} [replyToInviteNotification] StateUpdate replyToInviteNotification
     * @property {IWatermarkNotification|null} [watermarkNotification] StateUpdate watermarkNotification
     * @property {IConversationViewModification|null} [viewModification] StateUpdate viewModification
     * @property {IEasterEggNotification|null} [easterEggNotification] StateUpdate easterEggNotification
     * @property {ISelfPresenceNotification|null} [selfPresenceNotification] StateUpdate selfPresenceNotification
     * @property {IDeleteActionNotification|null} [deleteNotification] StateUpdate deleteNotification
     * @property {IPresenceNotification|null} [presenceNotification] StateUpdate presenceNotification
     * @property {IBlockNotification|null} [blockNotification] StateUpdate blockNotification
     * @property {ISetNotificationSettingNotification|null} [notificationSettingNotification] StateUpdate notificationSettingNotification
     * @property {IRichPresenceEnabledStateNotification|null} [richPresenceEnabledStateNotification] StateUpdate richPresenceEnabledStateNotification
     */

    /**
     * Constructs a new StateUpdate.
     * @exports StateUpdate
     * @classdesc Represents a StateUpdate.
     * @implements IStateUpdate
     * @constructor
     * @param {IStateUpdate=} [properties] Properties to set
     */
    function StateUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StateUpdate stateUpdateHeader.
     * @member {IStateUpdateHeader|null|undefined} stateUpdateHeader
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.stateUpdateHeader = null;

    /**
     * StateUpdate conversation.
     * @member {IConversation|null|undefined} conversation
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.conversation = null;

    /**
     * StateUpdate conversationNotification.
     * @member {IConversationNotification|null|undefined} conversationNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.conversationNotification = null;

    /**
     * StateUpdate eventNotification.
     * @member {IEventNotification|null|undefined} eventNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.eventNotification = null;

    /**
     * StateUpdate focusNotification.
     * @member {ISetFocusNotification|null|undefined} focusNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.focusNotification = null;

    /**
     * StateUpdate typingNotification.
     * @member {ISetTypingNotification|null|undefined} typingNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.typingNotification = null;

    /**
     * StateUpdate notificationLevelNotification.
     * @member {ISetConversationNotificationLevelNotification|null|undefined} notificationLevelNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.notificationLevelNotification = null;

    /**
     * StateUpdate replyToInviteNotification.
     * @member {IReplyToInviteNotification|null|undefined} replyToInviteNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.replyToInviteNotification = null;

    /**
     * StateUpdate watermarkNotification.
     * @member {IWatermarkNotification|null|undefined} watermarkNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.watermarkNotification = null;

    /**
     * StateUpdate viewModification.
     * @member {IConversationViewModification|null|undefined} viewModification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.viewModification = null;

    /**
     * StateUpdate easterEggNotification.
     * @member {IEasterEggNotification|null|undefined} easterEggNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.easterEggNotification = null;

    /**
     * StateUpdate selfPresenceNotification.
     * @member {ISelfPresenceNotification|null|undefined} selfPresenceNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.selfPresenceNotification = null;

    /**
     * StateUpdate deleteNotification.
     * @member {IDeleteActionNotification|null|undefined} deleteNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.deleteNotification = null;

    /**
     * StateUpdate presenceNotification.
     * @member {IPresenceNotification|null|undefined} presenceNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.presenceNotification = null;

    /**
     * StateUpdate blockNotification.
     * @member {IBlockNotification|null|undefined} blockNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.blockNotification = null;

    /**
     * StateUpdate notificationSettingNotification.
     * @member {ISetNotificationSettingNotification|null|undefined} notificationSettingNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.notificationSettingNotification = null;

    /**
     * StateUpdate richPresenceEnabledStateNotification.
     * @member {IRichPresenceEnabledStateNotification|null|undefined} richPresenceEnabledStateNotification
     * @memberof StateUpdate
     * @instance
     */
    StateUpdate.prototype.richPresenceEnabledStateNotification = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * StateUpdate stateUpdate.
     * @member {"conversationNotification"|"eventNotification"|"focusNotification"|"typingNotification"|"notificationLevelNotification"|"replyToInviteNotification"|"watermarkNotification"|"viewModification"|"easterEggNotification"|"selfPresenceNotification"|"deleteNotification"|"presenceNotification"|"blockNotification"|"notificationSettingNotification"|"richPresenceEnabledStateNotification"|undefined} stateUpdate
     * @memberof StateUpdate
     * @instance
     */
    Object.defineProperty(StateUpdate.prototype, "stateUpdate", {
        get: $util.oneOfGetter($oneOfFields = ["conversationNotification", "eventNotification", "focusNotification", "typingNotification", "notificationLevelNotification", "replyToInviteNotification", "watermarkNotification", "viewModification", "easterEggNotification", "selfPresenceNotification", "deleteNotification", "presenceNotification", "blockNotification", "notificationSettingNotification", "richPresenceEnabledStateNotification"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new StateUpdate instance using the specified properties.
     * @function create
     * @memberof StateUpdate
     * @static
     * @param {IStateUpdate=} [properties] Properties to set
     * @returns {StateUpdate} StateUpdate instance
     */
    StateUpdate.create = function create(properties) {
        return new StateUpdate(properties);
    };

    /**
     * Encodes the specified StateUpdate message. Does not implicitly {@link StateUpdate.verify|verify} messages.
     * @function encode
     * @memberof StateUpdate
     * @static
     * @param {IStateUpdate} message StateUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateUpdate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.stateUpdateHeader != null && message.hasOwnProperty("stateUpdateHeader"))
            $root.StateUpdateHeader.encode(message.stateUpdateHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationNotification != null && message.hasOwnProperty("conversationNotification"))
            $root.ConversationNotification.encode(message.conversationNotification, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.eventNotification != null && message.hasOwnProperty("eventNotification"))
            $root.EventNotification.encode(message.eventNotification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.focusNotification != null && message.hasOwnProperty("focusNotification"))
            $root.SetFocusNotification.encode(message.focusNotification, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.typingNotification != null && message.hasOwnProperty("typingNotification"))
            $root.SetTypingNotification.encode(message.typingNotification, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.notificationLevelNotification != null && message.hasOwnProperty("notificationLevelNotification"))
            $root.SetConversationNotificationLevelNotification.encode(message.notificationLevelNotification, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.replyToInviteNotification != null && message.hasOwnProperty("replyToInviteNotification"))
            $root.ReplyToInviteNotification.encode(message.replyToInviteNotification, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.watermarkNotification != null && message.hasOwnProperty("watermarkNotification"))
            $root.WatermarkNotification.encode(message.watermarkNotification, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.viewModification != null && message.hasOwnProperty("viewModification"))
            $root.ConversationViewModification.encode(message.viewModification, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.easterEggNotification != null && message.hasOwnProperty("easterEggNotification"))
            $root.EasterEggNotification.encode(message.easterEggNotification, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            $root.Conversation.encode(message.conversation, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.selfPresenceNotification != null && message.hasOwnProperty("selfPresenceNotification"))
            $root.SelfPresenceNotification.encode(message.selfPresenceNotification, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        if (message.deleteNotification != null && message.hasOwnProperty("deleteNotification"))
            $root.DeleteActionNotification.encode(message.deleteNotification, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
        if (message.presenceNotification != null && message.hasOwnProperty("presenceNotification"))
            $root.PresenceNotification.encode(message.presenceNotification, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
        if (message.blockNotification != null && message.hasOwnProperty("blockNotification"))
            $root.BlockNotification.encode(message.blockNotification, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
        if (message.notificationSettingNotification != null && message.hasOwnProperty("notificationSettingNotification"))
            $root.SetNotificationSettingNotification.encode(message.notificationSettingNotification, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        if (message.richPresenceEnabledStateNotification != null && message.hasOwnProperty("richPresenceEnabledStateNotification"))
            $root.RichPresenceEnabledStateNotification.encode(message.richPresenceEnabledStateNotification, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified StateUpdate message, length delimited. Does not implicitly {@link StateUpdate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StateUpdate
     * @static
     * @param {IStateUpdate} message StateUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateUpdate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StateUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof StateUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StateUpdate} StateUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StateUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.stateUpdateHeader = $root.StateUpdateHeader.decode(reader, reader.uint32());
                break;
            case 13:
                message.conversation = $root.Conversation.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationNotification = $root.ConversationNotification.decode(reader, reader.uint32());
                break;
            case 3:
                message.eventNotification = $root.EventNotification.decode(reader, reader.uint32());
                break;
            case 4:
                message.focusNotification = $root.SetFocusNotification.decode(reader, reader.uint32());
                break;
            case 5:
                message.typingNotification = $root.SetTypingNotification.decode(reader, reader.uint32());
                break;
            case 6:
                message.notificationLevelNotification = $root.SetConversationNotificationLevelNotification.decode(reader, reader.uint32());
                break;
            case 7:
                message.replyToInviteNotification = $root.ReplyToInviteNotification.decode(reader, reader.uint32());
                break;
            case 8:
                message.watermarkNotification = $root.WatermarkNotification.decode(reader, reader.uint32());
                break;
            case 11:
                message.viewModification = $root.ConversationViewModification.decode(reader, reader.uint32());
                break;
            case 12:
                message.easterEggNotification = $root.EasterEggNotification.decode(reader, reader.uint32());
                break;
            case 14:
                message.selfPresenceNotification = $root.SelfPresenceNotification.decode(reader, reader.uint32());
                break;
            case 15:
                message.deleteNotification = $root.DeleteActionNotification.decode(reader, reader.uint32());
                break;
            case 16:
                message.presenceNotification = $root.PresenceNotification.decode(reader, reader.uint32());
                break;
            case 17:
                message.blockNotification = $root.BlockNotification.decode(reader, reader.uint32());
                break;
            case 19:
                message.notificationSettingNotification = $root.SetNotificationSettingNotification.decode(reader, reader.uint32());
                break;
            case 20:
                message.richPresenceEnabledStateNotification = $root.RichPresenceEnabledStateNotification.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StateUpdate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StateUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StateUpdate} StateUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateUpdate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StateUpdate message.
     * @function verify
     * @memberof StateUpdate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StateUpdate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.stateUpdateHeader != null && message.hasOwnProperty("stateUpdateHeader")) {
            let error = $root.StateUpdateHeader.verify(message.stateUpdateHeader);
            if (error)
                return "stateUpdateHeader." + error;
        }
        if (message.conversation != null && message.hasOwnProperty("conversation")) {
            let error = $root.Conversation.verify(message.conversation);
            if (error)
                return "conversation." + error;
        }
        if (message.conversationNotification != null && message.hasOwnProperty("conversationNotification")) {
            properties.stateUpdate = 1;
            {
                let error = $root.ConversationNotification.verify(message.conversationNotification);
                if (error)
                    return "conversationNotification." + error;
            }
        }
        if (message.eventNotification != null && message.hasOwnProperty("eventNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.EventNotification.verify(message.eventNotification);
                if (error)
                    return "eventNotification." + error;
            }
        }
        if (message.focusNotification != null && message.hasOwnProperty("focusNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.SetFocusNotification.verify(message.focusNotification);
                if (error)
                    return "focusNotification." + error;
            }
        }
        if (message.typingNotification != null && message.hasOwnProperty("typingNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.SetTypingNotification.verify(message.typingNotification);
                if (error)
                    return "typingNotification." + error;
            }
        }
        if (message.notificationLevelNotification != null && message.hasOwnProperty("notificationLevelNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.SetConversationNotificationLevelNotification.verify(message.notificationLevelNotification);
                if (error)
                    return "notificationLevelNotification." + error;
            }
        }
        if (message.replyToInviteNotification != null && message.hasOwnProperty("replyToInviteNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.ReplyToInviteNotification.verify(message.replyToInviteNotification);
                if (error)
                    return "replyToInviteNotification." + error;
            }
        }
        if (message.watermarkNotification != null && message.hasOwnProperty("watermarkNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.WatermarkNotification.verify(message.watermarkNotification);
                if (error)
                    return "watermarkNotification." + error;
            }
        }
        if (message.viewModification != null && message.hasOwnProperty("viewModification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.ConversationViewModification.verify(message.viewModification);
                if (error)
                    return "viewModification." + error;
            }
        }
        if (message.easterEggNotification != null && message.hasOwnProperty("easterEggNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.EasterEggNotification.verify(message.easterEggNotification);
                if (error)
                    return "easterEggNotification." + error;
            }
        }
        if (message.selfPresenceNotification != null && message.hasOwnProperty("selfPresenceNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.SelfPresenceNotification.verify(message.selfPresenceNotification);
                if (error)
                    return "selfPresenceNotification." + error;
            }
        }
        if (message.deleteNotification != null && message.hasOwnProperty("deleteNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.DeleteActionNotification.verify(message.deleteNotification);
                if (error)
                    return "deleteNotification." + error;
            }
        }
        if (message.presenceNotification != null && message.hasOwnProperty("presenceNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.PresenceNotification.verify(message.presenceNotification);
                if (error)
                    return "presenceNotification." + error;
            }
        }
        if (message.blockNotification != null && message.hasOwnProperty("blockNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.BlockNotification.verify(message.blockNotification);
                if (error)
                    return "blockNotification." + error;
            }
        }
        if (message.notificationSettingNotification != null && message.hasOwnProperty("notificationSettingNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.SetNotificationSettingNotification.verify(message.notificationSettingNotification);
                if (error)
                    return "notificationSettingNotification." + error;
            }
        }
        if (message.richPresenceEnabledStateNotification != null && message.hasOwnProperty("richPresenceEnabledStateNotification")) {
            if (properties.stateUpdate === 1)
                return "stateUpdate: multiple values";
            properties.stateUpdate = 1;
            {
                let error = $root.RichPresenceEnabledStateNotification.verify(message.richPresenceEnabledStateNotification);
                if (error)
                    return "richPresenceEnabledStateNotification." + error;
            }
        }
        return null;
    };

    /**
     * Creates a StateUpdate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StateUpdate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StateUpdate} StateUpdate
     */
    StateUpdate.fromObject = function fromObject(object) {
        if (object instanceof $root.StateUpdate)
            return object;
        let message = new $root.StateUpdate();
        if (object.stateUpdateHeader != null) {
            if (typeof object.stateUpdateHeader !== "object")
                throw TypeError(".StateUpdate.stateUpdateHeader: object expected");
            message.stateUpdateHeader = $root.StateUpdateHeader.fromObject(object.stateUpdateHeader);
        }
        if (object.conversation != null) {
            if (typeof object.conversation !== "object")
                throw TypeError(".StateUpdate.conversation: object expected");
            message.conversation = $root.Conversation.fromObject(object.conversation);
        }
        if (object.conversationNotification != null) {
            if (typeof object.conversationNotification !== "object")
                throw TypeError(".StateUpdate.conversationNotification: object expected");
            message.conversationNotification = $root.ConversationNotification.fromObject(object.conversationNotification);
        }
        if (object.eventNotification != null) {
            if (typeof object.eventNotification !== "object")
                throw TypeError(".StateUpdate.eventNotification: object expected");
            message.eventNotification = $root.EventNotification.fromObject(object.eventNotification);
        }
        if (object.focusNotification != null) {
            if (typeof object.focusNotification !== "object")
                throw TypeError(".StateUpdate.focusNotification: object expected");
            message.focusNotification = $root.SetFocusNotification.fromObject(object.focusNotification);
        }
        if (object.typingNotification != null) {
            if (typeof object.typingNotification !== "object")
                throw TypeError(".StateUpdate.typingNotification: object expected");
            message.typingNotification = $root.SetTypingNotification.fromObject(object.typingNotification);
        }
        if (object.notificationLevelNotification != null) {
            if (typeof object.notificationLevelNotification !== "object")
                throw TypeError(".StateUpdate.notificationLevelNotification: object expected");
            message.notificationLevelNotification = $root.SetConversationNotificationLevelNotification.fromObject(object.notificationLevelNotification);
        }
        if (object.replyToInviteNotification != null) {
            if (typeof object.replyToInviteNotification !== "object")
                throw TypeError(".StateUpdate.replyToInviteNotification: object expected");
            message.replyToInviteNotification = $root.ReplyToInviteNotification.fromObject(object.replyToInviteNotification);
        }
        if (object.watermarkNotification != null) {
            if (typeof object.watermarkNotification !== "object")
                throw TypeError(".StateUpdate.watermarkNotification: object expected");
            message.watermarkNotification = $root.WatermarkNotification.fromObject(object.watermarkNotification);
        }
        if (object.viewModification != null) {
            if (typeof object.viewModification !== "object")
                throw TypeError(".StateUpdate.viewModification: object expected");
            message.viewModification = $root.ConversationViewModification.fromObject(object.viewModification);
        }
        if (object.easterEggNotification != null) {
            if (typeof object.easterEggNotification !== "object")
                throw TypeError(".StateUpdate.easterEggNotification: object expected");
            message.easterEggNotification = $root.EasterEggNotification.fromObject(object.easterEggNotification);
        }
        if (object.selfPresenceNotification != null) {
            if (typeof object.selfPresenceNotification !== "object")
                throw TypeError(".StateUpdate.selfPresenceNotification: object expected");
            message.selfPresenceNotification = $root.SelfPresenceNotification.fromObject(object.selfPresenceNotification);
        }
        if (object.deleteNotification != null) {
            if (typeof object.deleteNotification !== "object")
                throw TypeError(".StateUpdate.deleteNotification: object expected");
            message.deleteNotification = $root.DeleteActionNotification.fromObject(object.deleteNotification);
        }
        if (object.presenceNotification != null) {
            if (typeof object.presenceNotification !== "object")
                throw TypeError(".StateUpdate.presenceNotification: object expected");
            message.presenceNotification = $root.PresenceNotification.fromObject(object.presenceNotification);
        }
        if (object.blockNotification != null) {
            if (typeof object.blockNotification !== "object")
                throw TypeError(".StateUpdate.blockNotification: object expected");
            message.blockNotification = $root.BlockNotification.fromObject(object.blockNotification);
        }
        if (object.notificationSettingNotification != null) {
            if (typeof object.notificationSettingNotification !== "object")
                throw TypeError(".StateUpdate.notificationSettingNotification: object expected");
            message.notificationSettingNotification = $root.SetNotificationSettingNotification.fromObject(object.notificationSettingNotification);
        }
        if (object.richPresenceEnabledStateNotification != null) {
            if (typeof object.richPresenceEnabledStateNotification !== "object")
                throw TypeError(".StateUpdate.richPresenceEnabledStateNotification: object expected");
            message.richPresenceEnabledStateNotification = $root.RichPresenceEnabledStateNotification.fromObject(object.richPresenceEnabledStateNotification);
        }
        return message;
    };

    /**
     * Creates a plain object from a StateUpdate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StateUpdate
     * @static
     * @param {StateUpdate} message StateUpdate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StateUpdate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.stateUpdateHeader = null;
            object.conversation = null;
        }
        if (message.stateUpdateHeader != null && message.hasOwnProperty("stateUpdateHeader"))
            object.stateUpdateHeader = $root.StateUpdateHeader.toObject(message.stateUpdateHeader, options);
        if (message.conversationNotification != null && message.hasOwnProperty("conversationNotification")) {
            object.conversationNotification = $root.ConversationNotification.toObject(message.conversationNotification, options);
            if (options.oneofs)
                object.stateUpdate = "conversationNotification";
        }
        if (message.eventNotification != null && message.hasOwnProperty("eventNotification")) {
            object.eventNotification = $root.EventNotification.toObject(message.eventNotification, options);
            if (options.oneofs)
                object.stateUpdate = "eventNotification";
        }
        if (message.focusNotification != null && message.hasOwnProperty("focusNotification")) {
            object.focusNotification = $root.SetFocusNotification.toObject(message.focusNotification, options);
            if (options.oneofs)
                object.stateUpdate = "focusNotification";
        }
        if (message.typingNotification != null && message.hasOwnProperty("typingNotification")) {
            object.typingNotification = $root.SetTypingNotification.toObject(message.typingNotification, options);
            if (options.oneofs)
                object.stateUpdate = "typingNotification";
        }
        if (message.notificationLevelNotification != null && message.hasOwnProperty("notificationLevelNotification")) {
            object.notificationLevelNotification = $root.SetConversationNotificationLevelNotification.toObject(message.notificationLevelNotification, options);
            if (options.oneofs)
                object.stateUpdate = "notificationLevelNotification";
        }
        if (message.replyToInviteNotification != null && message.hasOwnProperty("replyToInviteNotification")) {
            object.replyToInviteNotification = $root.ReplyToInviteNotification.toObject(message.replyToInviteNotification, options);
            if (options.oneofs)
                object.stateUpdate = "replyToInviteNotification";
        }
        if (message.watermarkNotification != null && message.hasOwnProperty("watermarkNotification")) {
            object.watermarkNotification = $root.WatermarkNotification.toObject(message.watermarkNotification, options);
            if (options.oneofs)
                object.stateUpdate = "watermarkNotification";
        }
        if (message.viewModification != null && message.hasOwnProperty("viewModification")) {
            object.viewModification = $root.ConversationViewModification.toObject(message.viewModification, options);
            if (options.oneofs)
                object.stateUpdate = "viewModification";
        }
        if (message.easterEggNotification != null && message.hasOwnProperty("easterEggNotification")) {
            object.easterEggNotification = $root.EasterEggNotification.toObject(message.easterEggNotification, options);
            if (options.oneofs)
                object.stateUpdate = "easterEggNotification";
        }
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            object.conversation = $root.Conversation.toObject(message.conversation, options);
        if (message.selfPresenceNotification != null && message.hasOwnProperty("selfPresenceNotification")) {
            object.selfPresenceNotification = $root.SelfPresenceNotification.toObject(message.selfPresenceNotification, options);
            if (options.oneofs)
                object.stateUpdate = "selfPresenceNotification";
        }
        if (message.deleteNotification != null && message.hasOwnProperty("deleteNotification")) {
            object.deleteNotification = $root.DeleteActionNotification.toObject(message.deleteNotification, options);
            if (options.oneofs)
                object.stateUpdate = "deleteNotification";
        }
        if (message.presenceNotification != null && message.hasOwnProperty("presenceNotification")) {
            object.presenceNotification = $root.PresenceNotification.toObject(message.presenceNotification, options);
            if (options.oneofs)
                object.stateUpdate = "presenceNotification";
        }
        if (message.blockNotification != null && message.hasOwnProperty("blockNotification")) {
            object.blockNotification = $root.BlockNotification.toObject(message.blockNotification, options);
            if (options.oneofs)
                object.stateUpdate = "blockNotification";
        }
        if (message.notificationSettingNotification != null && message.hasOwnProperty("notificationSettingNotification")) {
            object.notificationSettingNotification = $root.SetNotificationSettingNotification.toObject(message.notificationSettingNotification, options);
            if (options.oneofs)
                object.stateUpdate = "notificationSettingNotification";
        }
        if (message.richPresenceEnabledStateNotification != null && message.hasOwnProperty("richPresenceEnabledStateNotification")) {
            object.richPresenceEnabledStateNotification = $root.RichPresenceEnabledStateNotification.toObject(message.richPresenceEnabledStateNotification, options);
            if (options.oneofs)
                object.stateUpdate = "richPresenceEnabledStateNotification";
        }
        return object;
    };

    /**
     * Converts this StateUpdate to JSON.
     * @function toJSON
     * @memberof StateUpdate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StateUpdate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StateUpdate;
})();

export const StateUpdateHeader = $root.StateUpdateHeader = (() => {

    /**
     * Properties of a StateUpdateHeader.
     * @exports IStateUpdateHeader
     * @interface IStateUpdateHeader
     * @property {ActiveClientState|null} [activeClientState] StateUpdateHeader activeClientState
     * @property {string|null} [requestTraceId] StateUpdateHeader requestTraceId
     * @property {INotificationSettings|null} [notificationSettings] StateUpdateHeader notificationSettings
     * @property {number|Long|null} [currentServerTime] StateUpdateHeader currentServerTime
     */

    /**
     * Constructs a new StateUpdateHeader.
     * @exports StateUpdateHeader
     * @classdesc Represents a StateUpdateHeader.
     * @implements IStateUpdateHeader
     * @constructor
     * @param {IStateUpdateHeader=} [properties] Properties to set
     */
    function StateUpdateHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StateUpdateHeader activeClientState.
     * @member {ActiveClientState} activeClientState
     * @memberof StateUpdateHeader
     * @instance
     */
    StateUpdateHeader.prototype.activeClientState = 0;

    /**
     * StateUpdateHeader requestTraceId.
     * @member {string} requestTraceId
     * @memberof StateUpdateHeader
     * @instance
     */
    StateUpdateHeader.prototype.requestTraceId = "";

    /**
     * StateUpdateHeader notificationSettings.
     * @member {INotificationSettings|null|undefined} notificationSettings
     * @memberof StateUpdateHeader
     * @instance
     */
    StateUpdateHeader.prototype.notificationSettings = null;

    /**
     * StateUpdateHeader currentServerTime.
     * @member {number|Long} currentServerTime
     * @memberof StateUpdateHeader
     * @instance
     */
    StateUpdateHeader.prototype.currentServerTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new StateUpdateHeader instance using the specified properties.
     * @function create
     * @memberof StateUpdateHeader
     * @static
     * @param {IStateUpdateHeader=} [properties] Properties to set
     * @returns {StateUpdateHeader} StateUpdateHeader instance
     */
    StateUpdateHeader.create = function create(properties) {
        return new StateUpdateHeader(properties);
    };

    /**
     * Encodes the specified StateUpdateHeader message. Does not implicitly {@link StateUpdateHeader.verify|verify} messages.
     * @function encode
     * @memberof StateUpdateHeader
     * @static
     * @param {IStateUpdateHeader} message StateUpdateHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateUpdateHeader.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.activeClientState != null && message.hasOwnProperty("activeClientState"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.activeClientState);
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.requestTraceId);
        if (message.notificationSettings != null && message.hasOwnProperty("notificationSettings"))
            $root.NotificationSettings.encode(message.notificationSettings, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.currentServerTime);
        return writer;
    };

    /**
     * Encodes the specified StateUpdateHeader message, length delimited. Does not implicitly {@link StateUpdateHeader.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StateUpdateHeader
     * @static
     * @param {IStateUpdateHeader} message StateUpdateHeader message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StateUpdateHeader.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StateUpdateHeader message from the specified reader or buffer.
     * @function decode
     * @memberof StateUpdateHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StateUpdateHeader} StateUpdateHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateUpdateHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StateUpdateHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.activeClientState = reader.int32();
                break;
            case 3:
                message.requestTraceId = reader.string();
                break;
            case 4:
                message.notificationSettings = $root.NotificationSettings.decode(reader, reader.uint32());
                break;
            case 5:
                message.currentServerTime = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StateUpdateHeader message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StateUpdateHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StateUpdateHeader} StateUpdateHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StateUpdateHeader.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StateUpdateHeader message.
     * @function verify
     * @memberof StateUpdateHeader
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StateUpdateHeader.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.activeClientState != null && message.hasOwnProperty("activeClientState"))
            switch (message.activeClientState) {
            default:
                return "activeClientState: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            if (!$util.isString(message.requestTraceId))
                return "requestTraceId: string expected";
        if (message.notificationSettings != null && message.hasOwnProperty("notificationSettings")) {
            let error = $root.NotificationSettings.verify(message.notificationSettings);
            if (error)
                return "notificationSettings." + error;
        }
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            if (!$util.isInteger(message.currentServerTime) && !(message.currentServerTime && $util.isInteger(message.currentServerTime.low) && $util.isInteger(message.currentServerTime.high)))
                return "currentServerTime: integer|Long expected";
        return null;
    };

    /**
     * Creates a StateUpdateHeader message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StateUpdateHeader
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StateUpdateHeader} StateUpdateHeader
     */
    StateUpdateHeader.fromObject = function fromObject(object) {
        if (object instanceof $root.StateUpdateHeader)
            return object;
        let message = new $root.StateUpdateHeader();
        switch (object.activeClientState) {
        case "ACTIVE_CLIENT_STATE_NO_ACTIVE":
        case 0:
            message.activeClientState = 0;
            break;
        case "ACTIVE_CLIENT_STATE_IS_ACTIVE":
        case 1:
            message.activeClientState = 1;
            break;
        case "ACTIVE_CLIENT_STATE_OTHER_ACTIVE":
        case 2:
            message.activeClientState = 2;
            break;
        }
        if (object.requestTraceId != null)
            message.requestTraceId = String(object.requestTraceId);
        if (object.notificationSettings != null) {
            if (typeof object.notificationSettings !== "object")
                throw TypeError(".StateUpdateHeader.notificationSettings: object expected");
            message.notificationSettings = $root.NotificationSettings.fromObject(object.notificationSettings);
        }
        if (object.currentServerTime != null)
            if ($util.Long)
                (message.currentServerTime = $util.Long.fromValue(object.currentServerTime)).unsigned = true;
            else if (typeof object.currentServerTime === "string")
                message.currentServerTime = parseInt(object.currentServerTime, 10);
            else if (typeof object.currentServerTime === "number")
                message.currentServerTime = object.currentServerTime;
            else if (typeof object.currentServerTime === "object")
                message.currentServerTime = new $util.LongBits(object.currentServerTime.low >>> 0, object.currentServerTime.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a StateUpdateHeader message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StateUpdateHeader
     * @static
     * @param {StateUpdateHeader} message StateUpdateHeader
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StateUpdateHeader.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.activeClientState = options.enums === String ? "ACTIVE_CLIENT_STATE_NO_ACTIVE" : 0;
            object.requestTraceId = "";
            object.notificationSettings = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.currentServerTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.currentServerTime = options.longs === String ? "0" : 0;
        }
        if (message.activeClientState != null && message.hasOwnProperty("activeClientState"))
            object.activeClientState = options.enums === String ? $root.ActiveClientState[message.activeClientState] : message.activeClientState;
        if (message.requestTraceId != null && message.hasOwnProperty("requestTraceId"))
            object.requestTraceId = message.requestTraceId;
        if (message.notificationSettings != null && message.hasOwnProperty("notificationSettings"))
            object.notificationSettings = $root.NotificationSettings.toObject(message.notificationSettings, options);
        if (message.currentServerTime != null && message.hasOwnProperty("currentServerTime"))
            if (typeof message.currentServerTime === "number")
                object.currentServerTime = options.longs === String ? String(message.currentServerTime) : message.currentServerTime;
            else
                object.currentServerTime = options.longs === String ? $util.Long.prototype.toString.call(message.currentServerTime) : options.longs === Number ? new $util.LongBits(message.currentServerTime.low >>> 0, message.currentServerTime.high >>> 0).toNumber(true) : message.currentServerTime;
        return object;
    };

    /**
     * Converts this StateUpdateHeader to JSON.
     * @function toJSON
     * @memberof StateUpdateHeader
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StateUpdateHeader.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return StateUpdateHeader;
})();

export const BatchUpdate = $root.BatchUpdate = (() => {

    /**
     * Properties of a BatchUpdate.
     * @exports IBatchUpdate
     * @interface IBatchUpdate
     * @property {Array.<IStateUpdate>|null} [stateUpdate] BatchUpdate stateUpdate
     */

    /**
     * Constructs a new BatchUpdate.
     * @exports BatchUpdate
     * @classdesc Represents a BatchUpdate.
     * @implements IBatchUpdate
     * @constructor
     * @param {IBatchUpdate=} [properties] Properties to set
     */
    function BatchUpdate(properties) {
        this.stateUpdate = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BatchUpdate stateUpdate.
     * @member {Array.<IStateUpdate>} stateUpdate
     * @memberof BatchUpdate
     * @instance
     */
    BatchUpdate.prototype.stateUpdate = $util.emptyArray;

    /**
     * Creates a new BatchUpdate instance using the specified properties.
     * @function create
     * @memberof BatchUpdate
     * @static
     * @param {IBatchUpdate=} [properties] Properties to set
     * @returns {BatchUpdate} BatchUpdate instance
     */
    BatchUpdate.create = function create(properties) {
        return new BatchUpdate(properties);
    };

    /**
     * Encodes the specified BatchUpdate message. Does not implicitly {@link BatchUpdate.verify|verify} messages.
     * @function encode
     * @memberof BatchUpdate
     * @static
     * @param {IBatchUpdate} message BatchUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BatchUpdate.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.stateUpdate != null && message.stateUpdate.length)
            for (let i = 0; i < message.stateUpdate.length; ++i)
                $root.StateUpdate.encode(message.stateUpdate[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BatchUpdate message, length delimited. Does not implicitly {@link BatchUpdate.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BatchUpdate
     * @static
     * @param {IBatchUpdate} message BatchUpdate message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BatchUpdate.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BatchUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof BatchUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BatchUpdate} BatchUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BatchUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BatchUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.stateUpdate && message.stateUpdate.length))
                    message.stateUpdate = [];
                message.stateUpdate.push($root.StateUpdate.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BatchUpdate message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BatchUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BatchUpdate} BatchUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BatchUpdate.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BatchUpdate message.
     * @function verify
     * @memberof BatchUpdate
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BatchUpdate.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.stateUpdate != null && message.hasOwnProperty("stateUpdate")) {
            if (!Array.isArray(message.stateUpdate))
                return "stateUpdate: array expected";
            for (let i = 0; i < message.stateUpdate.length; ++i) {
                let error = $root.StateUpdate.verify(message.stateUpdate[i]);
                if (error)
                    return "stateUpdate." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BatchUpdate message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BatchUpdate
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BatchUpdate} BatchUpdate
     */
    BatchUpdate.fromObject = function fromObject(object) {
        if (object instanceof $root.BatchUpdate)
            return object;
        let message = new $root.BatchUpdate();
        if (object.stateUpdate) {
            if (!Array.isArray(object.stateUpdate))
                throw TypeError(".BatchUpdate.stateUpdate: array expected");
            message.stateUpdate = [];
            for (let i = 0; i < object.stateUpdate.length; ++i) {
                if (typeof object.stateUpdate[i] !== "object")
                    throw TypeError(".BatchUpdate.stateUpdate: object expected");
                message.stateUpdate[i] = $root.StateUpdate.fromObject(object.stateUpdate[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BatchUpdate message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BatchUpdate
     * @static
     * @param {BatchUpdate} message BatchUpdate
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BatchUpdate.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.stateUpdate = [];
        if (message.stateUpdate && message.stateUpdate.length) {
            object.stateUpdate = [];
            for (let j = 0; j < message.stateUpdate.length; ++j)
                object.stateUpdate[j] = $root.StateUpdate.toObject(message.stateUpdate[j], options);
        }
        return object;
    };

    /**
     * Converts this BatchUpdate to JSON.
     * @function toJSON
     * @memberof BatchUpdate
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BatchUpdate.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BatchUpdate;
})();

export const ConversationNotification = $root.ConversationNotification = (() => {

    /**
     * Properties of a ConversationNotification.
     * @exports IConversationNotification
     * @interface IConversationNotification
     * @property {IConversation|null} [conversation] ConversationNotification conversation
     */

    /**
     * Constructs a new ConversationNotification.
     * @exports ConversationNotification
     * @classdesc Represents a ConversationNotification.
     * @implements IConversationNotification
     * @constructor
     * @param {IConversationNotification=} [properties] Properties to set
     */
    function ConversationNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationNotification conversation.
     * @member {IConversation|null|undefined} conversation
     * @memberof ConversationNotification
     * @instance
     */
    ConversationNotification.prototype.conversation = null;

    /**
     * Creates a new ConversationNotification instance using the specified properties.
     * @function create
     * @memberof ConversationNotification
     * @static
     * @param {IConversationNotification=} [properties] Properties to set
     * @returns {ConversationNotification} ConversationNotification instance
     */
    ConversationNotification.create = function create(properties) {
        return new ConversationNotification(properties);
    };

    /**
     * Encodes the specified ConversationNotification message. Does not implicitly {@link ConversationNotification.verify|verify} messages.
     * @function encode
     * @memberof ConversationNotification
     * @static
     * @param {IConversationNotification} message ConversationNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            $root.Conversation.encode(message.conversation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConversationNotification message, length delimited. Does not implicitly {@link ConversationNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationNotification
     * @static
     * @param {IConversationNotification} message ConversationNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationNotification message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationNotification} ConversationNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversation = $root.Conversation.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationNotification} ConversationNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationNotification message.
     * @function verify
     * @memberof ConversationNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversation != null && message.hasOwnProperty("conversation")) {
            let error = $root.Conversation.verify(message.conversation);
            if (error)
                return "conversation." + error;
        }
        return null;
    };

    /**
     * Creates a ConversationNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationNotification} ConversationNotification
     */
    ConversationNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationNotification)
            return object;
        let message = new $root.ConversationNotification();
        if (object.conversation != null) {
            if (typeof object.conversation !== "object")
                throw TypeError(".ConversationNotification.conversation: object expected");
            message.conversation = $root.Conversation.fromObject(object.conversation);
        }
        return message;
    };

    /**
     * Creates a plain object from a ConversationNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationNotification
     * @static
     * @param {ConversationNotification} message ConversationNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.conversation = null;
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            object.conversation = $root.Conversation.toObject(message.conversation, options);
        return object;
    };

    /**
     * Converts this ConversationNotification to JSON.
     * @function toJSON
     * @memberof ConversationNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationNotification;
})();

export const EventNotification = $root.EventNotification = (() => {

    /**
     * Properties of an EventNotification.
     * @exports IEventNotification
     * @interface IEventNotification
     * @property {IEvent|null} [event] EventNotification event
     */

    /**
     * Constructs a new EventNotification.
     * @exports EventNotification
     * @classdesc Represents an EventNotification.
     * @implements IEventNotification
     * @constructor
     * @param {IEventNotification=} [properties] Properties to set
     */
    function EventNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EventNotification event.
     * @member {IEvent|null|undefined} event
     * @memberof EventNotification
     * @instance
     */
    EventNotification.prototype.event = null;

    /**
     * Creates a new EventNotification instance using the specified properties.
     * @function create
     * @memberof EventNotification
     * @static
     * @param {IEventNotification=} [properties] Properties to set
     * @returns {EventNotification} EventNotification instance
     */
    EventNotification.create = function create(properties) {
        return new EventNotification(properties);
    };

    /**
     * Encodes the specified EventNotification message. Does not implicitly {@link EventNotification.verify|verify} messages.
     * @function encode
     * @memberof EventNotification
     * @static
     * @param {IEventNotification} message EventNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.event != null && message.hasOwnProperty("event"))
            $root.Event.encode(message.event, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EventNotification message, length delimited. Does not implicitly {@link EventNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EventNotification
     * @static
     * @param {IEventNotification} message EventNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EventNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EventNotification message from the specified reader or buffer.
     * @function decode
     * @memberof EventNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EventNotification} EventNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EventNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.event = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EventNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EventNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EventNotification} EventNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EventNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EventNotification message.
     * @function verify
     * @memberof EventNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EventNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.event != null && message.hasOwnProperty("event")) {
            let error = $root.Event.verify(message.event);
            if (error)
                return "event." + error;
        }
        return null;
    };

    /**
     * Creates an EventNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EventNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EventNotification} EventNotification
     */
    EventNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.EventNotification)
            return object;
        let message = new $root.EventNotification();
        if (object.event != null) {
            if (typeof object.event !== "object")
                throw TypeError(".EventNotification.event: object expected");
            message.event = $root.Event.fromObject(object.event);
        }
        return message;
    };

    /**
     * Creates a plain object from an EventNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EventNotification
     * @static
     * @param {EventNotification} message EventNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EventNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.event = null;
        if (message.event != null && message.hasOwnProperty("event"))
            object.event = $root.Event.toObject(message.event, options);
        return object;
    };

    /**
     * Converts this EventNotification to JSON.
     * @function toJSON
     * @memberof EventNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EventNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EventNotification;
})();

export const SetFocusNotification = $root.SetFocusNotification = (() => {

    /**
     * Properties of a SetFocusNotification.
     * @exports ISetFocusNotification
     * @interface ISetFocusNotification
     * @property {IConversationId|null} [conversationId] SetFocusNotification conversationId
     * @property {IParticipantId|null} [senderId] SetFocusNotification senderId
     * @property {number|Long|null} [timestamp] SetFocusNotification timestamp
     * @property {FocusType|null} [type] SetFocusNotification type
     * @property {FocusDevice|null} [device] SetFocusNotification device
     */

    /**
     * Constructs a new SetFocusNotification.
     * @exports SetFocusNotification
     * @classdesc Represents a SetFocusNotification.
     * @implements ISetFocusNotification
     * @constructor
     * @param {ISetFocusNotification=} [properties] Properties to set
     */
    function SetFocusNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetFocusNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetFocusNotification
     * @instance
     */
    SetFocusNotification.prototype.conversationId = null;

    /**
     * SetFocusNotification senderId.
     * @member {IParticipantId|null|undefined} senderId
     * @memberof SetFocusNotification
     * @instance
     */
    SetFocusNotification.prototype.senderId = null;

    /**
     * SetFocusNotification timestamp.
     * @member {number|Long} timestamp
     * @memberof SetFocusNotification
     * @instance
     */
    SetFocusNotification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SetFocusNotification type.
     * @member {FocusType} type
     * @memberof SetFocusNotification
     * @instance
     */
    SetFocusNotification.prototype.type = 0;

    /**
     * SetFocusNotification device.
     * @member {FocusDevice} device
     * @memberof SetFocusNotification
     * @instance
     */
    SetFocusNotification.prototype.device = 0;

    /**
     * Creates a new SetFocusNotification instance using the specified properties.
     * @function create
     * @memberof SetFocusNotification
     * @static
     * @param {ISetFocusNotification=} [properties] Properties to set
     * @returns {SetFocusNotification} SetFocusNotification instance
     */
    SetFocusNotification.create = function create(properties) {
        return new SetFocusNotification(properties);
    };

    /**
     * Encodes the specified SetFocusNotification message. Does not implicitly {@link SetFocusNotification.verify|verify} messages.
     * @function encode
     * @memberof SetFocusNotification
     * @static
     * @param {ISetFocusNotification} message SetFocusNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            $root.ParticipantId.encode(message.senderId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
        if (message.device != null && message.hasOwnProperty("device"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.device);
        return writer;
    };

    /**
     * Encodes the specified SetFocusNotification message, length delimited. Does not implicitly {@link SetFocusNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetFocusNotification
     * @static
     * @param {ISetFocusNotification} message SetFocusNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetFocusNotification message from the specified reader or buffer.
     * @function decode
     * @memberof SetFocusNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetFocusNotification} SetFocusNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetFocusNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.senderId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 3:
                message.timestamp = reader.uint64();
                break;
            case 4:
                message.type = reader.int32();
                break;
            case 5:
                message.device = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetFocusNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetFocusNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetFocusNotification} SetFocusNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetFocusNotification message.
     * @function verify
     * @memberof SetFocusNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetFocusNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.senderId != null && message.hasOwnProperty("senderId")) {
            let error = $root.ParticipantId.verify(message.senderId);
            if (error)
                return "senderId." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.device != null && message.hasOwnProperty("device"))
            switch (message.device) {
            default:
                return "device: enum value expected";
            case 0:
            case 20:
            case 300:
                break;
            }
        return null;
    };

    /**
     * Creates a SetFocusNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetFocusNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetFocusNotification} SetFocusNotification
     */
    SetFocusNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.SetFocusNotification)
            return object;
        let message = new $root.SetFocusNotification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetFocusNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.senderId != null) {
            if (typeof object.senderId !== "object")
                throw TypeError(".SetFocusNotification.senderId: object expected");
            message.senderId = $root.ParticipantId.fromObject(object.senderId);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        switch (object.type) {
        case "FOCUS_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "FOCUS_TYPE_FOCUSED":
        case 1:
            message.type = 1;
            break;
        case "FOCUS_TYPE_UNFOCUSED":
        case 2:
            message.type = 2;
            break;
        }
        switch (object.device) {
        case "FOCUS_DEVICE_UNSPECIFIED":
        case 0:
            message.device = 0;
            break;
        case "FOCUS_DEVICE_DESKTOP":
        case 20:
            message.device = 20;
            break;
        case "FOCUS_DEVICE_MOBILE":
        case 300:
            message.device = 300;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SetFocusNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetFocusNotification
     * @static
     * @param {SetFocusNotification} message SetFocusNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetFocusNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.senderId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.type = options.enums === String ? "FOCUS_TYPE_UNKNOWN" : 0;
            object.device = options.enums === String ? "FOCUS_DEVICE_UNSPECIFIED" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            object.senderId = $root.ParticipantId.toObject(message.senderId, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.FocusType[message.type] : message.type;
        if (message.device != null && message.hasOwnProperty("device"))
            object.device = options.enums === String ? $root.FocusDevice[message.device] : message.device;
        return object;
    };

    /**
     * Converts this SetFocusNotification to JSON.
     * @function toJSON
     * @memberof SetFocusNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetFocusNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetFocusNotification;
})();

export const SetTypingNotification = $root.SetTypingNotification = (() => {

    /**
     * Properties of a SetTypingNotification.
     * @exports ISetTypingNotification
     * @interface ISetTypingNotification
     * @property {IConversationId|null} [conversationId] SetTypingNotification conversationId
     * @property {IParticipantId|null} [senderId] SetTypingNotification senderId
     * @property {number|Long|null} [timestamp] SetTypingNotification timestamp
     * @property {TypingType|null} [type] SetTypingNotification type
     */

    /**
     * Constructs a new SetTypingNotification.
     * @exports SetTypingNotification
     * @classdesc Represents a SetTypingNotification.
     * @implements ISetTypingNotification
     * @constructor
     * @param {ISetTypingNotification=} [properties] Properties to set
     */
    function SetTypingNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetTypingNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetTypingNotification
     * @instance
     */
    SetTypingNotification.prototype.conversationId = null;

    /**
     * SetTypingNotification senderId.
     * @member {IParticipantId|null|undefined} senderId
     * @memberof SetTypingNotification
     * @instance
     */
    SetTypingNotification.prototype.senderId = null;

    /**
     * SetTypingNotification timestamp.
     * @member {number|Long} timestamp
     * @memberof SetTypingNotification
     * @instance
     */
    SetTypingNotification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SetTypingNotification type.
     * @member {TypingType} type
     * @memberof SetTypingNotification
     * @instance
     */
    SetTypingNotification.prototype.type = 0;

    /**
     * Creates a new SetTypingNotification instance using the specified properties.
     * @function create
     * @memberof SetTypingNotification
     * @static
     * @param {ISetTypingNotification=} [properties] Properties to set
     * @returns {SetTypingNotification} SetTypingNotification instance
     */
    SetTypingNotification.create = function create(properties) {
        return new SetTypingNotification(properties);
    };

    /**
     * Encodes the specified SetTypingNotification message. Does not implicitly {@link SetTypingNotification.verify|verify} messages.
     * @function encode
     * @memberof SetTypingNotification
     * @static
     * @param {ISetTypingNotification} message SetTypingNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            $root.ParticipantId.encode(message.senderId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified SetTypingNotification message, length delimited. Does not implicitly {@link SetTypingNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetTypingNotification
     * @static
     * @param {ISetTypingNotification} message SetTypingNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetTypingNotification message from the specified reader or buffer.
     * @function decode
     * @memberof SetTypingNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetTypingNotification} SetTypingNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetTypingNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.senderId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 3:
                message.timestamp = reader.uint64();
                break;
            case 4:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetTypingNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetTypingNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetTypingNotification} SetTypingNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetTypingNotification message.
     * @function verify
     * @memberof SetTypingNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetTypingNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.senderId != null && message.hasOwnProperty("senderId")) {
            let error = $root.ParticipantId.verify(message.senderId);
            if (error)
                return "senderId." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
        return null;
    };

    /**
     * Creates a SetTypingNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetTypingNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetTypingNotification} SetTypingNotification
     */
    SetTypingNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.SetTypingNotification)
            return object;
        let message = new $root.SetTypingNotification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetTypingNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.senderId != null) {
            if (typeof object.senderId !== "object")
                throw TypeError(".SetTypingNotification.senderId: object expected");
            message.senderId = $root.ParticipantId.fromObject(object.senderId);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        switch (object.type) {
        case "TYPING_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "TYPING_TYPE_STARTED":
        case 1:
            message.type = 1;
            break;
        case "TYPING_TYPE_PAUSED":
        case 2:
            message.type = 2;
            break;
        case "TYPING_TYPE_STOPPED":
        case 3:
            message.type = 3;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SetTypingNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetTypingNotification
     * @static
     * @param {SetTypingNotification} message SetTypingNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetTypingNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.senderId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
            object.type = options.enums === String ? "TYPING_TYPE_UNKNOWN" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            object.senderId = $root.ParticipantId.toObject(message.senderId, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.TypingType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this SetTypingNotification to JSON.
     * @function toJSON
     * @memberof SetTypingNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetTypingNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetTypingNotification;
})();

export const SetConversationNotificationLevelNotification = $root.SetConversationNotificationLevelNotification = (() => {

    /**
     * Properties of a SetConversationNotificationLevelNotification.
     * @exports ISetConversationNotificationLevelNotification
     * @interface ISetConversationNotificationLevelNotification
     * @property {IConversationId|null} [conversationId] SetConversationNotificationLevelNotification conversationId
     * @property {NotificationLevel|null} [level] SetConversationNotificationLevelNotification level
     * @property {number|Long|null} [timestamp] SetConversationNotificationLevelNotification timestamp
     */

    /**
     * Constructs a new SetConversationNotificationLevelNotification.
     * @exports SetConversationNotificationLevelNotification
     * @classdesc Represents a SetConversationNotificationLevelNotification.
     * @implements ISetConversationNotificationLevelNotification
     * @constructor
     * @param {ISetConversationNotificationLevelNotification=} [properties] Properties to set
     */
    function SetConversationNotificationLevelNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetConversationNotificationLevelNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetConversationNotificationLevelNotification
     * @instance
     */
    SetConversationNotificationLevelNotification.prototype.conversationId = null;

    /**
     * SetConversationNotificationLevelNotification level.
     * @member {NotificationLevel} level
     * @memberof SetConversationNotificationLevelNotification
     * @instance
     */
    SetConversationNotificationLevelNotification.prototype.level = 0;

    /**
     * SetConversationNotificationLevelNotification timestamp.
     * @member {number|Long} timestamp
     * @memberof SetConversationNotificationLevelNotification
     * @instance
     */
    SetConversationNotificationLevelNotification.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SetConversationNotificationLevelNotification instance using the specified properties.
     * @function create
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {ISetConversationNotificationLevelNotification=} [properties] Properties to set
     * @returns {SetConversationNotificationLevelNotification} SetConversationNotificationLevelNotification instance
     */
    SetConversationNotificationLevelNotification.create = function create(properties) {
        return new SetConversationNotificationLevelNotification(properties);
    };

    /**
     * Encodes the specified SetConversationNotificationLevelNotification message. Does not implicitly {@link SetConversationNotificationLevelNotification.verify|verify} messages.
     * @function encode
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {ISetConversationNotificationLevelNotification} message SetConversationNotificationLevelNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timestamp);
        return writer;
    };

    /**
     * Encodes the specified SetConversationNotificationLevelNotification message, length delimited. Does not implicitly {@link SetConversationNotificationLevelNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {ISetConversationNotificationLevelNotification} message SetConversationNotificationLevelNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetConversationNotificationLevelNotification message from the specified reader or buffer.
     * @function decode
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetConversationNotificationLevelNotification} SetConversationNotificationLevelNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetConversationNotificationLevelNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.level = reader.int32();
                break;
            case 4:
                message.timestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetConversationNotificationLevelNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetConversationNotificationLevelNotification} SetConversationNotificationLevelNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetConversationNotificationLevelNotification message.
     * @function verify
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetConversationNotificationLevelNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.level != null && message.hasOwnProperty("level"))
            switch (message.level) {
            default:
                return "level: enum value expected";
            case 0:
            case 10:
            case 30:
                break;
            }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a SetConversationNotificationLevelNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetConversationNotificationLevelNotification} SetConversationNotificationLevelNotification
     */
    SetConversationNotificationLevelNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.SetConversationNotificationLevelNotification)
            return object;
        let message = new $root.SetConversationNotificationLevelNotification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetConversationNotificationLevelNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.level) {
        case "NOTIFICATION_LEVEL_UNKNOWN":
        case 0:
            message.level = 0;
            break;
        case "NOTIFICATION_LEVEL_QUIET":
        case 10:
            message.level = 10;
            break;
        case "NOTIFICATION_LEVEL_RING":
        case 30:
            message.level = 30;
            break;
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SetConversationNotificationLevelNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetConversationNotificationLevelNotification
     * @static
     * @param {SetConversationNotificationLevelNotification} message SetConversationNotificationLevelNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetConversationNotificationLevelNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.level = options.enums === String ? "NOTIFICATION_LEVEL_UNKNOWN" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = options.enums === String ? $root.NotificationLevel[message.level] : message.level;
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        return object;
    };

    /**
     * Converts this SetConversationNotificationLevelNotification to JSON.
     * @function toJSON
     * @memberof SetConversationNotificationLevelNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetConversationNotificationLevelNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetConversationNotificationLevelNotification;
})();

export const ReplyToInviteNotification = $root.ReplyToInviteNotification = (() => {

    /**
     * Properties of a ReplyToInviteNotification.
     * @exports IReplyToInviteNotification
     * @interface IReplyToInviteNotification
     * @property {IConversationId|null} [conversationId] ReplyToInviteNotification conversationId
     * @property {ReplyToInviteType|null} [type] ReplyToInviteNotification type
     */

    /**
     * Constructs a new ReplyToInviteNotification.
     * @exports ReplyToInviteNotification
     * @classdesc Represents a ReplyToInviteNotification.
     * @implements IReplyToInviteNotification
     * @constructor
     * @param {IReplyToInviteNotification=} [properties] Properties to set
     */
    function ReplyToInviteNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ReplyToInviteNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof ReplyToInviteNotification
     * @instance
     */
    ReplyToInviteNotification.prototype.conversationId = null;

    /**
     * ReplyToInviteNotification type.
     * @member {ReplyToInviteType} type
     * @memberof ReplyToInviteNotification
     * @instance
     */
    ReplyToInviteNotification.prototype.type = 0;

    /**
     * Creates a new ReplyToInviteNotification instance using the specified properties.
     * @function create
     * @memberof ReplyToInviteNotification
     * @static
     * @param {IReplyToInviteNotification=} [properties] Properties to set
     * @returns {ReplyToInviteNotification} ReplyToInviteNotification instance
     */
    ReplyToInviteNotification.create = function create(properties) {
        return new ReplyToInviteNotification(properties);
    };

    /**
     * Encodes the specified ReplyToInviteNotification message. Does not implicitly {@link ReplyToInviteNotification.verify|verify} messages.
     * @function encode
     * @memberof ReplyToInviteNotification
     * @static
     * @param {IReplyToInviteNotification} message ReplyToInviteNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReplyToInviteNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified ReplyToInviteNotification message, length delimited. Does not implicitly {@link ReplyToInviteNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ReplyToInviteNotification
     * @static
     * @param {IReplyToInviteNotification} message ReplyToInviteNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ReplyToInviteNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ReplyToInviteNotification message from the specified reader or buffer.
     * @function decode
     * @memberof ReplyToInviteNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ReplyToInviteNotification} ReplyToInviteNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReplyToInviteNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReplyToInviteNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ReplyToInviteNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ReplyToInviteNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ReplyToInviteNotification} ReplyToInviteNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ReplyToInviteNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ReplyToInviteNotification message.
     * @function verify
     * @memberof ReplyToInviteNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ReplyToInviteNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a ReplyToInviteNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ReplyToInviteNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ReplyToInviteNotification} ReplyToInviteNotification
     */
    ReplyToInviteNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.ReplyToInviteNotification)
            return object;
        let message = new $root.ReplyToInviteNotification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".ReplyToInviteNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.type) {
        case "REPLY_TO_INVITE_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "REPLY_TO_INVITE_TYPE_ACCEPT":
        case 1:
            message.type = 1;
            break;
        case "REPLY_TO_INVITE_TYPE_DECLINE":
        case 2:
            message.type = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ReplyToInviteNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ReplyToInviteNotification
     * @static
     * @param {ReplyToInviteNotification} message ReplyToInviteNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ReplyToInviteNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.type = options.enums === String ? "REPLY_TO_INVITE_TYPE_UNKNOWN" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.ReplyToInviteType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this ReplyToInviteNotification to JSON.
     * @function toJSON
     * @memberof ReplyToInviteNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ReplyToInviteNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ReplyToInviteNotification;
})();

export const WatermarkNotification = $root.WatermarkNotification = (() => {

    /**
     * Properties of a WatermarkNotification.
     * @exports IWatermarkNotification
     * @interface IWatermarkNotification
     * @property {IParticipantId|null} [senderId] WatermarkNotification senderId
     * @property {IConversationId|null} [conversationId] WatermarkNotification conversationId
     * @property {number|Long|null} [latestReadTimestamp] WatermarkNotification latestReadTimestamp
     */

    /**
     * Constructs a new WatermarkNotification.
     * @exports WatermarkNotification
     * @classdesc Represents a WatermarkNotification.
     * @implements IWatermarkNotification
     * @constructor
     * @param {IWatermarkNotification=} [properties] Properties to set
     */
    function WatermarkNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WatermarkNotification senderId.
     * @member {IParticipantId|null|undefined} senderId
     * @memberof WatermarkNotification
     * @instance
     */
    WatermarkNotification.prototype.senderId = null;

    /**
     * WatermarkNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof WatermarkNotification
     * @instance
     */
    WatermarkNotification.prototype.conversationId = null;

    /**
     * WatermarkNotification latestReadTimestamp.
     * @member {number|Long} latestReadTimestamp
     * @memberof WatermarkNotification
     * @instance
     */
    WatermarkNotification.prototype.latestReadTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new WatermarkNotification instance using the specified properties.
     * @function create
     * @memberof WatermarkNotification
     * @static
     * @param {IWatermarkNotification=} [properties] Properties to set
     * @returns {WatermarkNotification} WatermarkNotification instance
     */
    WatermarkNotification.create = function create(properties) {
        return new WatermarkNotification(properties);
    };

    /**
     * Encodes the specified WatermarkNotification message. Does not implicitly {@link WatermarkNotification.verify|verify} messages.
     * @function encode
     * @memberof WatermarkNotification
     * @static
     * @param {IWatermarkNotification} message WatermarkNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WatermarkNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            $root.ParticipantId.encode(message.senderId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.latestReadTimestamp);
        return writer;
    };

    /**
     * Encodes the specified WatermarkNotification message, length delimited. Does not implicitly {@link WatermarkNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WatermarkNotification
     * @static
     * @param {IWatermarkNotification} message WatermarkNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WatermarkNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WatermarkNotification message from the specified reader or buffer.
     * @function decode
     * @memberof WatermarkNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WatermarkNotification} WatermarkNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WatermarkNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WatermarkNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.senderId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.latestReadTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WatermarkNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WatermarkNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WatermarkNotification} WatermarkNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WatermarkNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WatermarkNotification message.
     * @function verify
     * @memberof WatermarkNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WatermarkNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.senderId != null && message.hasOwnProperty("senderId")) {
            let error = $root.ParticipantId.verify(message.senderId);
            if (error)
                return "senderId." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            if (!$util.isInteger(message.latestReadTimestamp) && !(message.latestReadTimestamp && $util.isInteger(message.latestReadTimestamp.low) && $util.isInteger(message.latestReadTimestamp.high)))
                return "latestReadTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a WatermarkNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WatermarkNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WatermarkNotification} WatermarkNotification
     */
    WatermarkNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.WatermarkNotification)
            return object;
        let message = new $root.WatermarkNotification();
        if (object.senderId != null) {
            if (typeof object.senderId !== "object")
                throw TypeError(".WatermarkNotification.senderId: object expected");
            message.senderId = $root.ParticipantId.fromObject(object.senderId);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".WatermarkNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.latestReadTimestamp != null)
            if ($util.Long)
                (message.latestReadTimestamp = $util.Long.fromValue(object.latestReadTimestamp)).unsigned = true;
            else if (typeof object.latestReadTimestamp === "string")
                message.latestReadTimestamp = parseInt(object.latestReadTimestamp, 10);
            else if (typeof object.latestReadTimestamp === "number")
                message.latestReadTimestamp = object.latestReadTimestamp;
            else if (typeof object.latestReadTimestamp === "object")
                message.latestReadTimestamp = new $util.LongBits(object.latestReadTimestamp.low >>> 0, object.latestReadTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a WatermarkNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WatermarkNotification
     * @static
     * @param {WatermarkNotification} message WatermarkNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WatermarkNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.senderId = null;
            object.conversationId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.latestReadTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.latestReadTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            object.senderId = $root.ParticipantId.toObject(message.senderId, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.latestReadTimestamp != null && message.hasOwnProperty("latestReadTimestamp"))
            if (typeof message.latestReadTimestamp === "number")
                object.latestReadTimestamp = options.longs === String ? String(message.latestReadTimestamp) : message.latestReadTimestamp;
            else
                object.latestReadTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.latestReadTimestamp) : options.longs === Number ? new $util.LongBits(message.latestReadTimestamp.low >>> 0, message.latestReadTimestamp.high >>> 0).toNumber(true) : message.latestReadTimestamp;
        return object;
    };

    /**
     * Converts this WatermarkNotification to JSON.
     * @function toJSON
     * @memberof WatermarkNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WatermarkNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return WatermarkNotification;
})();

export const ConversationViewModification = $root.ConversationViewModification = (() => {

    /**
     * Properties of a ConversationViewModification.
     * @exports IConversationViewModification
     * @interface IConversationViewModification
     * @property {IConversationId|null} [conversationId] ConversationViewModification conversationId
     * @property {ConversationView|null} [oldView] ConversationViewModification oldView
     * @property {ConversationView|null} [newView] ConversationViewModification newView
     */

    /**
     * Constructs a new ConversationViewModification.
     * @exports ConversationViewModification
     * @classdesc Represents a ConversationViewModification.
     * @implements IConversationViewModification
     * @constructor
     * @param {IConversationViewModification=} [properties] Properties to set
     */
    function ConversationViewModification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationViewModification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof ConversationViewModification
     * @instance
     */
    ConversationViewModification.prototype.conversationId = null;

    /**
     * ConversationViewModification oldView.
     * @member {ConversationView} oldView
     * @memberof ConversationViewModification
     * @instance
     */
    ConversationViewModification.prototype.oldView = 0;

    /**
     * ConversationViewModification newView.
     * @member {ConversationView} newView
     * @memberof ConversationViewModification
     * @instance
     */
    ConversationViewModification.prototype.newView = 0;

    /**
     * Creates a new ConversationViewModification instance using the specified properties.
     * @function create
     * @memberof ConversationViewModification
     * @static
     * @param {IConversationViewModification=} [properties] Properties to set
     * @returns {ConversationViewModification} ConversationViewModification instance
     */
    ConversationViewModification.create = function create(properties) {
        return new ConversationViewModification(properties);
    };

    /**
     * Encodes the specified ConversationViewModification message. Does not implicitly {@link ConversationViewModification.verify|verify} messages.
     * @function encode
     * @memberof ConversationViewModification
     * @static
     * @param {IConversationViewModification} message ConversationViewModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationViewModification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.oldView != null && message.hasOwnProperty("oldView"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.oldView);
        if (message.newView != null && message.hasOwnProperty("newView"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.newView);
        return writer;
    };

    /**
     * Encodes the specified ConversationViewModification message, length delimited. Does not implicitly {@link ConversationViewModification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationViewModification
     * @static
     * @param {IConversationViewModification} message ConversationViewModification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationViewModification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationViewModification message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationViewModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationViewModification} ConversationViewModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationViewModification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationViewModification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.oldView = reader.int32();
                break;
            case 3:
                message.newView = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationViewModification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationViewModification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationViewModification} ConversationViewModification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationViewModification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationViewModification message.
     * @function verify
     * @memberof ConversationViewModification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationViewModification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.oldView != null && message.hasOwnProperty("oldView"))
            switch (message.oldView) {
            default:
                return "oldView: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.newView != null && message.hasOwnProperty("newView"))
            switch (message.newView) {
            default:
                return "newView: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a ConversationViewModification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationViewModification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationViewModification} ConversationViewModification
     */
    ConversationViewModification.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationViewModification)
            return object;
        let message = new $root.ConversationViewModification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".ConversationViewModification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.oldView) {
        case "CONVERSATION_VIEW_UNKNOWN":
        case 0:
            message.oldView = 0;
            break;
        case "CONVERSATION_VIEW_INBOX":
        case 1:
            message.oldView = 1;
            break;
        case "CONVERSATION_VIEW_ARCHIVED":
        case 2:
            message.oldView = 2;
            break;
        }
        switch (object.newView) {
        case "CONVERSATION_VIEW_UNKNOWN":
        case 0:
            message.newView = 0;
            break;
        case "CONVERSATION_VIEW_INBOX":
        case 1:
            message.newView = 1;
            break;
        case "CONVERSATION_VIEW_ARCHIVED":
        case 2:
            message.newView = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a ConversationViewModification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationViewModification
     * @static
     * @param {ConversationViewModification} message ConversationViewModification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationViewModification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.oldView = options.enums === String ? "CONVERSATION_VIEW_UNKNOWN" : 0;
            object.newView = options.enums === String ? "CONVERSATION_VIEW_UNKNOWN" : 0;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.oldView != null && message.hasOwnProperty("oldView"))
            object.oldView = options.enums === String ? $root.ConversationView[message.oldView] : message.oldView;
        if (message.newView != null && message.hasOwnProperty("newView"))
            object.newView = options.enums === String ? $root.ConversationView[message.newView] : message.newView;
        return object;
    };

    /**
     * Converts this ConversationViewModification to JSON.
     * @function toJSON
     * @memberof ConversationViewModification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationViewModification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationViewModification;
})();

export const EasterEggNotification = $root.EasterEggNotification = (() => {

    /**
     * Properties of an EasterEggNotification.
     * @exports IEasterEggNotification
     * @interface IEasterEggNotification
     * @property {IParticipantId|null} [senderId] EasterEggNotification senderId
     * @property {IConversationId|null} [conversationId] EasterEggNotification conversationId
     * @property {IEasterEgg|null} [easterEgg] EasterEggNotification easterEgg
     */

    /**
     * Constructs a new EasterEggNotification.
     * @exports EasterEggNotification
     * @classdesc Represents an EasterEggNotification.
     * @implements IEasterEggNotification
     * @constructor
     * @param {IEasterEggNotification=} [properties] Properties to set
     */
    function EasterEggNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EasterEggNotification senderId.
     * @member {IParticipantId|null|undefined} senderId
     * @memberof EasterEggNotification
     * @instance
     */
    EasterEggNotification.prototype.senderId = null;

    /**
     * EasterEggNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof EasterEggNotification
     * @instance
     */
    EasterEggNotification.prototype.conversationId = null;

    /**
     * EasterEggNotification easterEgg.
     * @member {IEasterEgg|null|undefined} easterEgg
     * @memberof EasterEggNotification
     * @instance
     */
    EasterEggNotification.prototype.easterEgg = null;

    /**
     * Creates a new EasterEggNotification instance using the specified properties.
     * @function create
     * @memberof EasterEggNotification
     * @static
     * @param {IEasterEggNotification=} [properties] Properties to set
     * @returns {EasterEggNotification} EasterEggNotification instance
     */
    EasterEggNotification.create = function create(properties) {
        return new EasterEggNotification(properties);
    };

    /**
     * Encodes the specified EasterEggNotification message. Does not implicitly {@link EasterEggNotification.verify|verify} messages.
     * @function encode
     * @memberof EasterEggNotification
     * @static
     * @param {IEasterEggNotification} message EasterEggNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            $root.ParticipantId.encode(message.senderId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg"))
            $root.EasterEgg.encode(message.easterEgg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EasterEggNotification message, length delimited. Does not implicitly {@link EasterEggNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EasterEggNotification
     * @static
     * @param {IEasterEggNotification} message EasterEggNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EasterEggNotification message from the specified reader or buffer.
     * @function decode
     * @memberof EasterEggNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EasterEggNotification} EasterEggNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EasterEggNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.senderId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.easterEgg = $root.EasterEgg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EasterEggNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EasterEggNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EasterEggNotification} EasterEggNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EasterEggNotification message.
     * @function verify
     * @memberof EasterEggNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EasterEggNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.senderId != null && message.hasOwnProperty("senderId")) {
            let error = $root.ParticipantId.verify(message.senderId);
            if (error)
                return "senderId." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg")) {
            let error = $root.EasterEgg.verify(message.easterEgg);
            if (error)
                return "easterEgg." + error;
        }
        return null;
    };

    /**
     * Creates an EasterEggNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EasterEggNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EasterEggNotification} EasterEggNotification
     */
    EasterEggNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.EasterEggNotification)
            return object;
        let message = new $root.EasterEggNotification();
        if (object.senderId != null) {
            if (typeof object.senderId !== "object")
                throw TypeError(".EasterEggNotification.senderId: object expected");
            message.senderId = $root.ParticipantId.fromObject(object.senderId);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".EasterEggNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.easterEgg != null) {
            if (typeof object.easterEgg !== "object")
                throw TypeError(".EasterEggNotification.easterEgg: object expected");
            message.easterEgg = $root.EasterEgg.fromObject(object.easterEgg);
        }
        return message;
    };

    /**
     * Creates a plain object from an EasterEggNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EasterEggNotification
     * @static
     * @param {EasterEggNotification} message EasterEggNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EasterEggNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.senderId = null;
            object.conversationId = null;
            object.easterEgg = null;
        }
        if (message.senderId != null && message.hasOwnProperty("senderId"))
            object.senderId = $root.ParticipantId.toObject(message.senderId, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg"))
            object.easterEgg = $root.EasterEgg.toObject(message.easterEgg, options);
        return object;
    };

    /**
     * Converts this EasterEggNotification to JSON.
     * @function toJSON
     * @memberof EasterEggNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EasterEggNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EasterEggNotification;
})();

export const SelfPresenceNotification = $root.SelfPresenceNotification = (() => {

    /**
     * Properties of a SelfPresenceNotification.
     * @exports ISelfPresenceNotification
     * @interface ISelfPresenceNotification
     * @property {IClientPresenceState|null} [clientPresenceState] SelfPresenceNotification clientPresenceState
     * @property {IDoNotDisturbSetting|null} [doNotDisturbSetting] SelfPresenceNotification doNotDisturbSetting
     * @property {IDesktopOffSetting|null} [desktopOffSetting] SelfPresenceNotification desktopOffSetting
     * @property {IDesktopOffState|null} [desktopOffState] SelfPresenceNotification desktopOffState
     * @property {IMoodState|null} [moodState] SelfPresenceNotification moodState
     */

    /**
     * Constructs a new SelfPresenceNotification.
     * @exports SelfPresenceNotification
     * @classdesc Represents a SelfPresenceNotification.
     * @implements ISelfPresenceNotification
     * @constructor
     * @param {ISelfPresenceNotification=} [properties] Properties to set
     */
    function SelfPresenceNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SelfPresenceNotification clientPresenceState.
     * @member {IClientPresenceState|null|undefined} clientPresenceState
     * @memberof SelfPresenceNotification
     * @instance
     */
    SelfPresenceNotification.prototype.clientPresenceState = null;

    /**
     * SelfPresenceNotification doNotDisturbSetting.
     * @member {IDoNotDisturbSetting|null|undefined} doNotDisturbSetting
     * @memberof SelfPresenceNotification
     * @instance
     */
    SelfPresenceNotification.prototype.doNotDisturbSetting = null;

    /**
     * SelfPresenceNotification desktopOffSetting.
     * @member {IDesktopOffSetting|null|undefined} desktopOffSetting
     * @memberof SelfPresenceNotification
     * @instance
     */
    SelfPresenceNotification.prototype.desktopOffSetting = null;

    /**
     * SelfPresenceNotification desktopOffState.
     * @member {IDesktopOffState|null|undefined} desktopOffState
     * @memberof SelfPresenceNotification
     * @instance
     */
    SelfPresenceNotification.prototype.desktopOffState = null;

    /**
     * SelfPresenceNotification moodState.
     * @member {IMoodState|null|undefined} moodState
     * @memberof SelfPresenceNotification
     * @instance
     */
    SelfPresenceNotification.prototype.moodState = null;

    /**
     * Creates a new SelfPresenceNotification instance using the specified properties.
     * @function create
     * @memberof SelfPresenceNotification
     * @static
     * @param {ISelfPresenceNotification=} [properties] Properties to set
     * @returns {SelfPresenceNotification} SelfPresenceNotification instance
     */
    SelfPresenceNotification.create = function create(properties) {
        return new SelfPresenceNotification(properties);
    };

    /**
     * Encodes the specified SelfPresenceNotification message. Does not implicitly {@link SelfPresenceNotification.verify|verify} messages.
     * @function encode
     * @memberof SelfPresenceNotification
     * @static
     * @param {ISelfPresenceNotification} message SelfPresenceNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfPresenceNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.clientPresenceState != null && message.hasOwnProperty("clientPresenceState"))
            $root.ClientPresenceState.encode(message.clientPresenceState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.doNotDisturbSetting != null && message.hasOwnProperty("doNotDisturbSetting"))
            $root.DoNotDisturbSetting.encode(message.doNotDisturbSetting, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            $root.DesktopOffSetting.encode(message.desktopOffSetting, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState"))
            $root.DesktopOffState.encode(message.desktopOffState, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.moodState != null && message.hasOwnProperty("moodState"))
            $root.MoodState.encode(message.moodState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SelfPresenceNotification message, length delimited. Does not implicitly {@link SelfPresenceNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SelfPresenceNotification
     * @static
     * @param {ISelfPresenceNotification} message SelfPresenceNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SelfPresenceNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SelfPresenceNotification message from the specified reader or buffer.
     * @function decode
     * @memberof SelfPresenceNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SelfPresenceNotification} SelfPresenceNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfPresenceNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SelfPresenceNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.clientPresenceState = $root.ClientPresenceState.decode(reader, reader.uint32());
                break;
            case 3:
                message.doNotDisturbSetting = $root.DoNotDisturbSetting.decode(reader, reader.uint32());
                break;
            case 4:
                message.desktopOffSetting = $root.DesktopOffSetting.decode(reader, reader.uint32());
                break;
            case 5:
                message.desktopOffState = $root.DesktopOffState.decode(reader, reader.uint32());
                break;
            case 6:
                message.moodState = $root.MoodState.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SelfPresenceNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SelfPresenceNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SelfPresenceNotification} SelfPresenceNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SelfPresenceNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SelfPresenceNotification message.
     * @function verify
     * @memberof SelfPresenceNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SelfPresenceNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.clientPresenceState != null && message.hasOwnProperty("clientPresenceState")) {
            let error = $root.ClientPresenceState.verify(message.clientPresenceState);
            if (error)
                return "clientPresenceState." + error;
        }
        if (message.doNotDisturbSetting != null && message.hasOwnProperty("doNotDisturbSetting")) {
            let error = $root.DoNotDisturbSetting.verify(message.doNotDisturbSetting);
            if (error)
                return "doNotDisturbSetting." + error;
        }
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting")) {
            let error = $root.DesktopOffSetting.verify(message.desktopOffSetting);
            if (error)
                return "desktopOffSetting." + error;
        }
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState")) {
            let error = $root.DesktopOffState.verify(message.desktopOffState);
            if (error)
                return "desktopOffState." + error;
        }
        if (message.moodState != null && message.hasOwnProperty("moodState")) {
            let error = $root.MoodState.verify(message.moodState);
            if (error)
                return "moodState." + error;
        }
        return null;
    };

    /**
     * Creates a SelfPresenceNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SelfPresenceNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SelfPresenceNotification} SelfPresenceNotification
     */
    SelfPresenceNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.SelfPresenceNotification)
            return object;
        let message = new $root.SelfPresenceNotification();
        if (object.clientPresenceState != null) {
            if (typeof object.clientPresenceState !== "object")
                throw TypeError(".SelfPresenceNotification.clientPresenceState: object expected");
            message.clientPresenceState = $root.ClientPresenceState.fromObject(object.clientPresenceState);
        }
        if (object.doNotDisturbSetting != null) {
            if (typeof object.doNotDisturbSetting !== "object")
                throw TypeError(".SelfPresenceNotification.doNotDisturbSetting: object expected");
            message.doNotDisturbSetting = $root.DoNotDisturbSetting.fromObject(object.doNotDisturbSetting);
        }
        if (object.desktopOffSetting != null) {
            if (typeof object.desktopOffSetting !== "object")
                throw TypeError(".SelfPresenceNotification.desktopOffSetting: object expected");
            message.desktopOffSetting = $root.DesktopOffSetting.fromObject(object.desktopOffSetting);
        }
        if (object.desktopOffState != null) {
            if (typeof object.desktopOffState !== "object")
                throw TypeError(".SelfPresenceNotification.desktopOffState: object expected");
            message.desktopOffState = $root.DesktopOffState.fromObject(object.desktopOffState);
        }
        if (object.moodState != null) {
            if (typeof object.moodState !== "object")
                throw TypeError(".SelfPresenceNotification.moodState: object expected");
            message.moodState = $root.MoodState.fromObject(object.moodState);
        }
        return message;
    };

    /**
     * Creates a plain object from a SelfPresenceNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SelfPresenceNotification
     * @static
     * @param {SelfPresenceNotification} message SelfPresenceNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SelfPresenceNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.clientPresenceState = null;
            object.doNotDisturbSetting = null;
            object.desktopOffSetting = null;
            object.desktopOffState = null;
            object.moodState = null;
        }
        if (message.clientPresenceState != null && message.hasOwnProperty("clientPresenceState"))
            object.clientPresenceState = $root.ClientPresenceState.toObject(message.clientPresenceState, options);
        if (message.doNotDisturbSetting != null && message.hasOwnProperty("doNotDisturbSetting"))
            object.doNotDisturbSetting = $root.DoNotDisturbSetting.toObject(message.doNotDisturbSetting, options);
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            object.desktopOffSetting = $root.DesktopOffSetting.toObject(message.desktopOffSetting, options);
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState"))
            object.desktopOffState = $root.DesktopOffState.toObject(message.desktopOffState, options);
        if (message.moodState != null && message.hasOwnProperty("moodState"))
            object.moodState = $root.MoodState.toObject(message.moodState, options);
        return object;
    };

    /**
     * Converts this SelfPresenceNotification to JSON.
     * @function toJSON
     * @memberof SelfPresenceNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SelfPresenceNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SelfPresenceNotification;
})();

export const DeleteActionNotification = $root.DeleteActionNotification = (() => {

    /**
     * Properties of a DeleteActionNotification.
     * @exports IDeleteActionNotification
     * @interface IDeleteActionNotification
     * @property {IConversationId|null} [conversationId] DeleteActionNotification conversationId
     * @property {IDeleteAction|null} [deleteAction] DeleteActionNotification deleteAction
     */

    /**
     * Constructs a new DeleteActionNotification.
     * @exports DeleteActionNotification
     * @classdesc Represents a DeleteActionNotification.
     * @implements IDeleteActionNotification
     * @constructor
     * @param {IDeleteActionNotification=} [properties] Properties to set
     */
    function DeleteActionNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteActionNotification conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof DeleteActionNotification
     * @instance
     */
    DeleteActionNotification.prototype.conversationId = null;

    /**
     * DeleteActionNotification deleteAction.
     * @member {IDeleteAction|null|undefined} deleteAction
     * @memberof DeleteActionNotification
     * @instance
     */
    DeleteActionNotification.prototype.deleteAction = null;

    /**
     * Creates a new DeleteActionNotification instance using the specified properties.
     * @function create
     * @memberof DeleteActionNotification
     * @static
     * @param {IDeleteActionNotification=} [properties] Properties to set
     * @returns {DeleteActionNotification} DeleteActionNotification instance
     */
    DeleteActionNotification.create = function create(properties) {
        return new DeleteActionNotification(properties);
    };

    /**
     * Encodes the specified DeleteActionNotification message. Does not implicitly {@link DeleteActionNotification.verify|verify} messages.
     * @function encode
     * @memberof DeleteActionNotification
     * @static
     * @param {IDeleteActionNotification} message DeleteActionNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteActionNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction"))
            $root.DeleteAction.encode(message.deleteAction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DeleteActionNotification message, length delimited. Does not implicitly {@link DeleteActionNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteActionNotification
     * @static
     * @param {IDeleteActionNotification} message DeleteActionNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteActionNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteActionNotification message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteActionNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteActionNotification} DeleteActionNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteActionNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteActionNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 2:
                message.deleteAction = $root.DeleteAction.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteActionNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteActionNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteActionNotification} DeleteActionNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteActionNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteActionNotification message.
     * @function verify
     * @memberof DeleteActionNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteActionNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction")) {
            let error = $root.DeleteAction.verify(message.deleteAction);
            if (error)
                return "deleteAction." + error;
        }
        return null;
    };

    /**
     * Creates a DeleteActionNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteActionNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteActionNotification} DeleteActionNotification
     */
    DeleteActionNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteActionNotification)
            return object;
        let message = new $root.DeleteActionNotification();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".DeleteActionNotification.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.deleteAction != null) {
            if (typeof object.deleteAction !== "object")
                throw TypeError(".DeleteActionNotification.deleteAction: object expected");
            message.deleteAction = $root.DeleteAction.fromObject(object.deleteAction);
        }
        return message;
    };

    /**
     * Creates a plain object from a DeleteActionNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteActionNotification
     * @static
     * @param {DeleteActionNotification} message DeleteActionNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteActionNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.conversationId = null;
            object.deleteAction = null;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction"))
            object.deleteAction = $root.DeleteAction.toObject(message.deleteAction, options);
        return object;
    };

    /**
     * Converts this DeleteActionNotification to JSON.
     * @function toJSON
     * @memberof DeleteActionNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteActionNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteActionNotification;
})();

export const PresenceNotification = $root.PresenceNotification = (() => {

    /**
     * Properties of a PresenceNotification.
     * @exports IPresenceNotification
     * @interface IPresenceNotification
     * @property {Array.<IPresenceResult>|null} [presence] PresenceNotification presence
     */

    /**
     * Constructs a new PresenceNotification.
     * @exports PresenceNotification
     * @classdesc Represents a PresenceNotification.
     * @implements IPresenceNotification
     * @constructor
     * @param {IPresenceNotification=} [properties] Properties to set
     */
    function PresenceNotification(properties) {
        this.presence = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PresenceNotification presence.
     * @member {Array.<IPresenceResult>} presence
     * @memberof PresenceNotification
     * @instance
     */
    PresenceNotification.prototype.presence = $util.emptyArray;

    /**
     * Creates a new PresenceNotification instance using the specified properties.
     * @function create
     * @memberof PresenceNotification
     * @static
     * @param {IPresenceNotification=} [properties] Properties to set
     * @returns {PresenceNotification} PresenceNotification instance
     */
    PresenceNotification.create = function create(properties) {
        return new PresenceNotification(properties);
    };

    /**
     * Encodes the specified PresenceNotification message. Does not implicitly {@link PresenceNotification.verify|verify} messages.
     * @function encode
     * @memberof PresenceNotification
     * @static
     * @param {IPresenceNotification} message PresenceNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.presence != null && message.presence.length)
            for (let i = 0; i < message.presence.length; ++i)
                $root.PresenceResult.encode(message.presence[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PresenceNotification message, length delimited. Does not implicitly {@link PresenceNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PresenceNotification
     * @static
     * @param {IPresenceNotification} message PresenceNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PresenceNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PresenceNotification message from the specified reader or buffer.
     * @function decode
     * @memberof PresenceNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PresenceNotification} PresenceNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PresenceNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.presence && message.presence.length))
                    message.presence = [];
                message.presence.push($root.PresenceResult.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PresenceNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PresenceNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PresenceNotification} PresenceNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PresenceNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PresenceNotification message.
     * @function verify
     * @memberof PresenceNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PresenceNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.presence != null && message.hasOwnProperty("presence")) {
            if (!Array.isArray(message.presence))
                return "presence: array expected";
            for (let i = 0; i < message.presence.length; ++i) {
                let error = $root.PresenceResult.verify(message.presence[i]);
                if (error)
                    return "presence." + error;
            }
        }
        return null;
    };

    /**
     * Creates a PresenceNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PresenceNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PresenceNotification} PresenceNotification
     */
    PresenceNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.PresenceNotification)
            return object;
        let message = new $root.PresenceNotification();
        if (object.presence) {
            if (!Array.isArray(object.presence))
                throw TypeError(".PresenceNotification.presence: array expected");
            message.presence = [];
            for (let i = 0; i < object.presence.length; ++i) {
                if (typeof object.presence[i] !== "object")
                    throw TypeError(".PresenceNotification.presence: object expected");
                message.presence[i] = $root.PresenceResult.fromObject(object.presence[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a PresenceNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PresenceNotification
     * @static
     * @param {PresenceNotification} message PresenceNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PresenceNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.presence = [];
        if (message.presence && message.presence.length) {
            object.presence = [];
            for (let j = 0; j < message.presence.length; ++j)
                object.presence[j] = $root.PresenceResult.toObject(message.presence[j], options);
        }
        return object;
    };

    /**
     * Converts this PresenceNotification to JSON.
     * @function toJSON
     * @memberof PresenceNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PresenceNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return PresenceNotification;
})();

export const BlockNotification = $root.BlockNotification = (() => {

    /**
     * Properties of a BlockNotification.
     * @exports IBlockNotification
     * @interface IBlockNotification
     * @property {Array.<IBlockStateChange>|null} [blockStateChange] BlockNotification blockStateChange
     */

    /**
     * Constructs a new BlockNotification.
     * @exports BlockNotification
     * @classdesc Represents a BlockNotification.
     * @implements IBlockNotification
     * @constructor
     * @param {IBlockNotification=} [properties] Properties to set
     */
    function BlockNotification(properties) {
        this.blockStateChange = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * BlockNotification blockStateChange.
     * @member {Array.<IBlockStateChange>} blockStateChange
     * @memberof BlockNotification
     * @instance
     */
    BlockNotification.prototype.blockStateChange = $util.emptyArray;

    /**
     * Creates a new BlockNotification instance using the specified properties.
     * @function create
     * @memberof BlockNotification
     * @static
     * @param {IBlockNotification=} [properties] Properties to set
     * @returns {BlockNotification} BlockNotification instance
     */
    BlockNotification.create = function create(properties) {
        return new BlockNotification(properties);
    };

    /**
     * Encodes the specified BlockNotification message. Does not implicitly {@link BlockNotification.verify|verify} messages.
     * @function encode
     * @memberof BlockNotification
     * @static
     * @param {IBlockNotification} message BlockNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BlockNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.blockStateChange != null && message.blockStateChange.length)
            for (let i = 0; i < message.blockStateChange.length; ++i)
                $root.BlockStateChange.encode(message.blockStateChange[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified BlockNotification message, length delimited. Does not implicitly {@link BlockNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof BlockNotification
     * @static
     * @param {IBlockNotification} message BlockNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    BlockNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a BlockNotification message from the specified reader or buffer.
     * @function decode
     * @memberof BlockNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {BlockNotification} BlockNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BlockNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BlockNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.blockStateChange && message.blockStateChange.length))
                    message.blockStateChange = [];
                message.blockStateChange.push($root.BlockStateChange.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a BlockNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof BlockNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {BlockNotification} BlockNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    BlockNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a BlockNotification message.
     * @function verify
     * @memberof BlockNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    BlockNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.blockStateChange != null && message.hasOwnProperty("blockStateChange")) {
            if (!Array.isArray(message.blockStateChange))
                return "blockStateChange: array expected";
            for (let i = 0; i < message.blockStateChange.length; ++i) {
                let error = $root.BlockStateChange.verify(message.blockStateChange[i]);
                if (error)
                    return "blockStateChange." + error;
            }
        }
        return null;
    };

    /**
     * Creates a BlockNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof BlockNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {BlockNotification} BlockNotification
     */
    BlockNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.BlockNotification)
            return object;
        let message = new $root.BlockNotification();
        if (object.blockStateChange) {
            if (!Array.isArray(object.blockStateChange))
                throw TypeError(".BlockNotification.blockStateChange: array expected");
            message.blockStateChange = [];
            for (let i = 0; i < object.blockStateChange.length; ++i) {
                if (typeof object.blockStateChange[i] !== "object")
                    throw TypeError(".BlockNotification.blockStateChange: object expected");
                message.blockStateChange[i] = $root.BlockStateChange.fromObject(object.blockStateChange[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a BlockNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof BlockNotification
     * @static
     * @param {BlockNotification} message BlockNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    BlockNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.blockStateChange = [];
        if (message.blockStateChange && message.blockStateChange.length) {
            object.blockStateChange = [];
            for (let j = 0; j < message.blockStateChange.length; ++j)
                object.blockStateChange[j] = $root.BlockStateChange.toObject(message.blockStateChange[j], options);
        }
        return object;
    };

    /**
     * Converts this BlockNotification to JSON.
     * @function toJSON
     * @memberof BlockNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    BlockNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return BlockNotification;
})();

export const SetNotificationSettingNotification = $root.SetNotificationSettingNotification = (() => {

    /**
     * Properties of a SetNotificationSettingNotification.
     * @exports ISetNotificationSettingNotification
     * @interface ISetNotificationSettingNotification
     * @property {Array.<IConfigurationBit>|null} [configurationBit] SetNotificationSettingNotification configurationBit
     * @property {IDesktopSoundSetting|null} [desktopSoundSetting] SetNotificationSettingNotification desktopSoundSetting
     */

    /**
     * Constructs a new SetNotificationSettingNotification.
     * @exports SetNotificationSettingNotification
     * @classdesc Represents a SetNotificationSettingNotification.
     * @implements ISetNotificationSettingNotification
     * @constructor
     * @param {ISetNotificationSettingNotification=} [properties] Properties to set
     */
    function SetNotificationSettingNotification(properties) {
        this.configurationBit = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetNotificationSettingNotification configurationBit.
     * @member {Array.<IConfigurationBit>} configurationBit
     * @memberof SetNotificationSettingNotification
     * @instance
     */
    SetNotificationSettingNotification.prototype.configurationBit = $util.emptyArray;

    /**
     * SetNotificationSettingNotification desktopSoundSetting.
     * @member {IDesktopSoundSetting|null|undefined} desktopSoundSetting
     * @memberof SetNotificationSettingNotification
     * @instance
     */
    SetNotificationSettingNotification.prototype.desktopSoundSetting = null;

    /**
     * Creates a new SetNotificationSettingNotification instance using the specified properties.
     * @function create
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {ISetNotificationSettingNotification=} [properties] Properties to set
     * @returns {SetNotificationSettingNotification} SetNotificationSettingNotification instance
     */
    SetNotificationSettingNotification.create = function create(properties) {
        return new SetNotificationSettingNotification(properties);
    };

    /**
     * Encodes the specified SetNotificationSettingNotification message. Does not implicitly {@link SetNotificationSettingNotification.verify|verify} messages.
     * @function encode
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {ISetNotificationSettingNotification} message SetNotificationSettingNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetNotificationSettingNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.configurationBit != null && message.configurationBit.length)
            for (let i = 0; i < message.configurationBit.length; ++i)
                $root.ConfigurationBit.encode(message.configurationBit[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting"))
            $root.DesktopSoundSetting.encode(message.desktopSoundSetting, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetNotificationSettingNotification message, length delimited. Does not implicitly {@link SetNotificationSettingNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {ISetNotificationSettingNotification} message SetNotificationSettingNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetNotificationSettingNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetNotificationSettingNotification message from the specified reader or buffer.
     * @function decode
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetNotificationSettingNotification} SetNotificationSettingNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetNotificationSettingNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetNotificationSettingNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.configurationBit && message.configurationBit.length))
                    message.configurationBit = [];
                message.configurationBit.push($root.ConfigurationBit.decode(reader, reader.uint32()));
                break;
            case 2:
                message.desktopSoundSetting = $root.DesktopSoundSetting.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetNotificationSettingNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetNotificationSettingNotification} SetNotificationSettingNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetNotificationSettingNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetNotificationSettingNotification message.
     * @function verify
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetNotificationSettingNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.configurationBit != null && message.hasOwnProperty("configurationBit")) {
            if (!Array.isArray(message.configurationBit))
                return "configurationBit: array expected";
            for (let i = 0; i < message.configurationBit.length; ++i) {
                let error = $root.ConfigurationBit.verify(message.configurationBit[i]);
                if (error)
                    return "configurationBit." + error;
            }
        }
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting")) {
            let error = $root.DesktopSoundSetting.verify(message.desktopSoundSetting);
            if (error)
                return "desktopSoundSetting." + error;
        }
        return null;
    };

    /**
     * Creates a SetNotificationSettingNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetNotificationSettingNotification} SetNotificationSettingNotification
     */
    SetNotificationSettingNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.SetNotificationSettingNotification)
            return object;
        let message = new $root.SetNotificationSettingNotification();
        if (object.configurationBit) {
            if (!Array.isArray(object.configurationBit))
                throw TypeError(".SetNotificationSettingNotification.configurationBit: array expected");
            message.configurationBit = [];
            for (let i = 0; i < object.configurationBit.length; ++i) {
                if (typeof object.configurationBit[i] !== "object")
                    throw TypeError(".SetNotificationSettingNotification.configurationBit: object expected");
                message.configurationBit[i] = $root.ConfigurationBit.fromObject(object.configurationBit[i]);
            }
        }
        if (object.desktopSoundSetting != null) {
            if (typeof object.desktopSoundSetting !== "object")
                throw TypeError(".SetNotificationSettingNotification.desktopSoundSetting: object expected");
            message.desktopSoundSetting = $root.DesktopSoundSetting.fromObject(object.desktopSoundSetting);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetNotificationSettingNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetNotificationSettingNotification
     * @static
     * @param {SetNotificationSettingNotification} message SetNotificationSettingNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetNotificationSettingNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.configurationBit = [];
        if (options.defaults)
            object.desktopSoundSetting = null;
        if (message.configurationBit && message.configurationBit.length) {
            object.configurationBit = [];
            for (let j = 0; j < message.configurationBit.length; ++j)
                object.configurationBit[j] = $root.ConfigurationBit.toObject(message.configurationBit[j], options);
        }
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting"))
            object.desktopSoundSetting = $root.DesktopSoundSetting.toObject(message.desktopSoundSetting, options);
        return object;
    };

    /**
     * Converts this SetNotificationSettingNotification to JSON.
     * @function toJSON
     * @memberof SetNotificationSettingNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetNotificationSettingNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetNotificationSettingNotification;
})();

export const RichPresenceEnabledStateNotification = $root.RichPresenceEnabledStateNotification = (() => {

    /**
     * Properties of a RichPresenceEnabledStateNotification.
     * @exports IRichPresenceEnabledStateNotification
     * @interface IRichPresenceEnabledStateNotification
     * @property {Array.<IRichPresenceEnabledState>|null} [richPresenceEnabledState] RichPresenceEnabledStateNotification richPresenceEnabledState
     */

    /**
     * Constructs a new RichPresenceEnabledStateNotification.
     * @exports RichPresenceEnabledStateNotification
     * @classdesc Represents a RichPresenceEnabledStateNotification.
     * @implements IRichPresenceEnabledStateNotification
     * @constructor
     * @param {IRichPresenceEnabledStateNotification=} [properties] Properties to set
     */
    function RichPresenceEnabledStateNotification(properties) {
        this.richPresenceEnabledState = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RichPresenceEnabledStateNotification richPresenceEnabledState.
     * @member {Array.<IRichPresenceEnabledState>} richPresenceEnabledState
     * @memberof RichPresenceEnabledStateNotification
     * @instance
     */
    RichPresenceEnabledStateNotification.prototype.richPresenceEnabledState = $util.emptyArray;

    /**
     * Creates a new RichPresenceEnabledStateNotification instance using the specified properties.
     * @function create
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {IRichPresenceEnabledStateNotification=} [properties] Properties to set
     * @returns {RichPresenceEnabledStateNotification} RichPresenceEnabledStateNotification instance
     */
    RichPresenceEnabledStateNotification.create = function create(properties) {
        return new RichPresenceEnabledStateNotification(properties);
    };

    /**
     * Encodes the specified RichPresenceEnabledStateNotification message. Does not implicitly {@link RichPresenceEnabledStateNotification.verify|verify} messages.
     * @function encode
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {IRichPresenceEnabledStateNotification} message RichPresenceEnabledStateNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceEnabledStateNotification.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.richPresenceEnabledState != null && message.richPresenceEnabledState.length)
            for (let i = 0; i < message.richPresenceEnabledState.length; ++i)
                $root.RichPresenceEnabledState.encode(message.richPresenceEnabledState[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RichPresenceEnabledStateNotification message, length delimited. Does not implicitly {@link RichPresenceEnabledStateNotification.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {IRichPresenceEnabledStateNotification} message RichPresenceEnabledStateNotification message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RichPresenceEnabledStateNotification.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RichPresenceEnabledStateNotification message from the specified reader or buffer.
     * @function decode
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RichPresenceEnabledStateNotification} RichPresenceEnabledStateNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceEnabledStateNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RichPresenceEnabledStateNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                if (!(message.richPresenceEnabledState && message.richPresenceEnabledState.length))
                    message.richPresenceEnabledState = [];
                message.richPresenceEnabledState.push($root.RichPresenceEnabledState.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RichPresenceEnabledStateNotification message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RichPresenceEnabledStateNotification} RichPresenceEnabledStateNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RichPresenceEnabledStateNotification.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RichPresenceEnabledStateNotification message.
     * @function verify
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RichPresenceEnabledStateNotification.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.richPresenceEnabledState != null && message.hasOwnProperty("richPresenceEnabledState")) {
            if (!Array.isArray(message.richPresenceEnabledState))
                return "richPresenceEnabledState: array expected";
            for (let i = 0; i < message.richPresenceEnabledState.length; ++i) {
                let error = $root.RichPresenceEnabledState.verify(message.richPresenceEnabledState[i]);
                if (error)
                    return "richPresenceEnabledState." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RichPresenceEnabledStateNotification message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RichPresenceEnabledStateNotification} RichPresenceEnabledStateNotification
     */
    RichPresenceEnabledStateNotification.fromObject = function fromObject(object) {
        if (object instanceof $root.RichPresenceEnabledStateNotification)
            return object;
        let message = new $root.RichPresenceEnabledStateNotification();
        if (object.richPresenceEnabledState) {
            if (!Array.isArray(object.richPresenceEnabledState))
                throw TypeError(".RichPresenceEnabledStateNotification.richPresenceEnabledState: array expected");
            message.richPresenceEnabledState = [];
            for (let i = 0; i < object.richPresenceEnabledState.length; ++i) {
                if (typeof object.richPresenceEnabledState[i] !== "object")
                    throw TypeError(".RichPresenceEnabledStateNotification.richPresenceEnabledState: object expected");
                message.richPresenceEnabledState[i] = $root.RichPresenceEnabledState.fromObject(object.richPresenceEnabledState[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RichPresenceEnabledStateNotification message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RichPresenceEnabledStateNotification
     * @static
     * @param {RichPresenceEnabledStateNotification} message RichPresenceEnabledStateNotification
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RichPresenceEnabledStateNotification.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.richPresenceEnabledState = [];
        if (message.richPresenceEnabledState && message.richPresenceEnabledState.length) {
            object.richPresenceEnabledState = [];
            for (let j = 0; j < message.richPresenceEnabledState.length; ++j)
                object.richPresenceEnabledState[j] = $root.RichPresenceEnabledState.toObject(message.richPresenceEnabledState[j], options);
        }
        return object;
    };

    /**
     * Converts this RichPresenceEnabledStateNotification to JSON.
     * @function toJSON
     * @memberof RichPresenceEnabledStateNotification
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RichPresenceEnabledStateNotification.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RichPresenceEnabledStateNotification;
})();

export const ConversationSpec = $root.ConversationSpec = (() => {

    /**
     * Properties of a ConversationSpec.
     * @exports IConversationSpec
     * @interface IConversationSpec
     * @property {IConversationId|null} [conversationId] ConversationSpec conversationId
     */

    /**
     * Constructs a new ConversationSpec.
     * @exports ConversationSpec
     * @classdesc Represents a ConversationSpec.
     * @implements IConversationSpec
     * @constructor
     * @param {IConversationSpec=} [properties] Properties to set
     */
    function ConversationSpec(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConversationSpec conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof ConversationSpec
     * @instance
     */
    ConversationSpec.prototype.conversationId = null;

    /**
     * Creates a new ConversationSpec instance using the specified properties.
     * @function create
     * @memberof ConversationSpec
     * @static
     * @param {IConversationSpec=} [properties] Properties to set
     * @returns {ConversationSpec} ConversationSpec instance
     */
    ConversationSpec.create = function create(properties) {
        return new ConversationSpec(properties);
    };

    /**
     * Encodes the specified ConversationSpec message. Does not implicitly {@link ConversationSpec.verify|verify} messages.
     * @function encode
     * @memberof ConversationSpec
     * @static
     * @param {IConversationSpec} message ConversationSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationSpec.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConversationSpec message, length delimited. Does not implicitly {@link ConversationSpec.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConversationSpec
     * @static
     * @param {IConversationSpec} message ConversationSpec message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConversationSpec.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConversationSpec message from the specified reader or buffer.
     * @function decode
     * @memberof ConversationSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConversationSpec} ConversationSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationSpec.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConversationSpec();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConversationSpec message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConversationSpec
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConversationSpec} ConversationSpec
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConversationSpec.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConversationSpec message.
     * @function verify
     * @memberof ConversationSpec
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConversationSpec.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        return null;
    };

    /**
     * Creates a ConversationSpec message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConversationSpec
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConversationSpec} ConversationSpec
     */
    ConversationSpec.fromObject = function fromObject(object) {
        if (object instanceof $root.ConversationSpec)
            return object;
        let message = new $root.ConversationSpec();
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".ConversationSpec.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        return message;
    };

    /**
     * Creates a plain object from a ConversationSpec message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConversationSpec
     * @static
     * @param {ConversationSpec} message ConversationSpec
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConversationSpec.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.conversationId = null;
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        return object;
    };

    /**
     * Converts this ConversationSpec to JSON.
     * @function toJSON
     * @memberof ConversationSpec
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConversationSpec.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ConversationSpec;
})();

/**
 * OffnetworkAddressType enum.
 * @exports OffnetworkAddressType
 * @enum {string}
 * @property {number} OFFNETWORK_ADDRESS_TYPE_UNKNOWN=0 OFFNETWORK_ADDRESS_TYPE_UNKNOWN value
 * @property {number} OFFNETWORK_ADDRESS_TYPE_EMAIL=1 OFFNETWORK_ADDRESS_TYPE_EMAIL value
 */
$root.OffnetworkAddressType = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "OFFNETWORK_ADDRESS_TYPE_UNKNOWN"] = 0;
    values[valuesById[1] = "OFFNETWORK_ADDRESS_TYPE_EMAIL"] = 1;
    return values;
})();

export const OffnetworkAddress = $root.OffnetworkAddress = (() => {

    /**
     * Properties of an OffnetworkAddress.
     * @exports IOffnetworkAddress
     * @interface IOffnetworkAddress
     * @property {OffnetworkAddressType|null} [type] OffnetworkAddress type
     * @property {string|null} [email] OffnetworkAddress email
     */

    /**
     * Constructs a new OffnetworkAddress.
     * @exports OffnetworkAddress
     * @classdesc Represents an OffnetworkAddress.
     * @implements IOffnetworkAddress
     * @constructor
     * @param {IOffnetworkAddress=} [properties] Properties to set
     */
    function OffnetworkAddress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OffnetworkAddress type.
     * @member {OffnetworkAddressType} type
     * @memberof OffnetworkAddress
     * @instance
     */
    OffnetworkAddress.prototype.type = 0;

    /**
     * OffnetworkAddress email.
     * @member {string} email
     * @memberof OffnetworkAddress
     * @instance
     */
    OffnetworkAddress.prototype.email = "";

    /**
     * Creates a new OffnetworkAddress instance using the specified properties.
     * @function create
     * @memberof OffnetworkAddress
     * @static
     * @param {IOffnetworkAddress=} [properties] Properties to set
     * @returns {OffnetworkAddress} OffnetworkAddress instance
     */
    OffnetworkAddress.create = function create(properties) {
        return new OffnetworkAddress(properties);
    };

    /**
     * Encodes the specified OffnetworkAddress message. Does not implicitly {@link OffnetworkAddress.verify|verify} messages.
     * @function encode
     * @memberof OffnetworkAddress
     * @static
     * @param {IOffnetworkAddress} message OffnetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OffnetworkAddress.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.email != null && message.hasOwnProperty("email"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
        return writer;
    };

    /**
     * Encodes the specified OffnetworkAddress message, length delimited. Does not implicitly {@link OffnetworkAddress.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OffnetworkAddress
     * @static
     * @param {IOffnetworkAddress} message OffnetworkAddress message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OffnetworkAddress.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OffnetworkAddress message from the specified reader or buffer.
     * @function decode
     * @memberof OffnetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OffnetworkAddress} OffnetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OffnetworkAddress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OffnetworkAddress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.type = reader.int32();
                break;
            case 3:
                message.email = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OffnetworkAddress message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OffnetworkAddress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OffnetworkAddress} OffnetworkAddress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OffnetworkAddress.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OffnetworkAddress message.
     * @function verify
     * @memberof OffnetworkAddress
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OffnetworkAddress.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.email != null && message.hasOwnProperty("email"))
            if (!$util.isString(message.email))
                return "email: string expected";
        return null;
    };

    /**
     * Creates an OffnetworkAddress message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OffnetworkAddress
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OffnetworkAddress} OffnetworkAddress
     */
    OffnetworkAddress.fromObject = function fromObject(object) {
        if (object instanceof $root.OffnetworkAddress)
            return object;
        let message = new $root.OffnetworkAddress();
        switch (object.type) {
        case "OFFNETWORK_ADDRESS_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "OFFNETWORK_ADDRESS_TYPE_EMAIL":
        case 1:
            message.type = 1;
            break;
        }
        if (object.email != null)
            message.email = String(object.email);
        return message;
    };

    /**
     * Creates a plain object from an OffnetworkAddress message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OffnetworkAddress
     * @static
     * @param {OffnetworkAddress} message OffnetworkAddress
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OffnetworkAddress.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.type = options.enums === String ? "OFFNETWORK_ADDRESS_TYPE_UNKNOWN" : 0;
            object.email = "";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.OffnetworkAddressType[message.type] : message.type;
        if (message.email != null && message.hasOwnProperty("email"))
            object.email = message.email;
        return object;
    };

    /**
     * Converts this OffnetworkAddress to JSON.
     * @function toJSON
     * @memberof OffnetworkAddress
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OffnetworkAddress.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return OffnetworkAddress;
})();

export const EntityResult = $root.EntityResult = (() => {

    /**
     * Properties of an EntityResult.
     * @exports IEntityResult
     * @interface IEntityResult
     * @property {IEntityLookupSpec|null} [lookupSpec] EntityResult lookupSpec
     * @property {Array.<IEntity>|null} [entity] EntityResult entity
     */

    /**
     * Constructs a new EntityResult.
     * @exports EntityResult
     * @classdesc Represents an EntityResult.
     * @implements IEntityResult
     * @constructor
     * @param {IEntityResult=} [properties] Properties to set
     */
    function EntityResult(properties) {
        this.entity = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EntityResult lookupSpec.
     * @member {IEntityLookupSpec|null|undefined} lookupSpec
     * @memberof EntityResult
     * @instance
     */
    EntityResult.prototype.lookupSpec = null;

    /**
     * EntityResult entity.
     * @member {Array.<IEntity>} entity
     * @memberof EntityResult
     * @instance
     */
    EntityResult.prototype.entity = $util.emptyArray;

    /**
     * Creates a new EntityResult instance using the specified properties.
     * @function create
     * @memberof EntityResult
     * @static
     * @param {IEntityResult=} [properties] Properties to set
     * @returns {EntityResult} EntityResult instance
     */
    EntityResult.create = function create(properties) {
        return new EntityResult(properties);
    };

    /**
     * Encodes the specified EntityResult message. Does not implicitly {@link EntityResult.verify|verify} messages.
     * @function encode
     * @memberof EntityResult
     * @static
     * @param {IEntityResult} message EntityResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityResult.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.lookupSpec != null && message.hasOwnProperty("lookupSpec"))
            $root.EntityLookupSpec.encode(message.lookupSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.entity != null && message.entity.length)
            for (let i = 0; i < message.entity.length; ++i)
                $root.Entity.encode(message.entity[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EntityResult message, length delimited. Does not implicitly {@link EntityResult.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EntityResult
     * @static
     * @param {IEntityResult} message EntityResult message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EntityResult.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EntityResult message from the specified reader or buffer.
     * @function decode
     * @memberof EntityResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EntityResult} EntityResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityResult.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EntityResult();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.lookupSpec = $root.EntityLookupSpec.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.entity && message.entity.length))
                    message.entity = [];
                message.entity.push($root.Entity.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EntityResult message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EntityResult
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EntityResult} EntityResult
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EntityResult.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EntityResult message.
     * @function verify
     * @memberof EntityResult
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EntityResult.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.lookupSpec != null && message.hasOwnProperty("lookupSpec")) {
            let error = $root.EntityLookupSpec.verify(message.lookupSpec);
            if (error)
                return "lookupSpec." + error;
        }
        if (message.entity != null && message.hasOwnProperty("entity")) {
            if (!Array.isArray(message.entity))
                return "entity: array expected";
            for (let i = 0; i < message.entity.length; ++i) {
                let error = $root.Entity.verify(message.entity[i]);
                if (error)
                    return "entity." + error;
            }
        }
        return null;
    };

    /**
     * Creates an EntityResult message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EntityResult
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EntityResult} EntityResult
     */
    EntityResult.fromObject = function fromObject(object) {
        if (object instanceof $root.EntityResult)
            return object;
        let message = new $root.EntityResult();
        if (object.lookupSpec != null) {
            if (typeof object.lookupSpec !== "object")
                throw TypeError(".EntityResult.lookupSpec: object expected");
            message.lookupSpec = $root.EntityLookupSpec.fromObject(object.lookupSpec);
        }
        if (object.entity) {
            if (!Array.isArray(object.entity))
                throw TypeError(".EntityResult.entity: array expected");
            message.entity = [];
            for (let i = 0; i < object.entity.length; ++i) {
                if (typeof object.entity[i] !== "object")
                    throw TypeError(".EntityResult.entity: object expected");
                message.entity[i] = $root.Entity.fromObject(object.entity[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an EntityResult message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EntityResult
     * @static
     * @param {EntityResult} message EntityResult
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EntityResult.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.entity = [];
        if (options.defaults)
            object.lookupSpec = null;
        if (message.lookupSpec != null && message.hasOwnProperty("lookupSpec"))
            object.lookupSpec = $root.EntityLookupSpec.toObject(message.lookupSpec, options);
        if (message.entity && message.entity.length) {
            object.entity = [];
            for (let j = 0; j < message.entity.length; ++j)
                object.entity[j] = $root.Entity.toObject(message.entity[j], options);
        }
        return object;
    };

    /**
     * Converts this EntityResult to JSON.
     * @function toJSON
     * @memberof EntityResult
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EntityResult.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EntityResult;
})();

/**
 * GroupLinkSharingStatus enum.
 * @exports GroupLinkSharingStatus
 * @enum {string}
 * @property {number} GROUP_LINK_SHARING_STATUS_UNKNOWN=0 GROUP_LINK_SHARING_STATUS_UNKNOWN value
 * @property {number} GROUP_LINK_SHARING_STATUS_ON=1 GROUP_LINK_SHARING_STATUS_ON value
 * @property {number} GROUP_LINK_SHARING_STATUS_OFF=2 GROUP_LINK_SHARING_STATUS_OFF value
 */
$root.GroupLinkSharingStatus = (function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "GROUP_LINK_SHARING_STATUS_UNKNOWN"] = 0;
    values[valuesById[1] = "GROUP_LINK_SHARING_STATUS_ON"] = 1;
    values[valuesById[2] = "GROUP_LINK_SHARING_STATUS_OFF"] = 2;
    return values;
})();

export const AddUserRequest = $root.AddUserRequest = (() => {

    /**
     * Properties of an AddUserRequest.
     * @exports IAddUserRequest
     * @interface IAddUserRequest
     * @property {IRequestHeader|null} [requestHeader] AddUserRequest requestHeader
     * @property {Array.<IInviteeID>|null} [inviteeId] AddUserRequest inviteeId
     * @property {IEventRequestHeader|null} [eventRequestHeader] AddUserRequest eventRequestHeader
     */

    /**
     * Constructs a new AddUserRequest.
     * @exports AddUserRequest
     * @classdesc Represents an AddUserRequest.
     * @implements IAddUserRequest
     * @constructor
     * @param {IAddUserRequest=} [properties] Properties to set
     */
    function AddUserRequest(properties) {
        this.inviteeId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AddUserRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof AddUserRequest
     * @instance
     */
    AddUserRequest.prototype.requestHeader = null;

    /**
     * AddUserRequest inviteeId.
     * @member {Array.<IInviteeID>} inviteeId
     * @memberof AddUserRequest
     * @instance
     */
    AddUserRequest.prototype.inviteeId = $util.emptyArray;

    /**
     * AddUserRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof AddUserRequest
     * @instance
     */
    AddUserRequest.prototype.eventRequestHeader = null;

    /**
     * Creates a new AddUserRequest instance using the specified properties.
     * @function create
     * @memberof AddUserRequest
     * @static
     * @param {IAddUserRequest=} [properties] Properties to set
     * @returns {AddUserRequest} AddUserRequest instance
     */
    AddUserRequest.create = function create(properties) {
        return new AddUserRequest(properties);
    };

    /**
     * Encodes the specified AddUserRequest message. Does not implicitly {@link AddUserRequest.verify|verify} messages.
     * @function encode
     * @memberof AddUserRequest
     * @static
     * @param {IAddUserRequest} message AddUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddUserRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.inviteeId != null && message.inviteeId.length)
            for (let i = 0; i < message.inviteeId.length; ++i)
                $root.InviteeID.encode(message.inviteeId[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AddUserRequest message, length delimited. Does not implicitly {@link AddUserRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AddUserRequest
     * @static
     * @param {IAddUserRequest} message AddUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AddUserRequest message from the specified reader or buffer.
     * @function decode
     * @memberof AddUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AddUserRequest} AddUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddUserRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddUserRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.inviteeId && message.inviteeId.length))
                    message.inviteeId = [];
                message.inviteeId.push($root.InviteeID.decode(reader, reader.uint32()));
                break;
            case 5:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AddUserRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AddUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AddUserRequest} AddUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddUserRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AddUserRequest message.
     * @function verify
     * @memberof AddUserRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AddUserRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.inviteeId != null && message.hasOwnProperty("inviteeId")) {
            if (!Array.isArray(message.inviteeId))
                return "inviteeId: array expected";
            for (let i = 0; i < message.inviteeId.length; ++i) {
                let error = $root.InviteeID.verify(message.inviteeId[i]);
                if (error)
                    return "inviteeId." + error;
            }
        }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        return null;
    };

    /**
     * Creates an AddUserRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AddUserRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AddUserRequest} AddUserRequest
     */
    AddUserRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.AddUserRequest)
            return object;
        let message = new $root.AddUserRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".AddUserRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.inviteeId) {
            if (!Array.isArray(object.inviteeId))
                throw TypeError(".AddUserRequest.inviteeId: array expected");
            message.inviteeId = [];
            for (let i = 0; i < object.inviteeId.length; ++i) {
                if (typeof object.inviteeId[i] !== "object")
                    throw TypeError(".AddUserRequest.inviteeId: object expected");
                message.inviteeId[i] = $root.InviteeID.fromObject(object.inviteeId[i]);
            }
        }
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".AddUserRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from an AddUserRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AddUserRequest
     * @static
     * @param {AddUserRequest} message AddUserRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AddUserRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.inviteeId = [];
        if (options.defaults) {
            object.requestHeader = null;
            object.eventRequestHeader = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.inviteeId && message.inviteeId.length) {
            object.inviteeId = [];
            for (let j = 0; j < message.inviteeId.length; ++j)
                object.inviteeId[j] = $root.InviteeID.toObject(message.inviteeId[j], options);
        }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        return object;
    };

    /**
     * Converts this AddUserRequest to JSON.
     * @function toJSON
     * @memberof AddUserRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AddUserRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AddUserRequest;
})();

export const AddUserResponse = $root.AddUserResponse = (() => {

    /**
     * Properties of an AddUserResponse.
     * @exports IAddUserResponse
     * @interface IAddUserResponse
     * @property {IResponseHeader|null} [responseHeader] AddUserResponse responseHeader
     * @property {IEvent|null} [createdEvent] AddUserResponse createdEvent
     */

    /**
     * Constructs a new AddUserResponse.
     * @exports AddUserResponse
     * @classdesc Represents an AddUserResponse.
     * @implements IAddUserResponse
     * @constructor
     * @param {IAddUserResponse=} [properties] Properties to set
     */
    function AddUserResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AddUserResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof AddUserResponse
     * @instance
     */
    AddUserResponse.prototype.responseHeader = null;

    /**
     * AddUserResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof AddUserResponse
     * @instance
     */
    AddUserResponse.prototype.createdEvent = null;

    /**
     * Creates a new AddUserResponse instance using the specified properties.
     * @function create
     * @memberof AddUserResponse
     * @static
     * @param {IAddUserResponse=} [properties] Properties to set
     * @returns {AddUserResponse} AddUserResponse instance
     */
    AddUserResponse.create = function create(properties) {
        return new AddUserResponse(properties);
    };

    /**
     * Encodes the specified AddUserResponse message. Does not implicitly {@link AddUserResponse.verify|verify} messages.
     * @function encode
     * @memberof AddUserResponse
     * @static
     * @param {IAddUserResponse} message AddUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddUserResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AddUserResponse message, length delimited. Does not implicitly {@link AddUserResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AddUserResponse
     * @static
     * @param {IAddUserResponse} message AddUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AddUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AddUserResponse message from the specified reader or buffer.
     * @function decode
     * @memberof AddUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AddUserResponse} AddUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddUserResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddUserResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 5:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AddUserResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AddUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AddUserResponse} AddUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AddUserResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AddUserResponse message.
     * @function verify
     * @memberof AddUserResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AddUserResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        return null;
    };

    /**
     * Creates an AddUserResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AddUserResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AddUserResponse} AddUserResponse
     */
    AddUserResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.AddUserResponse)
            return object;
        let message = new $root.AddUserResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".AddUserResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".AddUserResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        return message;
    };

    /**
     * Creates a plain object from an AddUserResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AddUserResponse
     * @static
     * @param {AddUserResponse} message AddUserResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AddUserResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        return object;
    };

    /**
     * Converts this AddUserResponse to JSON.
     * @function toJSON
     * @memberof AddUserResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AddUserResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return AddUserResponse;
})();

export const CreateConversationRequest = $root.CreateConversationRequest = (() => {

    /**
     * Properties of a CreateConversationRequest.
     * @exports ICreateConversationRequest
     * @interface ICreateConversationRequest
     * @property {IRequestHeader|null} [requestHeader] CreateConversationRequest requestHeader
     * @property {ConversationType|null} [type] CreateConversationRequest type
     * @property {number|Long|null} [clientGeneratedId] CreateConversationRequest clientGeneratedId
     * @property {string|null} [name] CreateConversationRequest name
     * @property {Array.<IInviteeID>|null} [inviteeId] CreateConversationRequest inviteeId
     */

    /**
     * Constructs a new CreateConversationRequest.
     * @exports CreateConversationRequest
     * @classdesc Represents a CreateConversationRequest.
     * @implements ICreateConversationRequest
     * @constructor
     * @param {ICreateConversationRequest=} [properties] Properties to set
     */
    function CreateConversationRequest(properties) {
        this.inviteeId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateConversationRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof CreateConversationRequest
     * @instance
     */
    CreateConversationRequest.prototype.requestHeader = null;

    /**
     * CreateConversationRequest type.
     * @member {ConversationType} type
     * @memberof CreateConversationRequest
     * @instance
     */
    CreateConversationRequest.prototype.type = 0;

    /**
     * CreateConversationRequest clientGeneratedId.
     * @member {number|Long} clientGeneratedId
     * @memberof CreateConversationRequest
     * @instance
     */
    CreateConversationRequest.prototype.clientGeneratedId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * CreateConversationRequest name.
     * @member {string} name
     * @memberof CreateConversationRequest
     * @instance
     */
    CreateConversationRequest.prototype.name = "";

    /**
     * CreateConversationRequest inviteeId.
     * @member {Array.<IInviteeID>} inviteeId
     * @memberof CreateConversationRequest
     * @instance
     */
    CreateConversationRequest.prototype.inviteeId = $util.emptyArray;

    /**
     * Creates a new CreateConversationRequest instance using the specified properties.
     * @function create
     * @memberof CreateConversationRequest
     * @static
     * @param {ICreateConversationRequest=} [properties] Properties to set
     * @returns {CreateConversationRequest} CreateConversationRequest instance
     */
    CreateConversationRequest.create = function create(properties) {
        return new CreateConversationRequest(properties);
    };

    /**
     * Encodes the specified CreateConversationRequest message. Does not implicitly {@link CreateConversationRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateConversationRequest
     * @static
     * @param {ICreateConversationRequest} message CreateConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateConversationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.clientGeneratedId);
        if (message.name != null && message.hasOwnProperty("name"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
        if (message.inviteeId != null && message.inviteeId.length)
            for (let i = 0; i < message.inviteeId.length; ++i)
                $root.InviteeID.encode(message.inviteeId[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateConversationRequest message, length delimited. Does not implicitly {@link CreateConversationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateConversationRequest
     * @static
     * @param {ICreateConversationRequest} message CreateConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateConversationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateConversationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateConversationRequest} CreateConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateConversationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateConversationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.type = reader.int32();
                break;
            case 3:
                message.clientGeneratedId = reader.uint64();
                break;
            case 4:
                message.name = reader.string();
                break;
            case 5:
                if (!(message.inviteeId && message.inviteeId.length))
                    message.inviteeId = [];
                message.inviteeId.push($root.InviteeID.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateConversationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateConversationRequest} CreateConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateConversationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateConversationRequest message.
     * @function verify
     * @memberof CreateConversationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateConversationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (!$util.isInteger(message.clientGeneratedId) && !(message.clientGeneratedId && $util.isInteger(message.clientGeneratedId.low) && $util.isInteger(message.clientGeneratedId.high)))
                return "clientGeneratedId: integer|Long expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.inviteeId != null && message.hasOwnProperty("inviteeId")) {
            if (!Array.isArray(message.inviteeId))
                return "inviteeId: array expected";
            for (let i = 0; i < message.inviteeId.length; ++i) {
                let error = $root.InviteeID.verify(message.inviteeId[i]);
                if (error)
                    return "inviteeId." + error;
            }
        }
        return null;
    };

    /**
     * Creates a CreateConversationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateConversationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateConversationRequest} CreateConversationRequest
     */
    CreateConversationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateConversationRequest)
            return object;
        let message = new $root.CreateConversationRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".CreateConversationRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        switch (object.type) {
        case "CONVERSATION_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "CONVERSATION_TYPE_ONE_TO_ONE":
        case 1:
            message.type = 1;
            break;
        case "CONVERSATION_TYPE_GROUP":
        case 2:
            message.type = 2;
            break;
        }
        if (object.clientGeneratedId != null)
            if ($util.Long)
                (message.clientGeneratedId = $util.Long.fromValue(object.clientGeneratedId)).unsigned = true;
            else if (typeof object.clientGeneratedId === "string")
                message.clientGeneratedId = parseInt(object.clientGeneratedId, 10);
            else if (typeof object.clientGeneratedId === "number")
                message.clientGeneratedId = object.clientGeneratedId;
            else if (typeof object.clientGeneratedId === "object")
                message.clientGeneratedId = new $util.LongBits(object.clientGeneratedId.low >>> 0, object.clientGeneratedId.high >>> 0).toNumber(true);
        if (object.name != null)
            message.name = String(object.name);
        if (object.inviteeId) {
            if (!Array.isArray(object.inviteeId))
                throw TypeError(".CreateConversationRequest.inviteeId: array expected");
            message.inviteeId = [];
            for (let i = 0; i < object.inviteeId.length; ++i) {
                if (typeof object.inviteeId[i] !== "object")
                    throw TypeError(".CreateConversationRequest.inviteeId: object expected");
                message.inviteeId[i] = $root.InviteeID.fromObject(object.inviteeId[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateConversationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateConversationRequest
     * @static
     * @param {CreateConversationRequest} message CreateConversationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateConversationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.inviteeId = [];
        if (options.defaults) {
            object.requestHeader = null;
            object.type = options.enums === String ? "CONVERSATION_TYPE_UNKNOWN" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.clientGeneratedId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.clientGeneratedId = options.longs === String ? "0" : 0;
            object.name = "";
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.ConversationType[message.type] : message.type;
        if (message.clientGeneratedId != null && message.hasOwnProperty("clientGeneratedId"))
            if (typeof message.clientGeneratedId === "number")
                object.clientGeneratedId = options.longs === String ? String(message.clientGeneratedId) : message.clientGeneratedId;
            else
                object.clientGeneratedId = options.longs === String ? $util.Long.prototype.toString.call(message.clientGeneratedId) : options.longs === Number ? new $util.LongBits(message.clientGeneratedId.low >>> 0, message.clientGeneratedId.high >>> 0).toNumber(true) : message.clientGeneratedId;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.inviteeId && message.inviteeId.length) {
            object.inviteeId = [];
            for (let j = 0; j < message.inviteeId.length; ++j)
                object.inviteeId[j] = $root.InviteeID.toObject(message.inviteeId[j], options);
        }
        return object;
    };

    /**
     * Converts this CreateConversationRequest to JSON.
     * @function toJSON
     * @memberof CreateConversationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateConversationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateConversationRequest;
})();

export const CreateConversationResponse = $root.CreateConversationResponse = (() => {

    /**
     * Properties of a CreateConversationResponse.
     * @exports ICreateConversationResponse
     * @interface ICreateConversationResponse
     * @property {IResponseHeader|null} [responseHeader] CreateConversationResponse responseHeader
     * @property {IConversation|null} [conversation] CreateConversationResponse conversation
     * @property {boolean|null} [newConversationCreated] CreateConversationResponse newConversationCreated
     */

    /**
     * Constructs a new CreateConversationResponse.
     * @exports CreateConversationResponse
     * @classdesc Represents a CreateConversationResponse.
     * @implements ICreateConversationResponse
     * @constructor
     * @param {ICreateConversationResponse=} [properties] Properties to set
     */
    function CreateConversationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateConversationResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof CreateConversationResponse
     * @instance
     */
    CreateConversationResponse.prototype.responseHeader = null;

    /**
     * CreateConversationResponse conversation.
     * @member {IConversation|null|undefined} conversation
     * @memberof CreateConversationResponse
     * @instance
     */
    CreateConversationResponse.prototype.conversation = null;

    /**
     * CreateConversationResponse newConversationCreated.
     * @member {boolean} newConversationCreated
     * @memberof CreateConversationResponse
     * @instance
     */
    CreateConversationResponse.prototype.newConversationCreated = false;

    /**
     * Creates a new CreateConversationResponse instance using the specified properties.
     * @function create
     * @memberof CreateConversationResponse
     * @static
     * @param {ICreateConversationResponse=} [properties] Properties to set
     * @returns {CreateConversationResponse} CreateConversationResponse instance
     */
    CreateConversationResponse.create = function create(properties) {
        return new CreateConversationResponse(properties);
    };

    /**
     * Encodes the specified CreateConversationResponse message. Does not implicitly {@link CreateConversationResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateConversationResponse
     * @static
     * @param {ICreateConversationResponse} message CreateConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateConversationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            $root.Conversation.encode(message.conversation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.newConversationCreated != null && message.hasOwnProperty("newConversationCreated"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.newConversationCreated);
        return writer;
    };

    /**
     * Encodes the specified CreateConversationResponse message, length delimited. Does not implicitly {@link CreateConversationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateConversationResponse
     * @static
     * @param {ICreateConversationResponse} message CreateConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateConversationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateConversationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateConversationResponse} CreateConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateConversationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateConversationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversation = $root.Conversation.decode(reader, reader.uint32());
                break;
            case 7:
                message.newConversationCreated = reader.bool();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateConversationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateConversationResponse} CreateConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateConversationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateConversationResponse message.
     * @function verify
     * @memberof CreateConversationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateConversationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.conversation != null && message.hasOwnProperty("conversation")) {
            let error = $root.Conversation.verify(message.conversation);
            if (error)
                return "conversation." + error;
        }
        if (message.newConversationCreated != null && message.hasOwnProperty("newConversationCreated"))
            if (typeof message.newConversationCreated !== "boolean")
                return "newConversationCreated: boolean expected";
        return null;
    };

    /**
     * Creates a CreateConversationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateConversationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateConversationResponse} CreateConversationResponse
     */
    CreateConversationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateConversationResponse)
            return object;
        let message = new $root.CreateConversationResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".CreateConversationResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.conversation != null) {
            if (typeof object.conversation !== "object")
                throw TypeError(".CreateConversationResponse.conversation: object expected");
            message.conversation = $root.Conversation.fromObject(object.conversation);
        }
        if (object.newConversationCreated != null)
            message.newConversationCreated = Boolean(object.newConversationCreated);
        return message;
    };

    /**
     * Creates a plain object from a CreateConversationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateConversationResponse
     * @static
     * @param {CreateConversationResponse} message CreateConversationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateConversationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.conversation = null;
            object.newConversationCreated = false;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.conversation != null && message.hasOwnProperty("conversation"))
            object.conversation = $root.Conversation.toObject(message.conversation, options);
        if (message.newConversationCreated != null && message.hasOwnProperty("newConversationCreated"))
            object.newConversationCreated = message.newConversationCreated;
        return object;
    };

    /**
     * Converts this CreateConversationResponse to JSON.
     * @function toJSON
     * @memberof CreateConversationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateConversationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return CreateConversationResponse;
})();

export const DeleteConversationRequest = $root.DeleteConversationRequest = (() => {

    /**
     * Properties of a DeleteConversationRequest.
     * @exports IDeleteConversationRequest
     * @interface IDeleteConversationRequest
     * @property {IRequestHeader|null} [requestHeader] DeleteConversationRequest requestHeader
     * @property {IConversationId|null} [conversationId] DeleteConversationRequest conversationId
     * @property {number|Long|null} [deleteUpperBoundTimestamp] DeleteConversationRequest deleteUpperBoundTimestamp
     */

    /**
     * Constructs a new DeleteConversationRequest.
     * @exports DeleteConversationRequest
     * @classdesc Represents a DeleteConversationRequest.
     * @implements IDeleteConversationRequest
     * @constructor
     * @param {IDeleteConversationRequest=} [properties] Properties to set
     */
    function DeleteConversationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteConversationRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof DeleteConversationRequest
     * @instance
     */
    DeleteConversationRequest.prototype.requestHeader = null;

    /**
     * DeleteConversationRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof DeleteConversationRequest
     * @instance
     */
    DeleteConversationRequest.prototype.conversationId = null;

    /**
     * DeleteConversationRequest deleteUpperBoundTimestamp.
     * @member {number|Long} deleteUpperBoundTimestamp
     * @memberof DeleteConversationRequest
     * @instance
     */
    DeleteConversationRequest.prototype.deleteUpperBoundTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new DeleteConversationRequest instance using the specified properties.
     * @function create
     * @memberof DeleteConversationRequest
     * @static
     * @param {IDeleteConversationRequest=} [properties] Properties to set
     * @returns {DeleteConversationRequest} DeleteConversationRequest instance
     */
    DeleteConversationRequest.create = function create(properties) {
        return new DeleteConversationRequest(properties);
    };

    /**
     * Encodes the specified DeleteConversationRequest message. Does not implicitly {@link DeleteConversationRequest.verify|verify} messages.
     * @function encode
     * @memberof DeleteConversationRequest
     * @static
     * @param {IDeleteConversationRequest} message DeleteConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteConversationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.deleteUpperBoundTimestamp);
        return writer;
    };

    /**
     * Encodes the specified DeleteConversationRequest message, length delimited. Does not implicitly {@link DeleteConversationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteConversationRequest
     * @static
     * @param {IDeleteConversationRequest} message DeleteConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteConversationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteConversationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteConversationRequest} DeleteConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteConversationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteConversationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.deleteUpperBoundTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteConversationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteConversationRequest} DeleteConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteConversationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteConversationRequest message.
     * @function verify
     * @memberof DeleteConversationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteConversationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            if (!$util.isInteger(message.deleteUpperBoundTimestamp) && !(message.deleteUpperBoundTimestamp && $util.isInteger(message.deleteUpperBoundTimestamp.low) && $util.isInteger(message.deleteUpperBoundTimestamp.high)))
                return "deleteUpperBoundTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a DeleteConversationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteConversationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteConversationRequest} DeleteConversationRequest
     */
    DeleteConversationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteConversationRequest)
            return object;
        let message = new $root.DeleteConversationRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".DeleteConversationRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".DeleteConversationRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.deleteUpperBoundTimestamp != null)
            if ($util.Long)
                (message.deleteUpperBoundTimestamp = $util.Long.fromValue(object.deleteUpperBoundTimestamp)).unsigned = true;
            else if (typeof object.deleteUpperBoundTimestamp === "string")
                message.deleteUpperBoundTimestamp = parseInt(object.deleteUpperBoundTimestamp, 10);
            else if (typeof object.deleteUpperBoundTimestamp === "number")
                message.deleteUpperBoundTimestamp = object.deleteUpperBoundTimestamp;
            else if (typeof object.deleteUpperBoundTimestamp === "object")
                message.deleteUpperBoundTimestamp = new $util.LongBits(object.deleteUpperBoundTimestamp.low >>> 0, object.deleteUpperBoundTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a DeleteConversationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteConversationRequest
     * @static
     * @param {DeleteConversationRequest} message DeleteConversationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteConversationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.deleteUpperBoundTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.deleteUpperBoundTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.deleteUpperBoundTimestamp != null && message.hasOwnProperty("deleteUpperBoundTimestamp"))
            if (typeof message.deleteUpperBoundTimestamp === "number")
                object.deleteUpperBoundTimestamp = options.longs === String ? String(message.deleteUpperBoundTimestamp) : message.deleteUpperBoundTimestamp;
            else
                object.deleteUpperBoundTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.deleteUpperBoundTimestamp) : options.longs === Number ? new $util.LongBits(message.deleteUpperBoundTimestamp.low >>> 0, message.deleteUpperBoundTimestamp.high >>> 0).toNumber(true) : message.deleteUpperBoundTimestamp;
        return object;
    };

    /**
     * Converts this DeleteConversationRequest to JSON.
     * @function toJSON
     * @memberof DeleteConversationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteConversationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteConversationRequest;
})();

export const DeleteConversationResponse = $root.DeleteConversationResponse = (() => {

    /**
     * Properties of a DeleteConversationResponse.
     * @exports IDeleteConversationResponse
     * @interface IDeleteConversationResponse
     * @property {IResponseHeader|null} [responseHeader] DeleteConversationResponse responseHeader
     * @property {IDeleteAction|null} [deleteAction] DeleteConversationResponse deleteAction
     */

    /**
     * Constructs a new DeleteConversationResponse.
     * @exports DeleteConversationResponse
     * @classdesc Represents a DeleteConversationResponse.
     * @implements IDeleteConversationResponse
     * @constructor
     * @param {IDeleteConversationResponse=} [properties] Properties to set
     */
    function DeleteConversationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DeleteConversationResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof DeleteConversationResponse
     * @instance
     */
    DeleteConversationResponse.prototype.responseHeader = null;

    /**
     * DeleteConversationResponse deleteAction.
     * @member {IDeleteAction|null|undefined} deleteAction
     * @memberof DeleteConversationResponse
     * @instance
     */
    DeleteConversationResponse.prototype.deleteAction = null;

    /**
     * Creates a new DeleteConversationResponse instance using the specified properties.
     * @function create
     * @memberof DeleteConversationResponse
     * @static
     * @param {IDeleteConversationResponse=} [properties] Properties to set
     * @returns {DeleteConversationResponse} DeleteConversationResponse instance
     */
    DeleteConversationResponse.create = function create(properties) {
        return new DeleteConversationResponse(properties);
    };

    /**
     * Encodes the specified DeleteConversationResponse message. Does not implicitly {@link DeleteConversationResponse.verify|verify} messages.
     * @function encode
     * @memberof DeleteConversationResponse
     * @static
     * @param {IDeleteConversationResponse} message DeleteConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteConversationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction"))
            $root.DeleteAction.encode(message.deleteAction, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DeleteConversationResponse message, length delimited. Does not implicitly {@link DeleteConversationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DeleteConversationResponse
     * @static
     * @param {IDeleteConversationResponse} message DeleteConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DeleteConversationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DeleteConversationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DeleteConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DeleteConversationResponse} DeleteConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteConversationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteConversationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.deleteAction = $root.DeleteAction.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DeleteConversationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DeleteConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DeleteConversationResponse} DeleteConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DeleteConversationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DeleteConversationResponse message.
     * @function verify
     * @memberof DeleteConversationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DeleteConversationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction")) {
            let error = $root.DeleteAction.verify(message.deleteAction);
            if (error)
                return "deleteAction." + error;
        }
        return null;
    };

    /**
     * Creates a DeleteConversationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DeleteConversationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DeleteConversationResponse} DeleteConversationResponse
     */
    DeleteConversationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DeleteConversationResponse)
            return object;
        let message = new $root.DeleteConversationResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".DeleteConversationResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.deleteAction != null) {
            if (typeof object.deleteAction !== "object")
                throw TypeError(".DeleteConversationResponse.deleteAction: object expected");
            message.deleteAction = $root.DeleteAction.fromObject(object.deleteAction);
        }
        return message;
    };

    /**
     * Creates a plain object from a DeleteConversationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DeleteConversationResponse
     * @static
     * @param {DeleteConversationResponse} message DeleteConversationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DeleteConversationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.deleteAction = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.deleteAction != null && message.hasOwnProperty("deleteAction"))
            object.deleteAction = $root.DeleteAction.toObject(message.deleteAction, options);
        return object;
    };

    /**
     * Converts this DeleteConversationResponse to JSON.
     * @function toJSON
     * @memberof DeleteConversationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DeleteConversationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return DeleteConversationResponse;
})();

export const EasterEggRequest = $root.EasterEggRequest = (() => {

    /**
     * Properties of an EasterEggRequest.
     * @exports IEasterEggRequest
     * @interface IEasterEggRequest
     * @property {IRequestHeader|null} [requestHeader] EasterEggRequest requestHeader
     * @property {IConversationId|null} [conversationId] EasterEggRequest conversationId
     * @property {IEasterEgg|null} [easterEgg] EasterEggRequest easterEgg
     */

    /**
     * Constructs a new EasterEggRequest.
     * @exports EasterEggRequest
     * @classdesc Represents an EasterEggRequest.
     * @implements IEasterEggRequest
     * @constructor
     * @param {IEasterEggRequest=} [properties] Properties to set
     */
    function EasterEggRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EasterEggRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof EasterEggRequest
     * @instance
     */
    EasterEggRequest.prototype.requestHeader = null;

    /**
     * EasterEggRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof EasterEggRequest
     * @instance
     */
    EasterEggRequest.prototype.conversationId = null;

    /**
     * EasterEggRequest easterEgg.
     * @member {IEasterEgg|null|undefined} easterEgg
     * @memberof EasterEggRequest
     * @instance
     */
    EasterEggRequest.prototype.easterEgg = null;

    /**
     * Creates a new EasterEggRequest instance using the specified properties.
     * @function create
     * @memberof EasterEggRequest
     * @static
     * @param {IEasterEggRequest=} [properties] Properties to set
     * @returns {EasterEggRequest} EasterEggRequest instance
     */
    EasterEggRequest.create = function create(properties) {
        return new EasterEggRequest(properties);
    };

    /**
     * Encodes the specified EasterEggRequest message. Does not implicitly {@link EasterEggRequest.verify|verify} messages.
     * @function encode
     * @memberof EasterEggRequest
     * @static
     * @param {IEasterEggRequest} message EasterEggRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg"))
            $root.EasterEgg.encode(message.easterEgg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified EasterEggRequest message, length delimited. Does not implicitly {@link EasterEggRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EasterEggRequest
     * @static
     * @param {IEasterEggRequest} message EasterEggRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EasterEggRequest message from the specified reader or buffer.
     * @function decode
     * @memberof EasterEggRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EasterEggRequest} EasterEggRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EasterEggRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.easterEgg = $root.EasterEgg.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EasterEggRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EasterEggRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EasterEggRequest} EasterEggRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EasterEggRequest message.
     * @function verify
     * @memberof EasterEggRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EasterEggRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg")) {
            let error = $root.EasterEgg.verify(message.easterEgg);
            if (error)
                return "easterEgg." + error;
        }
        return null;
    };

    /**
     * Creates an EasterEggRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EasterEggRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EasterEggRequest} EasterEggRequest
     */
    EasterEggRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.EasterEggRequest)
            return object;
        let message = new $root.EasterEggRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".EasterEggRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".EasterEggRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.easterEgg != null) {
            if (typeof object.easterEgg !== "object")
                throw TypeError(".EasterEggRequest.easterEgg: object expected");
            message.easterEgg = $root.EasterEgg.fromObject(object.easterEgg);
        }
        return message;
    };

    /**
     * Creates a plain object from an EasterEggRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EasterEggRequest
     * @static
     * @param {EasterEggRequest} message EasterEggRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EasterEggRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            object.easterEgg = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.easterEgg != null && message.hasOwnProperty("easterEgg"))
            object.easterEgg = $root.EasterEgg.toObject(message.easterEgg, options);
        return object;
    };

    /**
     * Converts this EasterEggRequest to JSON.
     * @function toJSON
     * @memberof EasterEggRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EasterEggRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EasterEggRequest;
})();

export const EasterEggResponse = $root.EasterEggResponse = (() => {

    /**
     * Properties of an EasterEggResponse.
     * @exports IEasterEggResponse
     * @interface IEasterEggResponse
     * @property {IResponseHeader|null} [responseHeader] EasterEggResponse responseHeader
     * @property {number|Long|null} [timestamp] EasterEggResponse timestamp
     */

    /**
     * Constructs a new EasterEggResponse.
     * @exports EasterEggResponse
     * @classdesc Represents an EasterEggResponse.
     * @implements IEasterEggResponse
     * @constructor
     * @param {IEasterEggResponse=} [properties] Properties to set
     */
    function EasterEggResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * EasterEggResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof EasterEggResponse
     * @instance
     */
    EasterEggResponse.prototype.responseHeader = null;

    /**
     * EasterEggResponse timestamp.
     * @member {number|Long} timestamp
     * @memberof EasterEggResponse
     * @instance
     */
    EasterEggResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new EasterEggResponse instance using the specified properties.
     * @function create
     * @memberof EasterEggResponse
     * @static
     * @param {IEasterEggResponse=} [properties] Properties to set
     * @returns {EasterEggResponse} EasterEggResponse instance
     */
    EasterEggResponse.create = function create(properties) {
        return new EasterEggResponse(properties);
    };

    /**
     * Encodes the specified EasterEggResponse message. Does not implicitly {@link EasterEggResponse.verify|verify} messages.
     * @function encode
     * @memberof EasterEggResponse
     * @static
     * @param {IEasterEggResponse} message EasterEggResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
        return writer;
    };

    /**
     * Encodes the specified EasterEggResponse message, length delimited. Does not implicitly {@link EasterEggResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof EasterEggResponse
     * @static
     * @param {IEasterEggResponse} message EasterEggResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    EasterEggResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an EasterEggResponse message from the specified reader or buffer.
     * @function decode
     * @memberof EasterEggResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {EasterEggResponse} EasterEggResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.EasterEggResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.timestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an EasterEggResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof EasterEggResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {EasterEggResponse} EasterEggResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    EasterEggResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an EasterEggResponse message.
     * @function verify
     * @memberof EasterEggResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    EasterEggResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates an EasterEggResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof EasterEggResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {EasterEggResponse} EasterEggResponse
     */
    EasterEggResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.EasterEggResponse)
            return object;
        let message = new $root.EasterEggResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".EasterEggResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from an EasterEggResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof EasterEggResponse
     * @static
     * @param {EasterEggResponse} message EasterEggResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    EasterEggResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        return object;
    };

    /**
     * Converts this EasterEggResponse to JSON.
     * @function toJSON
     * @memberof EasterEggResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    EasterEggResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return EasterEggResponse;
})();

export const GetConversationRequest = $root.GetConversationRequest = (() => {

    /**
     * Properties of a GetConversationRequest.
     * @exports IGetConversationRequest
     * @interface IGetConversationRequest
     * @property {IRequestHeader|null} [requestHeader] GetConversationRequest requestHeader
     * @property {IConversationSpec|null} [conversationSpec] GetConversationRequest conversationSpec
     * @property {boolean|null} [includeConversationMetadata] GetConversationRequest includeConversationMetadata
     * @property {boolean|null} [includeEvent] GetConversationRequest includeEvent
     * @property {number|Long|null} [maxEventsPerConversation] GetConversationRequest maxEventsPerConversation
     * @property {IEventContinuationToken|null} [eventContinuationToken] GetConversationRequest eventContinuationToken
     */

    /**
     * Constructs a new GetConversationRequest.
     * @exports GetConversationRequest
     * @classdesc Represents a GetConversationRequest.
     * @implements IGetConversationRequest
     * @constructor
     * @param {IGetConversationRequest=} [properties] Properties to set
     */
    function GetConversationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetConversationRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.requestHeader = null;

    /**
     * GetConversationRequest conversationSpec.
     * @member {IConversationSpec|null|undefined} conversationSpec
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.conversationSpec = null;

    /**
     * GetConversationRequest includeConversationMetadata.
     * @member {boolean} includeConversationMetadata
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.includeConversationMetadata = false;

    /**
     * GetConversationRequest includeEvent.
     * @member {boolean} includeEvent
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.includeEvent = false;

    /**
     * GetConversationRequest maxEventsPerConversation.
     * @member {number|Long} maxEventsPerConversation
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.maxEventsPerConversation = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * GetConversationRequest eventContinuationToken.
     * @member {IEventContinuationToken|null|undefined} eventContinuationToken
     * @memberof GetConversationRequest
     * @instance
     */
    GetConversationRequest.prototype.eventContinuationToken = null;

    /**
     * Creates a new GetConversationRequest instance using the specified properties.
     * @function create
     * @memberof GetConversationRequest
     * @static
     * @param {IGetConversationRequest=} [properties] Properties to set
     * @returns {GetConversationRequest} GetConversationRequest instance
     */
    GetConversationRequest.create = function create(properties) {
        return new GetConversationRequest(properties);
    };

    /**
     * Encodes the specified GetConversationRequest message. Does not implicitly {@link GetConversationRequest.verify|verify} messages.
     * @function encode
     * @memberof GetConversationRequest
     * @static
     * @param {IGetConversationRequest} message GetConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetConversationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationSpec != null && message.hasOwnProperty("conversationSpec"))
            $root.ConversationSpec.encode(message.conversationSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.includeConversationMetadata != null && message.hasOwnProperty("includeConversationMetadata"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeConversationMetadata);
        if (message.includeEvent != null && message.hasOwnProperty("includeEvent"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.includeEvent);
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxEventsPerConversation);
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken"))
            $root.EventContinuationToken.encode(message.eventContinuationToken, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetConversationRequest message, length delimited. Does not implicitly {@link GetConversationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetConversationRequest
     * @static
     * @param {IGetConversationRequest} message GetConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetConversationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetConversationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetConversationRequest} GetConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetConversationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetConversationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationSpec = $root.ConversationSpec.decode(reader, reader.uint32());
                break;
            case 3:
                message.includeConversationMetadata = reader.bool();
                break;
            case 4:
                message.includeEvent = reader.bool();
                break;
            case 6:
                message.maxEventsPerConversation = reader.uint64();
                break;
            case 7:
                message.eventContinuationToken = $root.EventContinuationToken.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetConversationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetConversationRequest} GetConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetConversationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetConversationRequest message.
     * @function verify
     * @memberof GetConversationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetConversationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationSpec != null && message.hasOwnProperty("conversationSpec")) {
            let error = $root.ConversationSpec.verify(message.conversationSpec);
            if (error)
                return "conversationSpec." + error;
        }
        if (message.includeConversationMetadata != null && message.hasOwnProperty("includeConversationMetadata"))
            if (typeof message.includeConversationMetadata !== "boolean")
                return "includeConversationMetadata: boolean expected";
        if (message.includeEvent != null && message.hasOwnProperty("includeEvent"))
            if (typeof message.includeEvent !== "boolean")
                return "includeEvent: boolean expected";
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            if (!$util.isInteger(message.maxEventsPerConversation) && !(message.maxEventsPerConversation && $util.isInteger(message.maxEventsPerConversation.low) && $util.isInteger(message.maxEventsPerConversation.high)))
                return "maxEventsPerConversation: integer|Long expected";
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken")) {
            let error = $root.EventContinuationToken.verify(message.eventContinuationToken);
            if (error)
                return "eventContinuationToken." + error;
        }
        return null;
    };

    /**
     * Creates a GetConversationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetConversationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetConversationRequest} GetConversationRequest
     */
    GetConversationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetConversationRequest)
            return object;
        let message = new $root.GetConversationRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".GetConversationRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationSpec != null) {
            if (typeof object.conversationSpec !== "object")
                throw TypeError(".GetConversationRequest.conversationSpec: object expected");
            message.conversationSpec = $root.ConversationSpec.fromObject(object.conversationSpec);
        }
        if (object.includeConversationMetadata != null)
            message.includeConversationMetadata = Boolean(object.includeConversationMetadata);
        if (object.includeEvent != null)
            message.includeEvent = Boolean(object.includeEvent);
        if (object.maxEventsPerConversation != null)
            if ($util.Long)
                (message.maxEventsPerConversation = $util.Long.fromValue(object.maxEventsPerConversation)).unsigned = true;
            else if (typeof object.maxEventsPerConversation === "string")
                message.maxEventsPerConversation = parseInt(object.maxEventsPerConversation, 10);
            else if (typeof object.maxEventsPerConversation === "number")
                message.maxEventsPerConversation = object.maxEventsPerConversation;
            else if (typeof object.maxEventsPerConversation === "object")
                message.maxEventsPerConversation = new $util.LongBits(object.maxEventsPerConversation.low >>> 0, object.maxEventsPerConversation.high >>> 0).toNumber(true);
        if (object.eventContinuationToken != null) {
            if (typeof object.eventContinuationToken !== "object")
                throw TypeError(".GetConversationRequest.eventContinuationToken: object expected");
            message.eventContinuationToken = $root.EventContinuationToken.fromObject(object.eventContinuationToken);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetConversationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetConversationRequest
     * @static
     * @param {GetConversationRequest} message GetConversationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetConversationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationSpec = null;
            object.includeConversationMetadata = false;
            object.includeEvent = false;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxEventsPerConversation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxEventsPerConversation = options.longs === String ? "0" : 0;
            object.eventContinuationToken = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationSpec != null && message.hasOwnProperty("conversationSpec"))
            object.conversationSpec = $root.ConversationSpec.toObject(message.conversationSpec, options);
        if (message.includeConversationMetadata != null && message.hasOwnProperty("includeConversationMetadata"))
            object.includeConversationMetadata = message.includeConversationMetadata;
        if (message.includeEvent != null && message.hasOwnProperty("includeEvent"))
            object.includeEvent = message.includeEvent;
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            if (typeof message.maxEventsPerConversation === "number")
                object.maxEventsPerConversation = options.longs === String ? String(message.maxEventsPerConversation) : message.maxEventsPerConversation;
            else
                object.maxEventsPerConversation = options.longs === String ? $util.Long.prototype.toString.call(message.maxEventsPerConversation) : options.longs === Number ? new $util.LongBits(message.maxEventsPerConversation.low >>> 0, message.maxEventsPerConversation.high >>> 0).toNumber(true) : message.maxEventsPerConversation;
        if (message.eventContinuationToken != null && message.hasOwnProperty("eventContinuationToken"))
            object.eventContinuationToken = $root.EventContinuationToken.toObject(message.eventContinuationToken, options);
        return object;
    };

    /**
     * Converts this GetConversationRequest to JSON.
     * @function toJSON
     * @memberof GetConversationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetConversationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetConversationRequest;
})();

export const GetConversationResponse = $root.GetConversationResponse = (() => {

    /**
     * Properties of a GetConversationResponse.
     * @exports IGetConversationResponse
     * @interface IGetConversationResponse
     * @property {IResponseHeader|null} [responseHeader] GetConversationResponse responseHeader
     * @property {IConversationState|null} [conversationState] GetConversationResponse conversationState
     */

    /**
     * Constructs a new GetConversationResponse.
     * @exports GetConversationResponse
     * @classdesc Represents a GetConversationResponse.
     * @implements IGetConversationResponse
     * @constructor
     * @param {IGetConversationResponse=} [properties] Properties to set
     */
    function GetConversationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetConversationResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof GetConversationResponse
     * @instance
     */
    GetConversationResponse.prototype.responseHeader = null;

    /**
     * GetConversationResponse conversationState.
     * @member {IConversationState|null|undefined} conversationState
     * @memberof GetConversationResponse
     * @instance
     */
    GetConversationResponse.prototype.conversationState = null;

    /**
     * Creates a new GetConversationResponse instance using the specified properties.
     * @function create
     * @memberof GetConversationResponse
     * @static
     * @param {IGetConversationResponse=} [properties] Properties to set
     * @returns {GetConversationResponse} GetConversationResponse instance
     */
    GetConversationResponse.create = function create(properties) {
        return new GetConversationResponse(properties);
    };

    /**
     * Encodes the specified GetConversationResponse message. Does not implicitly {@link GetConversationResponse.verify|verify} messages.
     * @function encode
     * @memberof GetConversationResponse
     * @static
     * @param {IGetConversationResponse} message GetConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetConversationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationState != null && message.hasOwnProperty("conversationState"))
            $root.ConversationState.encode(message.conversationState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetConversationResponse message, length delimited. Does not implicitly {@link GetConversationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetConversationResponse
     * @static
     * @param {IGetConversationResponse} message GetConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetConversationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetConversationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetConversationResponse} GetConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetConversationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetConversationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationState = $root.ConversationState.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetConversationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetConversationResponse} GetConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetConversationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetConversationResponse message.
     * @function verify
     * @memberof GetConversationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetConversationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.conversationState != null && message.hasOwnProperty("conversationState")) {
            let error = $root.ConversationState.verify(message.conversationState);
            if (error)
                return "conversationState." + error;
        }
        return null;
    };

    /**
     * Creates a GetConversationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetConversationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetConversationResponse} GetConversationResponse
     */
    GetConversationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetConversationResponse)
            return object;
        let message = new $root.GetConversationResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".GetConversationResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.conversationState != null) {
            if (typeof object.conversationState !== "object")
                throw TypeError(".GetConversationResponse.conversationState: object expected");
            message.conversationState = $root.ConversationState.fromObject(object.conversationState);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetConversationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetConversationResponse
     * @static
     * @param {GetConversationResponse} message GetConversationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetConversationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.conversationState = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.conversationState != null && message.hasOwnProperty("conversationState"))
            object.conversationState = $root.ConversationState.toObject(message.conversationState, options);
        return object;
    };

    /**
     * Converts this GetConversationResponse to JSON.
     * @function toJSON
     * @memberof GetConversationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetConversationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetConversationResponse;
})();

export const GetEntityByIdRequest = $root.GetEntityByIdRequest = (() => {

    /**
     * Properties of a GetEntityByIdRequest.
     * @exports IGetEntityByIdRequest
     * @interface IGetEntityByIdRequest
     * @property {IRequestHeader|null} [requestHeader] GetEntityByIdRequest requestHeader
     * @property {Array.<IEntityLookupSpec>|null} [batchLookupSpec] GetEntityByIdRequest batchLookupSpec
     */

    /**
     * Constructs a new GetEntityByIdRequest.
     * @exports GetEntityByIdRequest
     * @classdesc Represents a GetEntityByIdRequest.
     * @implements IGetEntityByIdRequest
     * @constructor
     * @param {IGetEntityByIdRequest=} [properties] Properties to set
     */
    function GetEntityByIdRequest(properties) {
        this.batchLookupSpec = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetEntityByIdRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof GetEntityByIdRequest
     * @instance
     */
    GetEntityByIdRequest.prototype.requestHeader = null;

    /**
     * GetEntityByIdRequest batchLookupSpec.
     * @member {Array.<IEntityLookupSpec>} batchLookupSpec
     * @memberof GetEntityByIdRequest
     * @instance
     */
    GetEntityByIdRequest.prototype.batchLookupSpec = $util.emptyArray;

    /**
     * Creates a new GetEntityByIdRequest instance using the specified properties.
     * @function create
     * @memberof GetEntityByIdRequest
     * @static
     * @param {IGetEntityByIdRequest=} [properties] Properties to set
     * @returns {GetEntityByIdRequest} GetEntityByIdRequest instance
     */
    GetEntityByIdRequest.create = function create(properties) {
        return new GetEntityByIdRequest(properties);
    };

    /**
     * Encodes the specified GetEntityByIdRequest message. Does not implicitly {@link GetEntityByIdRequest.verify|verify} messages.
     * @function encode
     * @memberof GetEntityByIdRequest
     * @static
     * @param {IGetEntityByIdRequest} message GetEntityByIdRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEntityByIdRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.batchLookupSpec != null && message.batchLookupSpec.length)
            for (let i = 0; i < message.batchLookupSpec.length; ++i)
                $root.EntityLookupSpec.encode(message.batchLookupSpec[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetEntityByIdRequest message, length delimited. Does not implicitly {@link GetEntityByIdRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetEntityByIdRequest
     * @static
     * @param {IGetEntityByIdRequest} message GetEntityByIdRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEntityByIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetEntityByIdRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetEntityByIdRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetEntityByIdRequest} GetEntityByIdRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEntityByIdRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetEntityByIdRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                if (!(message.batchLookupSpec && message.batchLookupSpec.length))
                    message.batchLookupSpec = [];
                message.batchLookupSpec.push($root.EntityLookupSpec.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetEntityByIdRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetEntityByIdRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetEntityByIdRequest} GetEntityByIdRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEntityByIdRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetEntityByIdRequest message.
     * @function verify
     * @memberof GetEntityByIdRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetEntityByIdRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.batchLookupSpec != null && message.hasOwnProperty("batchLookupSpec")) {
            if (!Array.isArray(message.batchLookupSpec))
                return "batchLookupSpec: array expected";
            for (let i = 0; i < message.batchLookupSpec.length; ++i) {
                let error = $root.EntityLookupSpec.verify(message.batchLookupSpec[i]);
                if (error)
                    return "batchLookupSpec." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetEntityByIdRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetEntityByIdRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetEntityByIdRequest} GetEntityByIdRequest
     */
    GetEntityByIdRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetEntityByIdRequest)
            return object;
        let message = new $root.GetEntityByIdRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".GetEntityByIdRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.batchLookupSpec) {
            if (!Array.isArray(object.batchLookupSpec))
                throw TypeError(".GetEntityByIdRequest.batchLookupSpec: array expected");
            message.batchLookupSpec = [];
            for (let i = 0; i < object.batchLookupSpec.length; ++i) {
                if (typeof object.batchLookupSpec[i] !== "object")
                    throw TypeError(".GetEntityByIdRequest.batchLookupSpec: object expected");
                message.batchLookupSpec[i] = $root.EntityLookupSpec.fromObject(object.batchLookupSpec[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetEntityByIdRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetEntityByIdRequest
     * @static
     * @param {GetEntityByIdRequest} message GetEntityByIdRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetEntityByIdRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.batchLookupSpec = [];
        if (options.defaults)
            object.requestHeader = null;
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.batchLookupSpec && message.batchLookupSpec.length) {
            object.batchLookupSpec = [];
            for (let j = 0; j < message.batchLookupSpec.length; ++j)
                object.batchLookupSpec[j] = $root.EntityLookupSpec.toObject(message.batchLookupSpec[j], options);
        }
        return object;
    };

    /**
     * Converts this GetEntityByIdRequest to JSON.
     * @function toJSON
     * @memberof GetEntityByIdRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetEntityByIdRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetEntityByIdRequest;
})();

export const GetEntityByIdResponse = $root.GetEntityByIdResponse = (() => {

    /**
     * Properties of a GetEntityByIdResponse.
     * @exports IGetEntityByIdResponse
     * @interface IGetEntityByIdResponse
     * @property {IResponseHeader|null} [responseHeader] GetEntityByIdResponse responseHeader
     * @property {Array.<IEntity>|null} [entity] GetEntityByIdResponse entity
     * @property {Array.<IEntityResult>|null} [entityResult] GetEntityByIdResponse entityResult
     */

    /**
     * Constructs a new GetEntityByIdResponse.
     * @exports GetEntityByIdResponse
     * @classdesc Represents a GetEntityByIdResponse.
     * @implements IGetEntityByIdResponse
     * @constructor
     * @param {IGetEntityByIdResponse=} [properties] Properties to set
     */
    function GetEntityByIdResponse(properties) {
        this.entity = [];
        this.entityResult = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetEntityByIdResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof GetEntityByIdResponse
     * @instance
     */
    GetEntityByIdResponse.prototype.responseHeader = null;

    /**
     * GetEntityByIdResponse entity.
     * @member {Array.<IEntity>} entity
     * @memberof GetEntityByIdResponse
     * @instance
     */
    GetEntityByIdResponse.prototype.entity = $util.emptyArray;

    /**
     * GetEntityByIdResponse entityResult.
     * @member {Array.<IEntityResult>} entityResult
     * @memberof GetEntityByIdResponse
     * @instance
     */
    GetEntityByIdResponse.prototype.entityResult = $util.emptyArray;

    /**
     * Creates a new GetEntityByIdResponse instance using the specified properties.
     * @function create
     * @memberof GetEntityByIdResponse
     * @static
     * @param {IGetEntityByIdResponse=} [properties] Properties to set
     * @returns {GetEntityByIdResponse} GetEntityByIdResponse instance
     */
    GetEntityByIdResponse.create = function create(properties) {
        return new GetEntityByIdResponse(properties);
    };

    /**
     * Encodes the specified GetEntityByIdResponse message. Does not implicitly {@link GetEntityByIdResponse.verify|verify} messages.
     * @function encode
     * @memberof GetEntityByIdResponse
     * @static
     * @param {IGetEntityByIdResponse} message GetEntityByIdResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEntityByIdResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.entity != null && message.entity.length)
            for (let i = 0; i < message.entity.length; ++i)
                $root.Entity.encode(message.entity[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.entityResult != null && message.entityResult.length)
            for (let i = 0; i < message.entityResult.length; ++i)
                $root.EntityResult.encode(message.entityResult[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetEntityByIdResponse message, length delimited. Does not implicitly {@link GetEntityByIdResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetEntityByIdResponse
     * @static
     * @param {IGetEntityByIdResponse} message GetEntityByIdResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetEntityByIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetEntityByIdResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetEntityByIdResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetEntityByIdResponse} GetEntityByIdResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEntityByIdResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetEntityByIdResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.entity && message.entity.length))
                    message.entity = [];
                message.entity.push($root.Entity.decode(reader, reader.uint32()));
                break;
            case 3:
                if (!(message.entityResult && message.entityResult.length))
                    message.entityResult = [];
                message.entityResult.push($root.EntityResult.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetEntityByIdResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetEntityByIdResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetEntityByIdResponse} GetEntityByIdResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetEntityByIdResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetEntityByIdResponse message.
     * @function verify
     * @memberof GetEntityByIdResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetEntityByIdResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.entity != null && message.hasOwnProperty("entity")) {
            if (!Array.isArray(message.entity))
                return "entity: array expected";
            for (let i = 0; i < message.entity.length; ++i) {
                let error = $root.Entity.verify(message.entity[i]);
                if (error)
                    return "entity." + error;
            }
        }
        if (message.entityResult != null && message.hasOwnProperty("entityResult")) {
            if (!Array.isArray(message.entityResult))
                return "entityResult: array expected";
            for (let i = 0; i < message.entityResult.length; ++i) {
                let error = $root.EntityResult.verify(message.entityResult[i]);
                if (error)
                    return "entityResult." + error;
            }
        }
        return null;
    };

    /**
     * Creates a GetEntityByIdResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetEntityByIdResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetEntityByIdResponse} GetEntityByIdResponse
     */
    GetEntityByIdResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetEntityByIdResponse)
            return object;
        let message = new $root.GetEntityByIdResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".GetEntityByIdResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.entity) {
            if (!Array.isArray(object.entity))
                throw TypeError(".GetEntityByIdResponse.entity: array expected");
            message.entity = [];
            for (let i = 0; i < object.entity.length; ++i) {
                if (typeof object.entity[i] !== "object")
                    throw TypeError(".GetEntityByIdResponse.entity: object expected");
                message.entity[i] = $root.Entity.fromObject(object.entity[i]);
            }
        }
        if (object.entityResult) {
            if (!Array.isArray(object.entityResult))
                throw TypeError(".GetEntityByIdResponse.entityResult: array expected");
            message.entityResult = [];
            for (let i = 0; i < object.entityResult.length; ++i) {
                if (typeof object.entityResult[i] !== "object")
                    throw TypeError(".GetEntityByIdResponse.entityResult: object expected");
                message.entityResult[i] = $root.EntityResult.fromObject(object.entityResult[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a GetEntityByIdResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetEntityByIdResponse
     * @static
     * @param {GetEntityByIdResponse} message GetEntityByIdResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetEntityByIdResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.entity = [];
            object.entityResult = [];
        }
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.entity && message.entity.length) {
            object.entity = [];
            for (let j = 0; j < message.entity.length; ++j)
                object.entity[j] = $root.Entity.toObject(message.entity[j], options);
        }
        if (message.entityResult && message.entityResult.length) {
            object.entityResult = [];
            for (let j = 0; j < message.entityResult.length; ++j)
                object.entityResult[j] = $root.EntityResult.toObject(message.entityResult[j], options);
        }
        return object;
    };

    /**
     * Converts this GetEntityByIdResponse to JSON.
     * @function toJSON
     * @memberof GetEntityByIdResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetEntityByIdResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetEntityByIdResponse;
})();

export const GetGroupConversationUrlRequest = $root.GetGroupConversationUrlRequest = (() => {

    /**
     * Properties of a GetGroupConversationUrlRequest.
     * @exports IGetGroupConversationUrlRequest
     * @interface IGetGroupConversationUrlRequest
     * @property {IRequestHeader|null} [requestHeader] GetGroupConversationUrlRequest requestHeader
     * @property {IConversationId|null} [conversationId] GetGroupConversationUrlRequest conversationId
     */

    /**
     * Constructs a new GetGroupConversationUrlRequest.
     * @exports GetGroupConversationUrlRequest
     * @classdesc Represents a GetGroupConversationUrlRequest.
     * @implements IGetGroupConversationUrlRequest
     * @constructor
     * @param {IGetGroupConversationUrlRequest=} [properties] Properties to set
     */
    function GetGroupConversationUrlRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetGroupConversationUrlRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof GetGroupConversationUrlRequest
     * @instance
     */
    GetGroupConversationUrlRequest.prototype.requestHeader = null;

    /**
     * GetGroupConversationUrlRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof GetGroupConversationUrlRequest
     * @instance
     */
    GetGroupConversationUrlRequest.prototype.conversationId = null;

    /**
     * Creates a new GetGroupConversationUrlRequest instance using the specified properties.
     * @function create
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {IGetGroupConversationUrlRequest=} [properties] Properties to set
     * @returns {GetGroupConversationUrlRequest} GetGroupConversationUrlRequest instance
     */
    GetGroupConversationUrlRequest.create = function create(properties) {
        return new GetGroupConversationUrlRequest(properties);
    };

    /**
     * Encodes the specified GetGroupConversationUrlRequest message. Does not implicitly {@link GetGroupConversationUrlRequest.verify|verify} messages.
     * @function encode
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {IGetGroupConversationUrlRequest} message GetGroupConversationUrlRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetGroupConversationUrlRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetGroupConversationUrlRequest message, length delimited. Does not implicitly {@link GetGroupConversationUrlRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {IGetGroupConversationUrlRequest} message GetGroupConversationUrlRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetGroupConversationUrlRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetGroupConversationUrlRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetGroupConversationUrlRequest} GetGroupConversationUrlRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetGroupConversationUrlRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGroupConversationUrlRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetGroupConversationUrlRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetGroupConversationUrlRequest} GetGroupConversationUrlRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetGroupConversationUrlRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetGroupConversationUrlRequest message.
     * @function verify
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetGroupConversationUrlRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        return null;
    };

    /**
     * Creates a GetGroupConversationUrlRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetGroupConversationUrlRequest} GetGroupConversationUrlRequest
     */
    GetGroupConversationUrlRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetGroupConversationUrlRequest)
            return object;
        let message = new $root.GetGroupConversationUrlRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".GetGroupConversationUrlRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".GetGroupConversationUrlRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetGroupConversationUrlRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetGroupConversationUrlRequest
     * @static
     * @param {GetGroupConversationUrlRequest} message GetGroupConversationUrlRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetGroupConversationUrlRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        return object;
    };

    /**
     * Converts this GetGroupConversationUrlRequest to JSON.
     * @function toJSON
     * @memberof GetGroupConversationUrlRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetGroupConversationUrlRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetGroupConversationUrlRequest;
})();

export const GetGroupConversationUrlResponse = $root.GetGroupConversationUrlResponse = (() => {

    /**
     * Properties of a GetGroupConversationUrlResponse.
     * @exports IGetGroupConversationUrlResponse
     * @interface IGetGroupConversationUrlResponse
     * @property {IResponseHeader|null} [responseHeader] GetGroupConversationUrlResponse responseHeader
     * @property {string|null} [groupConversationUrl] GetGroupConversationUrlResponse groupConversationUrl
     */

    /**
     * Constructs a new GetGroupConversationUrlResponse.
     * @exports GetGroupConversationUrlResponse
     * @classdesc Represents a GetGroupConversationUrlResponse.
     * @implements IGetGroupConversationUrlResponse
     * @constructor
     * @param {IGetGroupConversationUrlResponse=} [properties] Properties to set
     */
    function GetGroupConversationUrlResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetGroupConversationUrlResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof GetGroupConversationUrlResponse
     * @instance
     */
    GetGroupConversationUrlResponse.prototype.responseHeader = null;

    /**
     * GetGroupConversationUrlResponse groupConversationUrl.
     * @member {string} groupConversationUrl
     * @memberof GetGroupConversationUrlResponse
     * @instance
     */
    GetGroupConversationUrlResponse.prototype.groupConversationUrl = "";

    /**
     * Creates a new GetGroupConversationUrlResponse instance using the specified properties.
     * @function create
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {IGetGroupConversationUrlResponse=} [properties] Properties to set
     * @returns {GetGroupConversationUrlResponse} GetGroupConversationUrlResponse instance
     */
    GetGroupConversationUrlResponse.create = function create(properties) {
        return new GetGroupConversationUrlResponse(properties);
    };

    /**
     * Encodes the specified GetGroupConversationUrlResponse message. Does not implicitly {@link GetGroupConversationUrlResponse.verify|verify} messages.
     * @function encode
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {IGetGroupConversationUrlResponse} message GetGroupConversationUrlResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetGroupConversationUrlResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.groupConversationUrl != null && message.hasOwnProperty("groupConversationUrl"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupConversationUrl);
        return writer;
    };

    /**
     * Encodes the specified GetGroupConversationUrlResponse message, length delimited. Does not implicitly {@link GetGroupConversationUrlResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {IGetGroupConversationUrlResponse} message GetGroupConversationUrlResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetGroupConversationUrlResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetGroupConversationUrlResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetGroupConversationUrlResponse} GetGroupConversationUrlResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetGroupConversationUrlResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetGroupConversationUrlResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.groupConversationUrl = reader.string();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetGroupConversationUrlResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetGroupConversationUrlResponse} GetGroupConversationUrlResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetGroupConversationUrlResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetGroupConversationUrlResponse message.
     * @function verify
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetGroupConversationUrlResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.groupConversationUrl != null && message.hasOwnProperty("groupConversationUrl"))
            if (!$util.isString(message.groupConversationUrl))
                return "groupConversationUrl: string expected";
        return null;
    };

    /**
     * Creates a GetGroupConversationUrlResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetGroupConversationUrlResponse} GetGroupConversationUrlResponse
     */
    GetGroupConversationUrlResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetGroupConversationUrlResponse)
            return object;
        let message = new $root.GetGroupConversationUrlResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".GetGroupConversationUrlResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.groupConversationUrl != null)
            message.groupConversationUrl = String(object.groupConversationUrl);
        return message;
    };

    /**
     * Creates a plain object from a GetGroupConversationUrlResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetGroupConversationUrlResponse
     * @static
     * @param {GetGroupConversationUrlResponse} message GetGroupConversationUrlResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetGroupConversationUrlResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.groupConversationUrl = "";
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.groupConversationUrl != null && message.hasOwnProperty("groupConversationUrl"))
            object.groupConversationUrl = message.groupConversationUrl;
        return object;
    };

    /**
     * Converts this GetGroupConversationUrlResponse to JSON.
     * @function toJSON
     * @memberof GetGroupConversationUrlResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetGroupConversationUrlResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetGroupConversationUrlResponse;
})();

export const GetSuggestedEntitiesRequest = $root.GetSuggestedEntitiesRequest = (() => {

    /**
     * Properties of a GetSuggestedEntitiesRequest.
     * @exports IGetSuggestedEntitiesRequest
     * @interface IGetSuggestedEntitiesRequest
     * @property {IRequestHeader|null} [requestHeader] GetSuggestedEntitiesRequest requestHeader
     * @property {number|Long|null} [maxCount] GetSuggestedEntitiesRequest maxCount
     * @property {ISuggestedContactGroupHash|null} [favorites] GetSuggestedEntitiesRequest favorites
     * @property {ISuggestedContactGroupHash|null} [contactsYouHangoutWith] GetSuggestedEntitiesRequest contactsYouHangoutWith
     * @property {ISuggestedContactGroupHash|null} [otherContactsOnHangouts] GetSuggestedEntitiesRequest otherContactsOnHangouts
     * @property {ISuggestedContactGroupHash|null} [otherContacts] GetSuggestedEntitiesRequest otherContacts
     * @property {ISuggestedContactGroupHash|null} [dismissedContacts] GetSuggestedEntitiesRequest dismissedContacts
     * @property {ISuggestedContactGroupHash|null} [pinnedFavorites] GetSuggestedEntitiesRequest pinnedFavorites
     */

    /**
     * Constructs a new GetSuggestedEntitiesRequest.
     * @exports GetSuggestedEntitiesRequest
     * @classdesc Represents a GetSuggestedEntitiesRequest.
     * @implements IGetSuggestedEntitiesRequest
     * @constructor
     * @param {IGetSuggestedEntitiesRequest=} [properties] Properties to set
     */
    function GetSuggestedEntitiesRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSuggestedEntitiesRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.requestHeader = null;

    /**
     * GetSuggestedEntitiesRequest maxCount.
     * @member {number|Long} maxCount
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.maxCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * GetSuggestedEntitiesRequest favorites.
     * @member {ISuggestedContactGroupHash|null|undefined} favorites
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.favorites = null;

    /**
     * GetSuggestedEntitiesRequest contactsYouHangoutWith.
     * @member {ISuggestedContactGroupHash|null|undefined} contactsYouHangoutWith
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.contactsYouHangoutWith = null;

    /**
     * GetSuggestedEntitiesRequest otherContactsOnHangouts.
     * @member {ISuggestedContactGroupHash|null|undefined} otherContactsOnHangouts
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.otherContactsOnHangouts = null;

    /**
     * GetSuggestedEntitiesRequest otherContacts.
     * @member {ISuggestedContactGroupHash|null|undefined} otherContacts
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.otherContacts = null;

    /**
     * GetSuggestedEntitiesRequest dismissedContacts.
     * @member {ISuggestedContactGroupHash|null|undefined} dismissedContacts
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.dismissedContacts = null;

    /**
     * GetSuggestedEntitiesRequest pinnedFavorites.
     * @member {ISuggestedContactGroupHash|null|undefined} pinnedFavorites
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     */
    GetSuggestedEntitiesRequest.prototype.pinnedFavorites = null;

    /**
     * Creates a new GetSuggestedEntitiesRequest instance using the specified properties.
     * @function create
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {IGetSuggestedEntitiesRequest=} [properties] Properties to set
     * @returns {GetSuggestedEntitiesRequest} GetSuggestedEntitiesRequest instance
     */
    GetSuggestedEntitiesRequest.create = function create(properties) {
        return new GetSuggestedEntitiesRequest(properties);
    };

    /**
     * Encodes the specified GetSuggestedEntitiesRequest message. Does not implicitly {@link GetSuggestedEntitiesRequest.verify|verify} messages.
     * @function encode
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {IGetSuggestedEntitiesRequest} message GetSuggestedEntitiesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSuggestedEntitiesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxCount);
        if (message.favorites != null && message.hasOwnProperty("favorites"))
            $root.SuggestedContactGroupHash.encode(message.favorites, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith"))
            $root.SuggestedContactGroupHash.encode(message.contactsYouHangoutWith, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts"))
            $root.SuggestedContactGroupHash.encode(message.otherContactsOnHangouts, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts"))
            $root.SuggestedContactGroupHash.encode(message.otherContacts, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts"))
            $root.SuggestedContactGroupHash.encode(message.dismissedContacts, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites"))
            $root.SuggestedContactGroupHash.encode(message.pinnedFavorites, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetSuggestedEntitiesRequest message, length delimited. Does not implicitly {@link GetSuggestedEntitiesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {IGetSuggestedEntitiesRequest} message GetSuggestedEntitiesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSuggestedEntitiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSuggestedEntitiesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetSuggestedEntitiesRequest} GetSuggestedEntitiesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSuggestedEntitiesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSuggestedEntitiesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 4:
                message.maxCount = reader.uint64();
                break;
            case 8:
                message.favorites = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            case 9:
                message.contactsYouHangoutWith = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            case 10:
                message.otherContactsOnHangouts = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            case 11:
                message.otherContacts = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            case 12:
                message.dismissedContacts = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            case 13:
                message.pinnedFavorites = $root.SuggestedContactGroupHash.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetSuggestedEntitiesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetSuggestedEntitiesRequest} GetSuggestedEntitiesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSuggestedEntitiesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSuggestedEntitiesRequest message.
     * @function verify
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSuggestedEntitiesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            if (!$util.isInteger(message.maxCount) && !(message.maxCount && $util.isInteger(message.maxCount.low) && $util.isInteger(message.maxCount.high)))
                return "maxCount: integer|Long expected";
        if (message.favorites != null && message.hasOwnProperty("favorites")) {
            let error = $root.SuggestedContactGroupHash.verify(message.favorites);
            if (error)
                return "favorites." + error;
        }
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith")) {
            let error = $root.SuggestedContactGroupHash.verify(message.contactsYouHangoutWith);
            if (error)
                return "contactsYouHangoutWith." + error;
        }
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts")) {
            let error = $root.SuggestedContactGroupHash.verify(message.otherContactsOnHangouts);
            if (error)
                return "otherContactsOnHangouts." + error;
        }
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts")) {
            let error = $root.SuggestedContactGroupHash.verify(message.otherContacts);
            if (error)
                return "otherContacts." + error;
        }
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts")) {
            let error = $root.SuggestedContactGroupHash.verify(message.dismissedContacts);
            if (error)
                return "dismissedContacts." + error;
        }
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites")) {
            let error = $root.SuggestedContactGroupHash.verify(message.pinnedFavorites);
            if (error)
                return "pinnedFavorites." + error;
        }
        return null;
    };

    /**
     * Creates a GetSuggestedEntitiesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetSuggestedEntitiesRequest} GetSuggestedEntitiesRequest
     */
    GetSuggestedEntitiesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetSuggestedEntitiesRequest)
            return object;
        let message = new $root.GetSuggestedEntitiesRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.maxCount != null)
            if ($util.Long)
                (message.maxCount = $util.Long.fromValue(object.maxCount)).unsigned = true;
            else if (typeof object.maxCount === "string")
                message.maxCount = parseInt(object.maxCount, 10);
            else if (typeof object.maxCount === "number")
                message.maxCount = object.maxCount;
            else if (typeof object.maxCount === "object")
                message.maxCount = new $util.LongBits(object.maxCount.low >>> 0, object.maxCount.high >>> 0).toNumber(true);
        if (object.favorites != null) {
            if (typeof object.favorites !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.favorites: object expected");
            message.favorites = $root.SuggestedContactGroupHash.fromObject(object.favorites);
        }
        if (object.contactsYouHangoutWith != null) {
            if (typeof object.contactsYouHangoutWith !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.contactsYouHangoutWith: object expected");
            message.contactsYouHangoutWith = $root.SuggestedContactGroupHash.fromObject(object.contactsYouHangoutWith);
        }
        if (object.otherContactsOnHangouts != null) {
            if (typeof object.otherContactsOnHangouts !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.otherContactsOnHangouts: object expected");
            message.otherContactsOnHangouts = $root.SuggestedContactGroupHash.fromObject(object.otherContactsOnHangouts);
        }
        if (object.otherContacts != null) {
            if (typeof object.otherContacts !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.otherContacts: object expected");
            message.otherContacts = $root.SuggestedContactGroupHash.fromObject(object.otherContacts);
        }
        if (object.dismissedContacts != null) {
            if (typeof object.dismissedContacts !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.dismissedContacts: object expected");
            message.dismissedContacts = $root.SuggestedContactGroupHash.fromObject(object.dismissedContacts);
        }
        if (object.pinnedFavorites != null) {
            if (typeof object.pinnedFavorites !== "object")
                throw TypeError(".GetSuggestedEntitiesRequest.pinnedFavorites: object expected");
            message.pinnedFavorites = $root.SuggestedContactGroupHash.fromObject(object.pinnedFavorites);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetSuggestedEntitiesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetSuggestedEntitiesRequest
     * @static
     * @param {GetSuggestedEntitiesRequest} message GetSuggestedEntitiesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSuggestedEntitiesRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxCount = options.longs === String ? "0" : 0;
            object.favorites = null;
            object.contactsYouHangoutWith = null;
            object.otherContactsOnHangouts = null;
            object.otherContacts = null;
            object.dismissedContacts = null;
            object.pinnedFavorites = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            if (typeof message.maxCount === "number")
                object.maxCount = options.longs === String ? String(message.maxCount) : message.maxCount;
            else
                object.maxCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxCount) : options.longs === Number ? new $util.LongBits(message.maxCount.low >>> 0, message.maxCount.high >>> 0).toNumber(true) : message.maxCount;
        if (message.favorites != null && message.hasOwnProperty("favorites"))
            object.favorites = $root.SuggestedContactGroupHash.toObject(message.favorites, options);
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith"))
            object.contactsYouHangoutWith = $root.SuggestedContactGroupHash.toObject(message.contactsYouHangoutWith, options);
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts"))
            object.otherContactsOnHangouts = $root.SuggestedContactGroupHash.toObject(message.otherContactsOnHangouts, options);
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts"))
            object.otherContacts = $root.SuggestedContactGroupHash.toObject(message.otherContacts, options);
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts"))
            object.dismissedContacts = $root.SuggestedContactGroupHash.toObject(message.dismissedContacts, options);
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites"))
            object.pinnedFavorites = $root.SuggestedContactGroupHash.toObject(message.pinnedFavorites, options);
        return object;
    };

    /**
     * Converts this GetSuggestedEntitiesRequest to JSON.
     * @function toJSON
     * @memberof GetSuggestedEntitiesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSuggestedEntitiesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetSuggestedEntitiesRequest;
})();

export const GetSuggestedEntitiesResponse = $root.GetSuggestedEntitiesResponse = (() => {

    /**
     * Properties of a GetSuggestedEntitiesResponse.
     * @exports IGetSuggestedEntitiesResponse
     * @interface IGetSuggestedEntitiesResponse
     * @property {IResponseHeader|null} [responseHeader] GetSuggestedEntitiesResponse responseHeader
     * @property {Array.<IEntity>|null} [entity] GetSuggestedEntitiesResponse entity
     * @property {ISuggestedContactGroup|null} [favorites] GetSuggestedEntitiesResponse favorites
     * @property {ISuggestedContactGroup|null} [contactsYouHangoutWith] GetSuggestedEntitiesResponse contactsYouHangoutWith
     * @property {ISuggestedContactGroup|null} [otherContactsOnHangouts] GetSuggestedEntitiesResponse otherContactsOnHangouts
     * @property {ISuggestedContactGroup|null} [otherContacts] GetSuggestedEntitiesResponse otherContacts
     * @property {ISuggestedContactGroup|null} [dismissedContacts] GetSuggestedEntitiesResponse dismissedContacts
     * @property {ISuggestedContactGroup|null} [pinnedFavorites] GetSuggestedEntitiesResponse pinnedFavorites
     */

    /**
     * Constructs a new GetSuggestedEntitiesResponse.
     * @exports GetSuggestedEntitiesResponse
     * @classdesc Represents a GetSuggestedEntitiesResponse.
     * @implements IGetSuggestedEntitiesResponse
     * @constructor
     * @param {IGetSuggestedEntitiesResponse=} [properties] Properties to set
     */
    function GetSuggestedEntitiesResponse(properties) {
        this.entity = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSuggestedEntitiesResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.responseHeader = null;

    /**
     * GetSuggestedEntitiesResponse entity.
     * @member {Array.<IEntity>} entity
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.entity = $util.emptyArray;

    /**
     * GetSuggestedEntitiesResponse favorites.
     * @member {ISuggestedContactGroup|null|undefined} favorites
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.favorites = null;

    /**
     * GetSuggestedEntitiesResponse contactsYouHangoutWith.
     * @member {ISuggestedContactGroup|null|undefined} contactsYouHangoutWith
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.contactsYouHangoutWith = null;

    /**
     * GetSuggestedEntitiesResponse otherContactsOnHangouts.
     * @member {ISuggestedContactGroup|null|undefined} otherContactsOnHangouts
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.otherContactsOnHangouts = null;

    /**
     * GetSuggestedEntitiesResponse otherContacts.
     * @member {ISuggestedContactGroup|null|undefined} otherContacts
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.otherContacts = null;

    /**
     * GetSuggestedEntitiesResponse dismissedContacts.
     * @member {ISuggestedContactGroup|null|undefined} dismissedContacts
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.dismissedContacts = null;

    /**
     * GetSuggestedEntitiesResponse pinnedFavorites.
     * @member {ISuggestedContactGroup|null|undefined} pinnedFavorites
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     */
    GetSuggestedEntitiesResponse.prototype.pinnedFavorites = null;

    /**
     * Creates a new GetSuggestedEntitiesResponse instance using the specified properties.
     * @function create
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {IGetSuggestedEntitiesResponse=} [properties] Properties to set
     * @returns {GetSuggestedEntitiesResponse} GetSuggestedEntitiesResponse instance
     */
    GetSuggestedEntitiesResponse.create = function create(properties) {
        return new GetSuggestedEntitiesResponse(properties);
    };

    /**
     * Encodes the specified GetSuggestedEntitiesResponse message. Does not implicitly {@link GetSuggestedEntitiesResponse.verify|verify} messages.
     * @function encode
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {IGetSuggestedEntitiesResponse} message GetSuggestedEntitiesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSuggestedEntitiesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.entity != null && message.entity.length)
            for (let i = 0; i < message.entity.length; ++i)
                $root.Entity.encode(message.entity[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.favorites != null && message.hasOwnProperty("favorites"))
            $root.SuggestedContactGroup.encode(message.favorites, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith"))
            $root.SuggestedContactGroup.encode(message.contactsYouHangoutWith, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts"))
            $root.SuggestedContactGroup.encode(message.otherContactsOnHangouts, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts"))
            $root.SuggestedContactGroup.encode(message.otherContacts, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts"))
            $root.SuggestedContactGroup.encode(message.dismissedContacts, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites"))
            $root.SuggestedContactGroup.encode(message.pinnedFavorites, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetSuggestedEntitiesResponse message, length delimited. Does not implicitly {@link GetSuggestedEntitiesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {IGetSuggestedEntitiesResponse} message GetSuggestedEntitiesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSuggestedEntitiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSuggestedEntitiesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetSuggestedEntitiesResponse} GetSuggestedEntitiesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSuggestedEntitiesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSuggestedEntitiesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.entity && message.entity.length))
                    message.entity = [];
                message.entity.push($root.Entity.decode(reader, reader.uint32()));
                break;
            case 4:
                message.favorites = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            case 5:
                message.contactsYouHangoutWith = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            case 6:
                message.otherContactsOnHangouts = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            case 7:
                message.otherContacts = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            case 8:
                message.dismissedContacts = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            case 9:
                message.pinnedFavorites = $root.SuggestedContactGroup.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetSuggestedEntitiesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetSuggestedEntitiesResponse} GetSuggestedEntitiesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSuggestedEntitiesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSuggestedEntitiesResponse message.
     * @function verify
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSuggestedEntitiesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.entity != null && message.hasOwnProperty("entity")) {
            if (!Array.isArray(message.entity))
                return "entity: array expected";
            for (let i = 0; i < message.entity.length; ++i) {
                let error = $root.Entity.verify(message.entity[i]);
                if (error)
                    return "entity." + error;
            }
        }
        if (message.favorites != null && message.hasOwnProperty("favorites")) {
            let error = $root.SuggestedContactGroup.verify(message.favorites);
            if (error)
                return "favorites." + error;
        }
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith")) {
            let error = $root.SuggestedContactGroup.verify(message.contactsYouHangoutWith);
            if (error)
                return "contactsYouHangoutWith." + error;
        }
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts")) {
            let error = $root.SuggestedContactGroup.verify(message.otherContactsOnHangouts);
            if (error)
                return "otherContactsOnHangouts." + error;
        }
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts")) {
            let error = $root.SuggestedContactGroup.verify(message.otherContacts);
            if (error)
                return "otherContacts." + error;
        }
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts")) {
            let error = $root.SuggestedContactGroup.verify(message.dismissedContacts);
            if (error)
                return "dismissedContacts." + error;
        }
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites")) {
            let error = $root.SuggestedContactGroup.verify(message.pinnedFavorites);
            if (error)
                return "pinnedFavorites." + error;
        }
        return null;
    };

    /**
     * Creates a GetSuggestedEntitiesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetSuggestedEntitiesResponse} GetSuggestedEntitiesResponse
     */
    GetSuggestedEntitiesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetSuggestedEntitiesResponse)
            return object;
        let message = new $root.GetSuggestedEntitiesResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.entity) {
            if (!Array.isArray(object.entity))
                throw TypeError(".GetSuggestedEntitiesResponse.entity: array expected");
            message.entity = [];
            for (let i = 0; i < object.entity.length; ++i) {
                if (typeof object.entity[i] !== "object")
                    throw TypeError(".GetSuggestedEntitiesResponse.entity: object expected");
                message.entity[i] = $root.Entity.fromObject(object.entity[i]);
            }
        }
        if (object.favorites != null) {
            if (typeof object.favorites !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.favorites: object expected");
            message.favorites = $root.SuggestedContactGroup.fromObject(object.favorites);
        }
        if (object.contactsYouHangoutWith != null) {
            if (typeof object.contactsYouHangoutWith !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.contactsYouHangoutWith: object expected");
            message.contactsYouHangoutWith = $root.SuggestedContactGroup.fromObject(object.contactsYouHangoutWith);
        }
        if (object.otherContactsOnHangouts != null) {
            if (typeof object.otherContactsOnHangouts !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.otherContactsOnHangouts: object expected");
            message.otherContactsOnHangouts = $root.SuggestedContactGroup.fromObject(object.otherContactsOnHangouts);
        }
        if (object.otherContacts != null) {
            if (typeof object.otherContacts !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.otherContacts: object expected");
            message.otherContacts = $root.SuggestedContactGroup.fromObject(object.otherContacts);
        }
        if (object.dismissedContacts != null) {
            if (typeof object.dismissedContacts !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.dismissedContacts: object expected");
            message.dismissedContacts = $root.SuggestedContactGroup.fromObject(object.dismissedContacts);
        }
        if (object.pinnedFavorites != null) {
            if (typeof object.pinnedFavorites !== "object")
                throw TypeError(".GetSuggestedEntitiesResponse.pinnedFavorites: object expected");
            message.pinnedFavorites = $root.SuggestedContactGroup.fromObject(object.pinnedFavorites);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetSuggestedEntitiesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetSuggestedEntitiesResponse
     * @static
     * @param {GetSuggestedEntitiesResponse} message GetSuggestedEntitiesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSuggestedEntitiesResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.entity = [];
        if (options.defaults) {
            object.responseHeader = null;
            object.favorites = null;
            object.contactsYouHangoutWith = null;
            object.otherContactsOnHangouts = null;
            object.otherContacts = null;
            object.dismissedContacts = null;
            object.pinnedFavorites = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.entity && message.entity.length) {
            object.entity = [];
            for (let j = 0; j < message.entity.length; ++j)
                object.entity[j] = $root.Entity.toObject(message.entity[j], options);
        }
        if (message.favorites != null && message.hasOwnProperty("favorites"))
            object.favorites = $root.SuggestedContactGroup.toObject(message.favorites, options);
        if (message.contactsYouHangoutWith != null && message.hasOwnProperty("contactsYouHangoutWith"))
            object.contactsYouHangoutWith = $root.SuggestedContactGroup.toObject(message.contactsYouHangoutWith, options);
        if (message.otherContactsOnHangouts != null && message.hasOwnProperty("otherContactsOnHangouts"))
            object.otherContactsOnHangouts = $root.SuggestedContactGroup.toObject(message.otherContactsOnHangouts, options);
        if (message.otherContacts != null && message.hasOwnProperty("otherContacts"))
            object.otherContacts = $root.SuggestedContactGroup.toObject(message.otherContacts, options);
        if (message.dismissedContacts != null && message.hasOwnProperty("dismissedContacts"))
            object.dismissedContacts = $root.SuggestedContactGroup.toObject(message.dismissedContacts, options);
        if (message.pinnedFavorites != null && message.hasOwnProperty("pinnedFavorites"))
            object.pinnedFavorites = $root.SuggestedContactGroup.toObject(message.pinnedFavorites, options);
        return object;
    };

    /**
     * Converts this GetSuggestedEntitiesResponse to JSON.
     * @function toJSON
     * @memberof GetSuggestedEntitiesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSuggestedEntitiesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetSuggestedEntitiesResponse;
})();

export const GetSelfInfoRequest = $root.GetSelfInfoRequest = (() => {

    /**
     * Properties of a GetSelfInfoRequest.
     * @exports IGetSelfInfoRequest
     * @interface IGetSelfInfoRequest
     * @property {IRequestHeader|null} [requestHeader] GetSelfInfoRequest requestHeader
     */

    /**
     * Constructs a new GetSelfInfoRequest.
     * @exports GetSelfInfoRequest
     * @classdesc Represents a GetSelfInfoRequest.
     * @implements IGetSelfInfoRequest
     * @constructor
     * @param {IGetSelfInfoRequest=} [properties] Properties to set
     */
    function GetSelfInfoRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSelfInfoRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof GetSelfInfoRequest
     * @instance
     */
    GetSelfInfoRequest.prototype.requestHeader = null;

    /**
     * Creates a new GetSelfInfoRequest instance using the specified properties.
     * @function create
     * @memberof GetSelfInfoRequest
     * @static
     * @param {IGetSelfInfoRequest=} [properties] Properties to set
     * @returns {GetSelfInfoRequest} GetSelfInfoRequest instance
     */
    GetSelfInfoRequest.create = function create(properties) {
        return new GetSelfInfoRequest(properties);
    };

    /**
     * Encodes the specified GetSelfInfoRequest message. Does not implicitly {@link GetSelfInfoRequest.verify|verify} messages.
     * @function encode
     * @memberof GetSelfInfoRequest
     * @static
     * @param {IGetSelfInfoRequest} message GetSelfInfoRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSelfInfoRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetSelfInfoRequest message, length delimited. Does not implicitly {@link GetSelfInfoRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetSelfInfoRequest
     * @static
     * @param {IGetSelfInfoRequest} message GetSelfInfoRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSelfInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSelfInfoRequest message from the specified reader or buffer.
     * @function decode
     * @memberof GetSelfInfoRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetSelfInfoRequest} GetSelfInfoRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSelfInfoRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSelfInfoRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetSelfInfoRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetSelfInfoRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetSelfInfoRequest} GetSelfInfoRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSelfInfoRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSelfInfoRequest message.
     * @function verify
     * @memberof GetSelfInfoRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSelfInfoRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        return null;
    };

    /**
     * Creates a GetSelfInfoRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetSelfInfoRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetSelfInfoRequest} GetSelfInfoRequest
     */
    GetSelfInfoRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.GetSelfInfoRequest)
            return object;
        let message = new $root.GetSelfInfoRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".GetSelfInfoRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetSelfInfoRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetSelfInfoRequest
     * @static
     * @param {GetSelfInfoRequest} message GetSelfInfoRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSelfInfoRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.requestHeader = null;
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        return object;
    };

    /**
     * Converts this GetSelfInfoRequest to JSON.
     * @function toJSON
     * @memberof GetSelfInfoRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSelfInfoRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetSelfInfoRequest;
})();

export const GetSelfInfoResponse = $root.GetSelfInfoResponse = (() => {

    /**
     * Properties of a GetSelfInfoResponse.
     * @exports IGetSelfInfoResponse
     * @interface IGetSelfInfoResponse
     * @property {IResponseHeader|null} [responseHeader] GetSelfInfoResponse responseHeader
     * @property {IEntity|null} [selfEntity] GetSelfInfoResponse selfEntity
     * @property {boolean|null} [isKnownMinor] GetSelfInfoResponse isKnownMinor
     * @property {IDoNotDisturbSetting|null} [dndState] GetSelfInfoResponse dndState
     * @property {IDesktopOffSetting|null} [desktopOffSetting] GetSelfInfoResponse desktopOffSetting
     * @property {IPhoneData|null} [phoneData] GetSelfInfoResponse phoneData
     * @property {Array.<IConfigurationBit>|null} [configurationBit] GetSelfInfoResponse configurationBit
     * @property {IDesktopOffState|null} [desktopOffState] GetSelfInfoResponse desktopOffState
     * @property {boolean|null} [googlePlusUser] GetSelfInfoResponse googlePlusUser
     * @property {IDesktopSoundSetting|null} [desktopSoundSetting] GetSelfInfoResponse desktopSoundSetting
     * @property {IRichPresenceState|null} [richPresenceState] GetSelfInfoResponse richPresenceState
     * @property {ICountry|null} [defaultCountry] GetSelfInfoResponse defaultCountry
     */

    /**
     * Constructs a new GetSelfInfoResponse.
     * @exports GetSelfInfoResponse
     * @classdesc Represents a GetSelfInfoResponse.
     * @implements IGetSelfInfoResponse
     * @constructor
     * @param {IGetSelfInfoResponse=} [properties] Properties to set
     */
    function GetSelfInfoResponse(properties) {
        this.configurationBit = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * GetSelfInfoResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.responseHeader = null;

    /**
     * GetSelfInfoResponse selfEntity.
     * @member {IEntity|null|undefined} selfEntity
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.selfEntity = null;

    /**
     * GetSelfInfoResponse isKnownMinor.
     * @member {boolean} isKnownMinor
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.isKnownMinor = false;

    /**
     * GetSelfInfoResponse dndState.
     * @member {IDoNotDisturbSetting|null|undefined} dndState
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.dndState = null;

    /**
     * GetSelfInfoResponse desktopOffSetting.
     * @member {IDesktopOffSetting|null|undefined} desktopOffSetting
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.desktopOffSetting = null;

    /**
     * GetSelfInfoResponse phoneData.
     * @member {IPhoneData|null|undefined} phoneData
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.phoneData = null;

    /**
     * GetSelfInfoResponse configurationBit.
     * @member {Array.<IConfigurationBit>} configurationBit
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.configurationBit = $util.emptyArray;

    /**
     * GetSelfInfoResponse desktopOffState.
     * @member {IDesktopOffState|null|undefined} desktopOffState
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.desktopOffState = null;

    /**
     * GetSelfInfoResponse googlePlusUser.
     * @member {boolean} googlePlusUser
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.googlePlusUser = false;

    /**
     * GetSelfInfoResponse desktopSoundSetting.
     * @member {IDesktopSoundSetting|null|undefined} desktopSoundSetting
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.desktopSoundSetting = null;

    /**
     * GetSelfInfoResponse richPresenceState.
     * @member {IRichPresenceState|null|undefined} richPresenceState
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.richPresenceState = null;

    /**
     * GetSelfInfoResponse defaultCountry.
     * @member {ICountry|null|undefined} defaultCountry
     * @memberof GetSelfInfoResponse
     * @instance
     */
    GetSelfInfoResponse.prototype.defaultCountry = null;

    /**
     * Creates a new GetSelfInfoResponse instance using the specified properties.
     * @function create
     * @memberof GetSelfInfoResponse
     * @static
     * @param {IGetSelfInfoResponse=} [properties] Properties to set
     * @returns {GetSelfInfoResponse} GetSelfInfoResponse instance
     */
    GetSelfInfoResponse.create = function create(properties) {
        return new GetSelfInfoResponse(properties);
    };

    /**
     * Encodes the specified GetSelfInfoResponse message. Does not implicitly {@link GetSelfInfoResponse.verify|verify} messages.
     * @function encode
     * @memberof GetSelfInfoResponse
     * @static
     * @param {IGetSelfInfoResponse} message GetSelfInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSelfInfoResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.selfEntity != null && message.hasOwnProperty("selfEntity"))
            $root.Entity.encode(message.selfEntity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.isKnownMinor != null && message.hasOwnProperty("isKnownMinor"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isKnownMinor);
        if (message.dndState != null && message.hasOwnProperty("dndState"))
            $root.DoNotDisturbSetting.encode(message.dndState, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            $root.DesktopOffSetting.encode(message.desktopOffSetting, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.phoneData != null && message.hasOwnProperty("phoneData"))
            $root.PhoneData.encode(message.phoneData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.configurationBit != null && message.configurationBit.length)
            for (let i = 0; i < message.configurationBit.length; ++i)
                $root.ConfigurationBit.encode(message.configurationBit[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState"))
            $root.DesktopOffState.encode(message.desktopOffState, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.googlePlusUser != null && message.hasOwnProperty("googlePlusUser"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.googlePlusUser);
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting"))
            $root.DesktopSoundSetting.encode(message.desktopSoundSetting, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
        if (message.richPresenceState != null && message.hasOwnProperty("richPresenceState"))
            $root.RichPresenceState.encode(message.richPresenceState, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
        if (message.defaultCountry != null && message.hasOwnProperty("defaultCountry"))
            $root.Country.encode(message.defaultCountry, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified GetSelfInfoResponse message, length delimited. Does not implicitly {@link GetSelfInfoResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof GetSelfInfoResponse
     * @static
     * @param {IGetSelfInfoResponse} message GetSelfInfoResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    GetSelfInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a GetSelfInfoResponse message from the specified reader or buffer.
     * @function decode
     * @memberof GetSelfInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GetSelfInfoResponse} GetSelfInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSelfInfoResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GetSelfInfoResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.selfEntity = $root.Entity.decode(reader, reader.uint32());
                break;
            case 3:
                message.isKnownMinor = reader.bool();
                break;
            case 5:
                message.dndState = $root.DoNotDisturbSetting.decode(reader, reader.uint32());
                break;
            case 6:
                message.desktopOffSetting = $root.DesktopOffSetting.decode(reader, reader.uint32());
                break;
            case 7:
                message.phoneData = $root.PhoneData.decode(reader, reader.uint32());
                break;
            case 8:
                if (!(message.configurationBit && message.configurationBit.length))
                    message.configurationBit = [];
                message.configurationBit.push($root.ConfigurationBit.decode(reader, reader.uint32()));
                break;
            case 9:
                message.desktopOffState = $root.DesktopOffState.decode(reader, reader.uint32());
                break;
            case 10:
                message.googlePlusUser = reader.bool();
                break;
            case 11:
                message.desktopSoundSetting = $root.DesktopSoundSetting.decode(reader, reader.uint32());
                break;
            case 12:
                message.richPresenceState = $root.RichPresenceState.decode(reader, reader.uint32());
                break;
            case 19:
                message.defaultCountry = $root.Country.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a GetSelfInfoResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof GetSelfInfoResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {GetSelfInfoResponse} GetSelfInfoResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GetSelfInfoResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a GetSelfInfoResponse message.
     * @function verify
     * @memberof GetSelfInfoResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    GetSelfInfoResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.selfEntity != null && message.hasOwnProperty("selfEntity")) {
            let error = $root.Entity.verify(message.selfEntity);
            if (error)
                return "selfEntity." + error;
        }
        if (message.isKnownMinor != null && message.hasOwnProperty("isKnownMinor"))
            if (typeof message.isKnownMinor !== "boolean")
                return "isKnownMinor: boolean expected";
        if (message.dndState != null && message.hasOwnProperty("dndState")) {
            let error = $root.DoNotDisturbSetting.verify(message.dndState);
            if (error)
                return "dndState." + error;
        }
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting")) {
            let error = $root.DesktopOffSetting.verify(message.desktopOffSetting);
            if (error)
                return "desktopOffSetting." + error;
        }
        if (message.phoneData != null && message.hasOwnProperty("phoneData")) {
            let error = $root.PhoneData.verify(message.phoneData);
            if (error)
                return "phoneData." + error;
        }
        if (message.configurationBit != null && message.hasOwnProperty("configurationBit")) {
            if (!Array.isArray(message.configurationBit))
                return "configurationBit: array expected";
            for (let i = 0; i < message.configurationBit.length; ++i) {
                let error = $root.ConfigurationBit.verify(message.configurationBit[i]);
                if (error)
                    return "configurationBit." + error;
            }
        }
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState")) {
            let error = $root.DesktopOffState.verify(message.desktopOffState);
            if (error)
                return "desktopOffState." + error;
        }
        if (message.googlePlusUser != null && message.hasOwnProperty("googlePlusUser"))
            if (typeof message.googlePlusUser !== "boolean")
                return "googlePlusUser: boolean expected";
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting")) {
            let error = $root.DesktopSoundSetting.verify(message.desktopSoundSetting);
            if (error)
                return "desktopSoundSetting." + error;
        }
        if (message.richPresenceState != null && message.hasOwnProperty("richPresenceState")) {
            let error = $root.RichPresenceState.verify(message.richPresenceState);
            if (error)
                return "richPresenceState." + error;
        }
        if (message.defaultCountry != null && message.hasOwnProperty("defaultCountry")) {
            let error = $root.Country.verify(message.defaultCountry);
            if (error)
                return "defaultCountry." + error;
        }
        return null;
    };

    /**
     * Creates a GetSelfInfoResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof GetSelfInfoResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {GetSelfInfoResponse} GetSelfInfoResponse
     */
    GetSelfInfoResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.GetSelfInfoResponse)
            return object;
        let message = new $root.GetSelfInfoResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".GetSelfInfoResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.selfEntity != null) {
            if (typeof object.selfEntity !== "object")
                throw TypeError(".GetSelfInfoResponse.selfEntity: object expected");
            message.selfEntity = $root.Entity.fromObject(object.selfEntity);
        }
        if (object.isKnownMinor != null)
            message.isKnownMinor = Boolean(object.isKnownMinor);
        if (object.dndState != null) {
            if (typeof object.dndState !== "object")
                throw TypeError(".GetSelfInfoResponse.dndState: object expected");
            message.dndState = $root.DoNotDisturbSetting.fromObject(object.dndState);
        }
        if (object.desktopOffSetting != null) {
            if (typeof object.desktopOffSetting !== "object")
                throw TypeError(".GetSelfInfoResponse.desktopOffSetting: object expected");
            message.desktopOffSetting = $root.DesktopOffSetting.fromObject(object.desktopOffSetting);
        }
        if (object.phoneData != null) {
            if (typeof object.phoneData !== "object")
                throw TypeError(".GetSelfInfoResponse.phoneData: object expected");
            message.phoneData = $root.PhoneData.fromObject(object.phoneData);
        }
        if (object.configurationBit) {
            if (!Array.isArray(object.configurationBit))
                throw TypeError(".GetSelfInfoResponse.configurationBit: array expected");
            message.configurationBit = [];
            for (let i = 0; i < object.configurationBit.length; ++i) {
                if (typeof object.configurationBit[i] !== "object")
                    throw TypeError(".GetSelfInfoResponse.configurationBit: object expected");
                message.configurationBit[i] = $root.ConfigurationBit.fromObject(object.configurationBit[i]);
            }
        }
        if (object.desktopOffState != null) {
            if (typeof object.desktopOffState !== "object")
                throw TypeError(".GetSelfInfoResponse.desktopOffState: object expected");
            message.desktopOffState = $root.DesktopOffState.fromObject(object.desktopOffState);
        }
        if (object.googlePlusUser != null)
            message.googlePlusUser = Boolean(object.googlePlusUser);
        if (object.desktopSoundSetting != null) {
            if (typeof object.desktopSoundSetting !== "object")
                throw TypeError(".GetSelfInfoResponse.desktopSoundSetting: object expected");
            message.desktopSoundSetting = $root.DesktopSoundSetting.fromObject(object.desktopSoundSetting);
        }
        if (object.richPresenceState != null) {
            if (typeof object.richPresenceState !== "object")
                throw TypeError(".GetSelfInfoResponse.richPresenceState: object expected");
            message.richPresenceState = $root.RichPresenceState.fromObject(object.richPresenceState);
        }
        if (object.defaultCountry != null) {
            if (typeof object.defaultCountry !== "object")
                throw TypeError(".GetSelfInfoResponse.defaultCountry: object expected");
            message.defaultCountry = $root.Country.fromObject(object.defaultCountry);
        }
        return message;
    };

    /**
     * Creates a plain object from a GetSelfInfoResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof GetSelfInfoResponse
     * @static
     * @param {GetSelfInfoResponse} message GetSelfInfoResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    GetSelfInfoResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.configurationBit = [];
        if (options.defaults) {
            object.responseHeader = null;
            object.selfEntity = null;
            object.isKnownMinor = false;
            object.dndState = null;
            object.desktopOffSetting = null;
            object.phoneData = null;
            object.desktopOffState = null;
            object.googlePlusUser = false;
            object.desktopSoundSetting = null;
            object.richPresenceState = null;
            object.defaultCountry = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.selfEntity != null && message.hasOwnProperty("selfEntity"))
            object.selfEntity = $root.Entity.toObject(message.selfEntity, options);
        if (message.isKnownMinor != null && message.hasOwnProperty("isKnownMinor"))
            object.isKnownMinor = message.isKnownMinor;
        if (message.dndState != null && message.hasOwnProperty("dndState"))
            object.dndState = $root.DoNotDisturbSetting.toObject(message.dndState, options);
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            object.desktopOffSetting = $root.DesktopOffSetting.toObject(message.desktopOffSetting, options);
        if (message.phoneData != null && message.hasOwnProperty("phoneData"))
            object.phoneData = $root.PhoneData.toObject(message.phoneData, options);
        if (message.configurationBit && message.configurationBit.length) {
            object.configurationBit = [];
            for (let j = 0; j < message.configurationBit.length; ++j)
                object.configurationBit[j] = $root.ConfigurationBit.toObject(message.configurationBit[j], options);
        }
        if (message.desktopOffState != null && message.hasOwnProperty("desktopOffState"))
            object.desktopOffState = $root.DesktopOffState.toObject(message.desktopOffState, options);
        if (message.googlePlusUser != null && message.hasOwnProperty("googlePlusUser"))
            object.googlePlusUser = message.googlePlusUser;
        if (message.desktopSoundSetting != null && message.hasOwnProperty("desktopSoundSetting"))
            object.desktopSoundSetting = $root.DesktopSoundSetting.toObject(message.desktopSoundSetting, options);
        if (message.richPresenceState != null && message.hasOwnProperty("richPresenceState"))
            object.richPresenceState = $root.RichPresenceState.toObject(message.richPresenceState, options);
        if (message.defaultCountry != null && message.hasOwnProperty("defaultCountry"))
            object.defaultCountry = $root.Country.toObject(message.defaultCountry, options);
        return object;
    };

    /**
     * Converts this GetSelfInfoResponse to JSON.
     * @function toJSON
     * @memberof GetSelfInfoResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    GetSelfInfoResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return GetSelfInfoResponse;
})();

export const QueryPresenceRequest = $root.QueryPresenceRequest = (() => {

    /**
     * Properties of a QueryPresenceRequest.
     * @exports IQueryPresenceRequest
     * @interface IQueryPresenceRequest
     * @property {IRequestHeader|null} [requestHeader] QueryPresenceRequest requestHeader
     * @property {Array.<IParticipantId>|null} [participantId] QueryPresenceRequest participantId
     * @property {Array.<FieldMask>|null} [fieldMask] QueryPresenceRequest fieldMask
     */

    /**
     * Constructs a new QueryPresenceRequest.
     * @exports QueryPresenceRequest
     * @classdesc Represents a QueryPresenceRequest.
     * @implements IQueryPresenceRequest
     * @constructor
     * @param {IQueryPresenceRequest=} [properties] Properties to set
     */
    function QueryPresenceRequest(properties) {
        this.participantId = [];
        this.fieldMask = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * QueryPresenceRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof QueryPresenceRequest
     * @instance
     */
    QueryPresenceRequest.prototype.requestHeader = null;

    /**
     * QueryPresenceRequest participantId.
     * @member {Array.<IParticipantId>} participantId
     * @memberof QueryPresenceRequest
     * @instance
     */
    QueryPresenceRequest.prototype.participantId = $util.emptyArray;

    /**
     * QueryPresenceRequest fieldMask.
     * @member {Array.<FieldMask>} fieldMask
     * @memberof QueryPresenceRequest
     * @instance
     */
    QueryPresenceRequest.prototype.fieldMask = $util.emptyArray;

    /**
     * Creates a new QueryPresenceRequest instance using the specified properties.
     * @function create
     * @memberof QueryPresenceRequest
     * @static
     * @param {IQueryPresenceRequest=} [properties] Properties to set
     * @returns {QueryPresenceRequest} QueryPresenceRequest instance
     */
    QueryPresenceRequest.create = function create(properties) {
        return new QueryPresenceRequest(properties);
    };

    /**
     * Encodes the specified QueryPresenceRequest message. Does not implicitly {@link QueryPresenceRequest.verify|verify} messages.
     * @function encode
     * @memberof QueryPresenceRequest
     * @static
     * @param {IQueryPresenceRequest} message QueryPresenceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryPresenceRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.participantId != null && message.participantId.length)
            for (let i = 0; i < message.participantId.length; ++i)
                $root.ParticipantId.encode(message.participantId[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.fieldMask != null && message.fieldMask.length)
            for (let i = 0; i < message.fieldMask.length; ++i)
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fieldMask[i]);
        return writer;
    };

    /**
     * Encodes the specified QueryPresenceRequest message, length delimited. Does not implicitly {@link QueryPresenceRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof QueryPresenceRequest
     * @static
     * @param {IQueryPresenceRequest} message QueryPresenceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryPresenceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QueryPresenceRequest message from the specified reader or buffer.
     * @function decode
     * @memberof QueryPresenceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {QueryPresenceRequest} QueryPresenceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryPresenceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryPresenceRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.participantId && message.participantId.length))
                    message.participantId = [];
                message.participantId.push($root.ParticipantId.decode(reader, reader.uint32()));
                break;
            case 3:
                if (!(message.fieldMask && message.fieldMask.length))
                    message.fieldMask = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.fieldMask.push(reader.int32());
                } else
                    message.fieldMask.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a QueryPresenceRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof QueryPresenceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {QueryPresenceRequest} QueryPresenceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryPresenceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QueryPresenceRequest message.
     * @function verify
     * @memberof QueryPresenceRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QueryPresenceRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.participantId != null && message.hasOwnProperty("participantId")) {
            if (!Array.isArray(message.participantId))
                return "participantId: array expected";
            for (let i = 0; i < message.participantId.length; ++i) {
                let error = $root.ParticipantId.verify(message.participantId[i]);
                if (error)
                    return "participantId." + error;
            }
        }
        if (message.fieldMask != null && message.hasOwnProperty("fieldMask")) {
            if (!Array.isArray(message.fieldMask))
                return "fieldMask: array expected";
            for (let i = 0; i < message.fieldMask.length; ++i)
                switch (message.fieldMask[i]) {
                default:
                    return "fieldMask: enum value[] expected";
                case 1:
                case 2:
                case 3:
                case 6:
                case 7:
                case 10:
                    break;
                }
        }
        return null;
    };

    /**
     * Creates a QueryPresenceRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof QueryPresenceRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {QueryPresenceRequest} QueryPresenceRequest
     */
    QueryPresenceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.QueryPresenceRequest)
            return object;
        let message = new $root.QueryPresenceRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".QueryPresenceRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.participantId) {
            if (!Array.isArray(object.participantId))
                throw TypeError(".QueryPresenceRequest.participantId: array expected");
            message.participantId = [];
            for (let i = 0; i < object.participantId.length; ++i) {
                if (typeof object.participantId[i] !== "object")
                    throw TypeError(".QueryPresenceRequest.participantId: object expected");
                message.participantId[i] = $root.ParticipantId.fromObject(object.participantId[i]);
            }
        }
        if (object.fieldMask) {
            if (!Array.isArray(object.fieldMask))
                throw TypeError(".QueryPresenceRequest.fieldMask: array expected");
            message.fieldMask = [];
            for (let i = 0; i < object.fieldMask.length; ++i)
                switch (object.fieldMask[i]) {
                default:
                case "FIELD_MASK_REACHABLE":
                case 1:
                    message.fieldMask[i] = 1;
                    break;
                case "FIELD_MASK_AVAILABLE":
                case 2:
                    message.fieldMask[i] = 2;
                    break;
                case "FIELD_MASK_MOOD":
                case 3:
                    message.fieldMask[i] = 3;
                    break;
                case "FIELD_MASK_IN_CALL":
                case 6:
                    message.fieldMask[i] = 6;
                    break;
                case "FIELD_MASK_DEVICE":
                case 7:
                    message.fieldMask[i] = 7;
                    break;
                case "FIELD_MASK_LAST_SEEN":
                case 10:
                    message.fieldMask[i] = 10;
                    break;
                }
        }
        return message;
    };

    /**
     * Creates a plain object from a QueryPresenceRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof QueryPresenceRequest
     * @static
     * @param {QueryPresenceRequest} message QueryPresenceRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QueryPresenceRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.participantId = [];
            object.fieldMask = [];
        }
        if (options.defaults)
            object.requestHeader = null;
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.participantId && message.participantId.length) {
            object.participantId = [];
            for (let j = 0; j < message.participantId.length; ++j)
                object.participantId[j] = $root.ParticipantId.toObject(message.participantId[j], options);
        }
        if (message.fieldMask && message.fieldMask.length) {
            object.fieldMask = [];
            for (let j = 0; j < message.fieldMask.length; ++j)
                object.fieldMask[j] = options.enums === String ? $root.FieldMask[message.fieldMask[j]] : message.fieldMask[j];
        }
        return object;
    };

    /**
     * Converts this QueryPresenceRequest to JSON.
     * @function toJSON
     * @memberof QueryPresenceRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QueryPresenceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return QueryPresenceRequest;
})();

export const QueryPresenceResponse = $root.QueryPresenceResponse = (() => {

    /**
     * Properties of a QueryPresenceResponse.
     * @exports IQueryPresenceResponse
     * @interface IQueryPresenceResponse
     * @property {IResponseHeader|null} [responseHeader] QueryPresenceResponse responseHeader
     * @property {Array.<IPresenceResult>|null} [presenceResult] QueryPresenceResponse presenceResult
     */

    /**
     * Constructs a new QueryPresenceResponse.
     * @exports QueryPresenceResponse
     * @classdesc Represents a QueryPresenceResponse.
     * @implements IQueryPresenceResponse
     * @constructor
     * @param {IQueryPresenceResponse=} [properties] Properties to set
     */
    function QueryPresenceResponse(properties) {
        this.presenceResult = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * QueryPresenceResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof QueryPresenceResponse
     * @instance
     */
    QueryPresenceResponse.prototype.responseHeader = null;

    /**
     * QueryPresenceResponse presenceResult.
     * @member {Array.<IPresenceResult>} presenceResult
     * @memberof QueryPresenceResponse
     * @instance
     */
    QueryPresenceResponse.prototype.presenceResult = $util.emptyArray;

    /**
     * Creates a new QueryPresenceResponse instance using the specified properties.
     * @function create
     * @memberof QueryPresenceResponse
     * @static
     * @param {IQueryPresenceResponse=} [properties] Properties to set
     * @returns {QueryPresenceResponse} QueryPresenceResponse instance
     */
    QueryPresenceResponse.create = function create(properties) {
        return new QueryPresenceResponse(properties);
    };

    /**
     * Encodes the specified QueryPresenceResponse message. Does not implicitly {@link QueryPresenceResponse.verify|verify} messages.
     * @function encode
     * @memberof QueryPresenceResponse
     * @static
     * @param {IQueryPresenceResponse} message QueryPresenceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryPresenceResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.presenceResult != null && message.presenceResult.length)
            for (let i = 0; i < message.presenceResult.length; ++i)
                $root.PresenceResult.encode(message.presenceResult[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified QueryPresenceResponse message, length delimited. Does not implicitly {@link QueryPresenceResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof QueryPresenceResponse
     * @static
     * @param {IQueryPresenceResponse} message QueryPresenceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryPresenceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QueryPresenceResponse message from the specified reader or buffer.
     * @function decode
     * @memberof QueryPresenceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {QueryPresenceResponse} QueryPresenceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryPresenceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryPresenceResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.presenceResult && message.presenceResult.length))
                    message.presenceResult = [];
                message.presenceResult.push($root.PresenceResult.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a QueryPresenceResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof QueryPresenceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {QueryPresenceResponse} QueryPresenceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryPresenceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QueryPresenceResponse message.
     * @function verify
     * @memberof QueryPresenceResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QueryPresenceResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.presenceResult != null && message.hasOwnProperty("presenceResult")) {
            if (!Array.isArray(message.presenceResult))
                return "presenceResult: array expected";
            for (let i = 0; i < message.presenceResult.length; ++i) {
                let error = $root.PresenceResult.verify(message.presenceResult[i]);
                if (error)
                    return "presenceResult." + error;
            }
        }
        return null;
    };

    /**
     * Creates a QueryPresenceResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof QueryPresenceResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {QueryPresenceResponse} QueryPresenceResponse
     */
    QueryPresenceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.QueryPresenceResponse)
            return object;
        let message = new $root.QueryPresenceResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".QueryPresenceResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.presenceResult) {
            if (!Array.isArray(object.presenceResult))
                throw TypeError(".QueryPresenceResponse.presenceResult: array expected");
            message.presenceResult = [];
            for (let i = 0; i < object.presenceResult.length; ++i) {
                if (typeof object.presenceResult[i] !== "object")
                    throw TypeError(".QueryPresenceResponse.presenceResult: object expected");
                message.presenceResult[i] = $root.PresenceResult.fromObject(object.presenceResult[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a QueryPresenceResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof QueryPresenceResponse
     * @static
     * @param {QueryPresenceResponse} message QueryPresenceResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QueryPresenceResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.presenceResult = [];
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.presenceResult && message.presenceResult.length) {
            object.presenceResult = [];
            for (let j = 0; j < message.presenceResult.length; ++j)
                object.presenceResult[j] = $root.PresenceResult.toObject(message.presenceResult[j], options);
        }
        return object;
    };

    /**
     * Converts this QueryPresenceResponse to JSON.
     * @function toJSON
     * @memberof QueryPresenceResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QueryPresenceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return QueryPresenceResponse;
})();

export const RemoveUserRequest = $root.RemoveUserRequest = (() => {

    /**
     * Properties of a RemoveUserRequest.
     * @exports IRemoveUserRequest
     * @interface IRemoveUserRequest
     * @property {IRequestHeader|null} [requestHeader] RemoveUserRequest requestHeader
     * @property {IParticipantId|null} [participantId] RemoveUserRequest participantId
     * @property {IEventRequestHeader|null} [eventRequestHeader] RemoveUserRequest eventRequestHeader
     */

    /**
     * Constructs a new RemoveUserRequest.
     * @exports RemoveUserRequest
     * @classdesc Represents a RemoveUserRequest.
     * @implements IRemoveUserRequest
     * @constructor
     * @param {IRemoveUserRequest=} [properties] Properties to set
     */
    function RemoveUserRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RemoveUserRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof RemoveUserRequest
     * @instance
     */
    RemoveUserRequest.prototype.requestHeader = null;

    /**
     * RemoveUserRequest participantId.
     * @member {IParticipantId|null|undefined} participantId
     * @memberof RemoveUserRequest
     * @instance
     */
    RemoveUserRequest.prototype.participantId = null;

    /**
     * RemoveUserRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof RemoveUserRequest
     * @instance
     */
    RemoveUserRequest.prototype.eventRequestHeader = null;

    /**
     * Creates a new RemoveUserRequest instance using the specified properties.
     * @function create
     * @memberof RemoveUserRequest
     * @static
     * @param {IRemoveUserRequest=} [properties] Properties to set
     * @returns {RemoveUserRequest} RemoveUserRequest instance
     */
    RemoveUserRequest.create = function create(properties) {
        return new RemoveUserRequest(properties);
    };

    /**
     * Encodes the specified RemoveUserRequest message. Does not implicitly {@link RemoveUserRequest.verify|verify} messages.
     * @function encode
     * @memberof RemoveUserRequest
     * @static
     * @param {IRemoveUserRequest} message RemoveUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RemoveUserRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            $root.ParticipantId.encode(message.participantId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RemoveUserRequest message, length delimited. Does not implicitly {@link RemoveUserRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RemoveUserRequest
     * @static
     * @param {IRemoveUserRequest} message RemoveUserRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RemoveUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RemoveUserRequest message from the specified reader or buffer.
     * @function decode
     * @memberof RemoveUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RemoveUserRequest} RemoveUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RemoveUserRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoveUserRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                message.participantId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 5:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RemoveUserRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RemoveUserRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RemoveUserRequest} RemoveUserRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RemoveUserRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RemoveUserRequest message.
     * @function verify
     * @memberof RemoveUserRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RemoveUserRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.participantId != null && message.hasOwnProperty("participantId")) {
            let error = $root.ParticipantId.verify(message.participantId);
            if (error)
                return "participantId." + error;
        }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        return null;
    };

    /**
     * Creates a RemoveUserRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RemoveUserRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RemoveUserRequest} RemoveUserRequest
     */
    RemoveUserRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.RemoveUserRequest)
            return object;
        let message = new $root.RemoveUserRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".RemoveUserRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.participantId != null) {
            if (typeof object.participantId !== "object")
                throw TypeError(".RemoveUserRequest.participantId: object expected");
            message.participantId = $root.ParticipantId.fromObject(object.participantId);
        }
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".RemoveUserRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a RemoveUserRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RemoveUserRequest
     * @static
     * @param {RemoveUserRequest} message RemoveUserRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RemoveUserRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.participantId = null;
            object.eventRequestHeader = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.participantId != null && message.hasOwnProperty("participantId"))
            object.participantId = $root.ParticipantId.toObject(message.participantId, options);
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        return object;
    };

    /**
     * Converts this RemoveUserRequest to JSON.
     * @function toJSON
     * @memberof RemoveUserRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RemoveUserRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RemoveUserRequest;
})();

export const RemoveUserResponse = $root.RemoveUserResponse = (() => {

    /**
     * Properties of a RemoveUserResponse.
     * @exports IRemoveUserResponse
     * @interface IRemoveUserResponse
     * @property {IResponseHeader|null} [responseHeader] RemoveUserResponse responseHeader
     * @property {IEvent|null} [createdEvent] RemoveUserResponse createdEvent
     */

    /**
     * Constructs a new RemoveUserResponse.
     * @exports RemoveUserResponse
     * @classdesc Represents a RemoveUserResponse.
     * @implements IRemoveUserResponse
     * @constructor
     * @param {IRemoveUserResponse=} [properties] Properties to set
     */
    function RemoveUserResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RemoveUserResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof RemoveUserResponse
     * @instance
     */
    RemoveUserResponse.prototype.responseHeader = null;

    /**
     * RemoveUserResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof RemoveUserResponse
     * @instance
     */
    RemoveUserResponse.prototype.createdEvent = null;

    /**
     * Creates a new RemoveUserResponse instance using the specified properties.
     * @function create
     * @memberof RemoveUserResponse
     * @static
     * @param {IRemoveUserResponse=} [properties] Properties to set
     * @returns {RemoveUserResponse} RemoveUserResponse instance
     */
    RemoveUserResponse.create = function create(properties) {
        return new RemoveUserResponse(properties);
    };

    /**
     * Encodes the specified RemoveUserResponse message. Does not implicitly {@link RemoveUserResponse.verify|verify} messages.
     * @function encode
     * @memberof RemoveUserResponse
     * @static
     * @param {IRemoveUserResponse} message RemoveUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RemoveUserResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RemoveUserResponse message, length delimited. Does not implicitly {@link RemoveUserResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RemoveUserResponse
     * @static
     * @param {IRemoveUserResponse} message RemoveUserResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RemoveUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RemoveUserResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RemoveUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RemoveUserResponse} RemoveUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RemoveUserResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoveUserResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 4:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RemoveUserResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RemoveUserResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RemoveUserResponse} RemoveUserResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RemoveUserResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RemoveUserResponse message.
     * @function verify
     * @memberof RemoveUserResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RemoveUserResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        return null;
    };

    /**
     * Creates a RemoveUserResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RemoveUserResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RemoveUserResponse} RemoveUserResponse
     */
    RemoveUserResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RemoveUserResponse)
            return object;
        let message = new $root.RemoveUserResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".RemoveUserResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".RemoveUserResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        return message;
    };

    /**
     * Creates a plain object from a RemoveUserResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RemoveUserResponse
     * @static
     * @param {RemoveUserResponse} message RemoveUserResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RemoveUserResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        return object;
    };

    /**
     * Converts this RemoveUserResponse to JSON.
     * @function toJSON
     * @memberof RemoveUserResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RemoveUserResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RemoveUserResponse;
})();

export const RenameConversationRequest = $root.RenameConversationRequest = (() => {

    /**
     * Properties of a RenameConversationRequest.
     * @exports IRenameConversationRequest
     * @interface IRenameConversationRequest
     * @property {IRequestHeader|null} [requestHeader] RenameConversationRequest requestHeader
     * @property {string|null} [newName] RenameConversationRequest newName
     * @property {IEventRequestHeader|null} [eventRequestHeader] RenameConversationRequest eventRequestHeader
     */

    /**
     * Constructs a new RenameConversationRequest.
     * @exports RenameConversationRequest
     * @classdesc Represents a RenameConversationRequest.
     * @implements IRenameConversationRequest
     * @constructor
     * @param {IRenameConversationRequest=} [properties] Properties to set
     */
    function RenameConversationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RenameConversationRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof RenameConversationRequest
     * @instance
     */
    RenameConversationRequest.prototype.requestHeader = null;

    /**
     * RenameConversationRequest newName.
     * @member {string} newName
     * @memberof RenameConversationRequest
     * @instance
     */
    RenameConversationRequest.prototype.newName = "";

    /**
     * RenameConversationRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof RenameConversationRequest
     * @instance
     */
    RenameConversationRequest.prototype.eventRequestHeader = null;

    /**
     * Creates a new RenameConversationRequest instance using the specified properties.
     * @function create
     * @memberof RenameConversationRequest
     * @static
     * @param {IRenameConversationRequest=} [properties] Properties to set
     * @returns {RenameConversationRequest} RenameConversationRequest instance
     */
    RenameConversationRequest.create = function create(properties) {
        return new RenameConversationRequest(properties);
    };

    /**
     * Encodes the specified RenameConversationRequest message. Does not implicitly {@link RenameConversationRequest.verify|verify} messages.
     * @function encode
     * @memberof RenameConversationRequest
     * @static
     * @param {IRenameConversationRequest} message RenameConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RenameConversationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.newName != null && message.hasOwnProperty("newName"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.newName);
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RenameConversationRequest message, length delimited. Does not implicitly {@link RenameConversationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RenameConversationRequest
     * @static
     * @param {IRenameConversationRequest} message RenameConversationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RenameConversationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RenameConversationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof RenameConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RenameConversationRequest} RenameConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RenameConversationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RenameConversationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                message.newName = reader.string();
                break;
            case 5:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RenameConversationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RenameConversationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RenameConversationRequest} RenameConversationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RenameConversationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RenameConversationRequest message.
     * @function verify
     * @memberof RenameConversationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RenameConversationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.newName != null && message.hasOwnProperty("newName"))
            if (!$util.isString(message.newName))
                return "newName: string expected";
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        return null;
    };

    /**
     * Creates a RenameConversationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RenameConversationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RenameConversationRequest} RenameConversationRequest
     */
    RenameConversationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.RenameConversationRequest)
            return object;
        let message = new $root.RenameConversationRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".RenameConversationRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.newName != null)
            message.newName = String(object.newName);
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".RenameConversationRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a RenameConversationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RenameConversationRequest
     * @static
     * @param {RenameConversationRequest} message RenameConversationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RenameConversationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.newName = "";
            object.eventRequestHeader = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.newName != null && message.hasOwnProperty("newName"))
            object.newName = message.newName;
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        return object;
    };

    /**
     * Converts this RenameConversationRequest to JSON.
     * @function toJSON
     * @memberof RenameConversationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RenameConversationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RenameConversationRequest;
})();

export const RenameConversationResponse = $root.RenameConversationResponse = (() => {

    /**
     * Properties of a RenameConversationResponse.
     * @exports IRenameConversationResponse
     * @interface IRenameConversationResponse
     * @property {IResponseHeader|null} [responseHeader] RenameConversationResponse responseHeader
     * @property {IEvent|null} [createdEvent] RenameConversationResponse createdEvent
     */

    /**
     * Constructs a new RenameConversationResponse.
     * @exports RenameConversationResponse
     * @classdesc Represents a RenameConversationResponse.
     * @implements IRenameConversationResponse
     * @constructor
     * @param {IRenameConversationResponse=} [properties] Properties to set
     */
    function RenameConversationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RenameConversationResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof RenameConversationResponse
     * @instance
     */
    RenameConversationResponse.prototype.responseHeader = null;

    /**
     * RenameConversationResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof RenameConversationResponse
     * @instance
     */
    RenameConversationResponse.prototype.createdEvent = null;

    /**
     * Creates a new RenameConversationResponse instance using the specified properties.
     * @function create
     * @memberof RenameConversationResponse
     * @static
     * @param {IRenameConversationResponse=} [properties] Properties to set
     * @returns {RenameConversationResponse} RenameConversationResponse instance
     */
    RenameConversationResponse.create = function create(properties) {
        return new RenameConversationResponse(properties);
    };

    /**
     * Encodes the specified RenameConversationResponse message. Does not implicitly {@link RenameConversationResponse.verify|verify} messages.
     * @function encode
     * @memberof RenameConversationResponse
     * @static
     * @param {IRenameConversationResponse} message RenameConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RenameConversationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RenameConversationResponse message, length delimited. Does not implicitly {@link RenameConversationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RenameConversationResponse
     * @static
     * @param {IRenameConversationResponse} message RenameConversationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RenameConversationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RenameConversationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RenameConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RenameConversationResponse} RenameConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RenameConversationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RenameConversationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 4:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RenameConversationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RenameConversationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RenameConversationResponse} RenameConversationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RenameConversationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RenameConversationResponse message.
     * @function verify
     * @memberof RenameConversationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RenameConversationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        return null;
    };

    /**
     * Creates a RenameConversationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RenameConversationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RenameConversationResponse} RenameConversationResponse
     */
    RenameConversationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RenameConversationResponse)
            return object;
        let message = new $root.RenameConversationResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".RenameConversationResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".RenameConversationResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        return message;
    };

    /**
     * Creates a plain object from a RenameConversationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RenameConversationResponse
     * @static
     * @param {RenameConversationResponse} message RenameConversationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RenameConversationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        return object;
    };

    /**
     * Converts this RenameConversationResponse to JSON.
     * @function toJSON
     * @memberof RenameConversationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RenameConversationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return RenameConversationResponse;
})();

export const SearchEntitiesRequest = $root.SearchEntitiesRequest = (() => {

    /**
     * Properties of a SearchEntitiesRequest.
     * @exports ISearchEntitiesRequest
     * @interface ISearchEntitiesRequest
     * @property {IRequestHeader|null} [requestHeader] SearchEntitiesRequest requestHeader
     * @property {string|null} [query] SearchEntitiesRequest query
     * @property {number|Long|null} [maxCount] SearchEntitiesRequest maxCount
     */

    /**
     * Constructs a new SearchEntitiesRequest.
     * @exports SearchEntitiesRequest
     * @classdesc Represents a SearchEntitiesRequest.
     * @implements ISearchEntitiesRequest
     * @constructor
     * @param {ISearchEntitiesRequest=} [properties] Properties to set
     */
    function SearchEntitiesRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchEntitiesRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SearchEntitiesRequest
     * @instance
     */
    SearchEntitiesRequest.prototype.requestHeader = null;

    /**
     * SearchEntitiesRequest query.
     * @member {string} query
     * @memberof SearchEntitiesRequest
     * @instance
     */
    SearchEntitiesRequest.prototype.query = "";

    /**
     * SearchEntitiesRequest maxCount.
     * @member {number|Long} maxCount
     * @memberof SearchEntitiesRequest
     * @instance
     */
    SearchEntitiesRequest.prototype.maxCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SearchEntitiesRequest instance using the specified properties.
     * @function create
     * @memberof SearchEntitiesRequest
     * @static
     * @param {ISearchEntitiesRequest=} [properties] Properties to set
     * @returns {SearchEntitiesRequest} SearchEntitiesRequest instance
     */
    SearchEntitiesRequest.create = function create(properties) {
        return new SearchEntitiesRequest(properties);
    };

    /**
     * Encodes the specified SearchEntitiesRequest message. Does not implicitly {@link SearchEntitiesRequest.verify|verify} messages.
     * @function encode
     * @memberof SearchEntitiesRequest
     * @static
     * @param {ISearchEntitiesRequest} message SearchEntitiesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchEntitiesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.query != null && message.hasOwnProperty("query"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.query);
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxCount);
        return writer;
    };

    /**
     * Encodes the specified SearchEntitiesRequest message, length delimited. Does not implicitly {@link SearchEntitiesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchEntitiesRequest
     * @static
     * @param {ISearchEntitiesRequest} message SearchEntitiesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchEntitiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchEntitiesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SearchEntitiesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchEntitiesRequest} SearchEntitiesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchEntitiesRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchEntitiesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                message.query = reader.string();
                break;
            case 4:
                message.maxCount = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchEntitiesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchEntitiesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchEntitiesRequest} SearchEntitiesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchEntitiesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchEntitiesRequest message.
     * @function verify
     * @memberof SearchEntitiesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchEntitiesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.query != null && message.hasOwnProperty("query"))
            if (!$util.isString(message.query))
                return "query: string expected";
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            if (!$util.isInteger(message.maxCount) && !(message.maxCount && $util.isInteger(message.maxCount.low) && $util.isInteger(message.maxCount.high)))
                return "maxCount: integer|Long expected";
        return null;
    };

    /**
     * Creates a SearchEntitiesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchEntitiesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchEntitiesRequest} SearchEntitiesRequest
     */
    SearchEntitiesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchEntitiesRequest)
            return object;
        let message = new $root.SearchEntitiesRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SearchEntitiesRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.query != null)
            message.query = String(object.query);
        if (object.maxCount != null)
            if ($util.Long)
                (message.maxCount = $util.Long.fromValue(object.maxCount)).unsigned = true;
            else if (typeof object.maxCount === "string")
                message.maxCount = parseInt(object.maxCount, 10);
            else if (typeof object.maxCount === "number")
                message.maxCount = object.maxCount;
            else if (typeof object.maxCount === "object")
                message.maxCount = new $util.LongBits(object.maxCount.low >>> 0, object.maxCount.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SearchEntitiesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchEntitiesRequest
     * @static
     * @param {SearchEntitiesRequest} message SearchEntitiesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchEntitiesRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.query = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxCount = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.query != null && message.hasOwnProperty("query"))
            object.query = message.query;
        if (message.maxCount != null && message.hasOwnProperty("maxCount"))
            if (typeof message.maxCount === "number")
                object.maxCount = options.longs === String ? String(message.maxCount) : message.maxCount;
            else
                object.maxCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxCount) : options.longs === Number ? new $util.LongBits(message.maxCount.low >>> 0, message.maxCount.high >>> 0).toNumber(true) : message.maxCount;
        return object;
    };

    /**
     * Converts this SearchEntitiesRequest to JSON.
     * @function toJSON
     * @memberof SearchEntitiesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchEntitiesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SearchEntitiesRequest;
})();

export const SearchEntitiesResponse = $root.SearchEntitiesResponse = (() => {

    /**
     * Properties of a SearchEntitiesResponse.
     * @exports ISearchEntitiesResponse
     * @interface ISearchEntitiesResponse
     * @property {IResponseHeader|null} [responseHeader] SearchEntitiesResponse responseHeader
     * @property {Array.<IEntity>|null} [entity] SearchEntitiesResponse entity
     */

    /**
     * Constructs a new SearchEntitiesResponse.
     * @exports SearchEntitiesResponse
     * @classdesc Represents a SearchEntitiesResponse.
     * @implements ISearchEntitiesResponse
     * @constructor
     * @param {ISearchEntitiesResponse=} [properties] Properties to set
     */
    function SearchEntitiesResponse(properties) {
        this.entity = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SearchEntitiesResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SearchEntitiesResponse
     * @instance
     */
    SearchEntitiesResponse.prototype.responseHeader = null;

    /**
     * SearchEntitiesResponse entity.
     * @member {Array.<IEntity>} entity
     * @memberof SearchEntitiesResponse
     * @instance
     */
    SearchEntitiesResponse.prototype.entity = $util.emptyArray;

    /**
     * Creates a new SearchEntitiesResponse instance using the specified properties.
     * @function create
     * @memberof SearchEntitiesResponse
     * @static
     * @param {ISearchEntitiesResponse=} [properties] Properties to set
     * @returns {SearchEntitiesResponse} SearchEntitiesResponse instance
     */
    SearchEntitiesResponse.create = function create(properties) {
        return new SearchEntitiesResponse(properties);
    };

    /**
     * Encodes the specified SearchEntitiesResponse message. Does not implicitly {@link SearchEntitiesResponse.verify|verify} messages.
     * @function encode
     * @memberof SearchEntitiesResponse
     * @static
     * @param {ISearchEntitiesResponse} message SearchEntitiesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchEntitiesResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.entity != null && message.entity.length)
            for (let i = 0; i < message.entity.length; ++i)
                $root.Entity.encode(message.entity[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SearchEntitiesResponse message, length delimited. Does not implicitly {@link SearchEntitiesResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SearchEntitiesResponse
     * @static
     * @param {ISearchEntitiesResponse} message SearchEntitiesResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SearchEntitiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SearchEntitiesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SearchEntitiesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SearchEntitiesResponse} SearchEntitiesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchEntitiesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SearchEntitiesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                if (!(message.entity && message.entity.length))
                    message.entity = [];
                message.entity.push($root.Entity.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SearchEntitiesResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SearchEntitiesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SearchEntitiesResponse} SearchEntitiesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SearchEntitiesResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SearchEntitiesResponse message.
     * @function verify
     * @memberof SearchEntitiesResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SearchEntitiesResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.entity != null && message.hasOwnProperty("entity")) {
            if (!Array.isArray(message.entity))
                return "entity: array expected";
            for (let i = 0; i < message.entity.length; ++i) {
                let error = $root.Entity.verify(message.entity[i]);
                if (error)
                    return "entity." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SearchEntitiesResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SearchEntitiesResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SearchEntitiesResponse} SearchEntitiesResponse
     */
    SearchEntitiesResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SearchEntitiesResponse)
            return object;
        let message = new $root.SearchEntitiesResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SearchEntitiesResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.entity) {
            if (!Array.isArray(object.entity))
                throw TypeError(".SearchEntitiesResponse.entity: array expected");
            message.entity = [];
            for (let i = 0; i < object.entity.length; ++i) {
                if (typeof object.entity[i] !== "object")
                    throw TypeError(".SearchEntitiesResponse.entity: object expected");
                message.entity[i] = $root.Entity.fromObject(object.entity[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SearchEntitiesResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SearchEntitiesResponse
     * @static
     * @param {SearchEntitiesResponse} message SearchEntitiesResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SearchEntitiesResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.entity = [];
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.entity && message.entity.length) {
            object.entity = [];
            for (let j = 0; j < message.entity.length; ++j)
                object.entity[j] = $root.Entity.toObject(message.entity[j], options);
        }
        return object;
    };

    /**
     * Converts this SearchEntitiesResponse to JSON.
     * @function toJSON
     * @memberof SearchEntitiesResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SearchEntitiesResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SearchEntitiesResponse;
})();

export const Location = $root.Location = (() => {

    /**
     * Properties of a Location.
     * @exports ILocation
     * @interface ILocation
     * @property {IPlace|null} [place] Location place
     */

    /**
     * Constructs a new Location.
     * @exports Location
     * @classdesc Represents a Location.
     * @implements ILocation
     * @constructor
     * @param {ILocation=} [properties] Properties to set
     */
    function Location(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Location place.
     * @member {IPlace|null|undefined} place
     * @memberof Location
     * @instance
     */
    Location.prototype.place = null;

    /**
     * Creates a new Location instance using the specified properties.
     * @function create
     * @memberof Location
     * @static
     * @param {ILocation=} [properties] Properties to set
     * @returns {Location} Location instance
     */
    Location.create = function create(properties) {
        return new Location(properties);
    };

    /**
     * Encodes the specified Location message. Does not implicitly {@link Location.verify|verify} messages.
     * @function encode
     * @memberof Location
     * @static
     * @param {ILocation} message Location message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Location.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.place != null && message.hasOwnProperty("place"))
            $root.Place.encode(message.place, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Location message, length delimited. Does not implicitly {@link Location.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Location
     * @static
     * @param {ILocation} message Location message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Location.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Location message from the specified reader or buffer.
     * @function decode
     * @memberof Location
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Location} Location
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Location.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Location();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.place = $root.Place.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Location message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Location
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Location} Location
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Location.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Location message.
     * @function verify
     * @memberof Location
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Location.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.place != null && message.hasOwnProperty("place")) {
            let error = $root.Place.verify(message.place);
            if (error)
                return "place." + error;
        }
        return null;
    };

    /**
     * Creates a Location message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Location
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Location} Location
     */
    Location.fromObject = function fromObject(object) {
        if (object instanceof $root.Location)
            return object;
        let message = new $root.Location();
        if (object.place != null) {
            if (typeof object.place !== "object")
                throw TypeError(".Location.place: object expected");
            message.place = $root.Place.fromObject(object.place);
        }
        return message;
    };

    /**
     * Creates a plain object from a Location message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Location
     * @static
     * @param {Location} message Location
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Location.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.place = null;
        if (message.place != null && message.hasOwnProperty("place"))
            object.place = $root.Place.toObject(message.place, options);
        return object;
    };

    /**
     * Converts this Location to JSON.
     * @function toJSON
     * @memberof Location
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Location.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return Location;
})();

export const SendChatMessageRequest = $root.SendChatMessageRequest = (() => {

    /**
     * Properties of a SendChatMessageRequest.
     * @exports ISendChatMessageRequest
     * @interface ISendChatMessageRequest
     * @property {IRequestHeader|null} [requestHeader] SendChatMessageRequest requestHeader
     * @property {Array.<IEventAnnotation>|null} [annotation] SendChatMessageRequest annotation
     * @property {IMessageContent|null} [messageContent] SendChatMessageRequest messageContent
     * @property {IExistingMedia|null} [existingMedia] SendChatMessageRequest existingMedia
     * @property {IEventRequestHeader|null} [eventRequestHeader] SendChatMessageRequest eventRequestHeader
     * @property {IParticipantId|null} [userId] SendChatMessageRequest userId
     * @property {ILocation|null} [location] SendChatMessageRequest location
     */

    /**
     * Constructs a new SendChatMessageRequest.
     * @exports SendChatMessageRequest
     * @classdesc Represents a SendChatMessageRequest.
     * @implements ISendChatMessageRequest
     * @constructor
     * @param {ISendChatMessageRequest=} [properties] Properties to set
     */
    function SendChatMessageRequest(properties) {
        this.annotation = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SendChatMessageRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.requestHeader = null;

    /**
     * SendChatMessageRequest annotation.
     * @member {Array.<IEventAnnotation>} annotation
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.annotation = $util.emptyArray;

    /**
     * SendChatMessageRequest messageContent.
     * @member {IMessageContent|null|undefined} messageContent
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.messageContent = null;

    /**
     * SendChatMessageRequest existingMedia.
     * @member {IExistingMedia|null|undefined} existingMedia
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.existingMedia = null;

    /**
     * SendChatMessageRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.eventRequestHeader = null;

    /**
     * SendChatMessageRequest userId.
     * @member {IParticipantId|null|undefined} userId
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.userId = null;

    /**
     * SendChatMessageRequest location.
     * @member {ILocation|null|undefined} location
     * @memberof SendChatMessageRequest
     * @instance
     */
    SendChatMessageRequest.prototype.location = null;

    /**
     * Creates a new SendChatMessageRequest instance using the specified properties.
     * @function create
     * @memberof SendChatMessageRequest
     * @static
     * @param {ISendChatMessageRequest=} [properties] Properties to set
     * @returns {SendChatMessageRequest} SendChatMessageRequest instance
     */
    SendChatMessageRequest.create = function create(properties) {
        return new SendChatMessageRequest(properties);
    };

    /**
     * Encodes the specified SendChatMessageRequest message. Does not implicitly {@link SendChatMessageRequest.verify|verify} messages.
     * @function encode
     * @memberof SendChatMessageRequest
     * @static
     * @param {ISendChatMessageRequest} message SendChatMessageRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendChatMessageRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.annotation != null && message.annotation.length)
            for (let i = 0; i < message.annotation.length; ++i)
                $root.EventAnnotation.encode(message.annotation[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.messageContent != null && message.hasOwnProperty("messageContent"))
            $root.MessageContent.encode(message.messageContent, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.existingMedia != null && message.hasOwnProperty("existingMedia"))
            $root.ExistingMedia.encode(message.existingMedia, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.userId != null && message.hasOwnProperty("userId"))
            $root.ParticipantId.encode(message.userId, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
        if (message.location != null && message.hasOwnProperty("location"))
            $root.Location.encode(message.location, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SendChatMessageRequest message, length delimited. Does not implicitly {@link SendChatMessageRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SendChatMessageRequest
     * @static
     * @param {ISendChatMessageRequest} message SendChatMessageRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendChatMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SendChatMessageRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SendChatMessageRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SendChatMessageRequest} SendChatMessageRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendChatMessageRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SendChatMessageRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 5:
                if (!(message.annotation && message.annotation.length))
                    message.annotation = [];
                message.annotation.push($root.EventAnnotation.decode(reader, reader.uint32()));
                break;
            case 6:
                message.messageContent = $root.MessageContent.decode(reader, reader.uint32());
                break;
            case 7:
                message.existingMedia = $root.ExistingMedia.decode(reader, reader.uint32());
                break;
            case 8:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            case 9:
                message.userId = $root.ParticipantId.decode(reader, reader.uint32());
                break;
            case 10:
                message.location = $root.Location.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SendChatMessageRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SendChatMessageRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SendChatMessageRequest} SendChatMessageRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendChatMessageRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SendChatMessageRequest message.
     * @function verify
     * @memberof SendChatMessageRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SendChatMessageRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.annotation != null && message.hasOwnProperty("annotation")) {
            if (!Array.isArray(message.annotation))
                return "annotation: array expected";
            for (let i = 0; i < message.annotation.length; ++i) {
                let error = $root.EventAnnotation.verify(message.annotation[i]);
                if (error)
                    return "annotation." + error;
            }
        }
        if (message.messageContent != null && message.hasOwnProperty("messageContent")) {
            let error = $root.MessageContent.verify(message.messageContent);
            if (error)
                return "messageContent." + error;
        }
        if (message.existingMedia != null && message.hasOwnProperty("existingMedia")) {
            let error = $root.ExistingMedia.verify(message.existingMedia);
            if (error)
                return "existingMedia." + error;
        }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        if (message.userId != null && message.hasOwnProperty("userId")) {
            let error = $root.ParticipantId.verify(message.userId);
            if (error)
                return "userId." + error;
        }
        if (message.location != null && message.hasOwnProperty("location")) {
            let error = $root.Location.verify(message.location);
            if (error)
                return "location." + error;
        }
        return null;
    };

    /**
     * Creates a SendChatMessageRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SendChatMessageRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SendChatMessageRequest} SendChatMessageRequest
     */
    SendChatMessageRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SendChatMessageRequest)
            return object;
        let message = new $root.SendChatMessageRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SendChatMessageRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.annotation) {
            if (!Array.isArray(object.annotation))
                throw TypeError(".SendChatMessageRequest.annotation: array expected");
            message.annotation = [];
            for (let i = 0; i < object.annotation.length; ++i) {
                if (typeof object.annotation[i] !== "object")
                    throw TypeError(".SendChatMessageRequest.annotation: object expected");
                message.annotation[i] = $root.EventAnnotation.fromObject(object.annotation[i]);
            }
        }
        if (object.messageContent != null) {
            if (typeof object.messageContent !== "object")
                throw TypeError(".SendChatMessageRequest.messageContent: object expected");
            message.messageContent = $root.MessageContent.fromObject(object.messageContent);
        }
        if (object.existingMedia != null) {
            if (typeof object.existingMedia !== "object")
                throw TypeError(".SendChatMessageRequest.existingMedia: object expected");
            message.existingMedia = $root.ExistingMedia.fromObject(object.existingMedia);
        }
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".SendChatMessageRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        if (object.userId != null) {
            if (typeof object.userId !== "object")
                throw TypeError(".SendChatMessageRequest.userId: object expected");
            message.userId = $root.ParticipantId.fromObject(object.userId);
        }
        if (object.location != null) {
            if (typeof object.location !== "object")
                throw TypeError(".SendChatMessageRequest.location: object expected");
            message.location = $root.Location.fromObject(object.location);
        }
        return message;
    };

    /**
     * Creates a plain object from a SendChatMessageRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SendChatMessageRequest
     * @static
     * @param {SendChatMessageRequest} message SendChatMessageRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SendChatMessageRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.annotation = [];
        if (options.defaults) {
            object.requestHeader = null;
            object.messageContent = null;
            object.existingMedia = null;
            object.eventRequestHeader = null;
            object.userId = null;
            object.location = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.annotation && message.annotation.length) {
            object.annotation = [];
            for (let j = 0; j < message.annotation.length; ++j)
                object.annotation[j] = $root.EventAnnotation.toObject(message.annotation[j], options);
        }
        if (message.messageContent != null && message.hasOwnProperty("messageContent"))
            object.messageContent = $root.MessageContent.toObject(message.messageContent, options);
        if (message.existingMedia != null && message.hasOwnProperty("existingMedia"))
            object.existingMedia = $root.ExistingMedia.toObject(message.existingMedia, options);
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        if (message.userId != null && message.hasOwnProperty("userId"))
            object.userId = $root.ParticipantId.toObject(message.userId, options);
        if (message.location != null && message.hasOwnProperty("location"))
            object.location = $root.Location.toObject(message.location, options);
        return object;
    };

    /**
     * Converts this SendChatMessageRequest to JSON.
     * @function toJSON
     * @memberof SendChatMessageRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SendChatMessageRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SendChatMessageRequest;
})();

export const SendChatMessageResponse = $root.SendChatMessageResponse = (() => {

    /**
     * Properties of a SendChatMessageResponse.
     * @exports ISendChatMessageResponse
     * @interface ISendChatMessageResponse
     * @property {IResponseHeader|null} [responseHeader] SendChatMessageResponse responseHeader
     * @property {IEvent|null} [createdEvent] SendChatMessageResponse createdEvent
     */

    /**
     * Constructs a new SendChatMessageResponse.
     * @exports SendChatMessageResponse
     * @classdesc Represents a SendChatMessageResponse.
     * @implements ISendChatMessageResponse
     * @constructor
     * @param {ISendChatMessageResponse=} [properties] Properties to set
     */
    function SendChatMessageResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SendChatMessageResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SendChatMessageResponse
     * @instance
     */
    SendChatMessageResponse.prototype.responseHeader = null;

    /**
     * SendChatMessageResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof SendChatMessageResponse
     * @instance
     */
    SendChatMessageResponse.prototype.createdEvent = null;

    /**
     * Creates a new SendChatMessageResponse instance using the specified properties.
     * @function create
     * @memberof SendChatMessageResponse
     * @static
     * @param {ISendChatMessageResponse=} [properties] Properties to set
     * @returns {SendChatMessageResponse} SendChatMessageResponse instance
     */
    SendChatMessageResponse.create = function create(properties) {
        return new SendChatMessageResponse(properties);
    };

    /**
     * Encodes the specified SendChatMessageResponse message. Does not implicitly {@link SendChatMessageResponse.verify|verify} messages.
     * @function encode
     * @memberof SendChatMessageResponse
     * @static
     * @param {ISendChatMessageResponse} message SendChatMessageResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendChatMessageResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SendChatMessageResponse message, length delimited. Does not implicitly {@link SendChatMessageResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SendChatMessageResponse
     * @static
     * @param {ISendChatMessageResponse} message SendChatMessageResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendChatMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SendChatMessageResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SendChatMessageResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SendChatMessageResponse} SendChatMessageResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendChatMessageResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SendChatMessageResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 6:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SendChatMessageResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SendChatMessageResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SendChatMessageResponse} SendChatMessageResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendChatMessageResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SendChatMessageResponse message.
     * @function verify
     * @memberof SendChatMessageResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SendChatMessageResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        return null;
    };

    /**
     * Creates a SendChatMessageResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SendChatMessageResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SendChatMessageResponse} SendChatMessageResponse
     */
    SendChatMessageResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SendChatMessageResponse)
            return object;
        let message = new $root.SendChatMessageResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SendChatMessageResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".SendChatMessageResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        return message;
    };

    /**
     * Creates a plain object from a SendChatMessageResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SendChatMessageResponse
     * @static
     * @param {SendChatMessageResponse} message SendChatMessageResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SendChatMessageResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        return object;
    };

    /**
     * Converts this SendChatMessageResponse to JSON.
     * @function toJSON
     * @memberof SendChatMessageResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SendChatMessageResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SendChatMessageResponse;
})();

export const ModifyOTRStatusRequest = $root.ModifyOTRStatusRequest = (() => {

    /**
     * Properties of a ModifyOTRStatusRequest.
     * @exports IModifyOTRStatusRequest
     * @interface IModifyOTRStatusRequest
     * @property {IRequestHeader|null} [requestHeader] ModifyOTRStatusRequest requestHeader
     * @property {OffTheRecordStatus|null} [otrStatus] ModifyOTRStatusRequest otrStatus
     * @property {IEventRequestHeader|null} [eventRequestHeader] ModifyOTRStatusRequest eventRequestHeader
     */

    /**
     * Constructs a new ModifyOTRStatusRequest.
     * @exports ModifyOTRStatusRequest
     * @classdesc Represents a ModifyOTRStatusRequest.
     * @implements IModifyOTRStatusRequest
     * @constructor
     * @param {IModifyOTRStatusRequest=} [properties] Properties to set
     */
    function ModifyOTRStatusRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ModifyOTRStatusRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof ModifyOTRStatusRequest
     * @instance
     */
    ModifyOTRStatusRequest.prototype.requestHeader = null;

    /**
     * ModifyOTRStatusRequest otrStatus.
     * @member {OffTheRecordStatus} otrStatus
     * @memberof ModifyOTRStatusRequest
     * @instance
     */
    ModifyOTRStatusRequest.prototype.otrStatus = 0;

    /**
     * ModifyOTRStatusRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof ModifyOTRStatusRequest
     * @instance
     */
    ModifyOTRStatusRequest.prototype.eventRequestHeader = null;

    /**
     * Creates a new ModifyOTRStatusRequest instance using the specified properties.
     * @function create
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {IModifyOTRStatusRequest=} [properties] Properties to set
     * @returns {ModifyOTRStatusRequest} ModifyOTRStatusRequest instance
     */
    ModifyOTRStatusRequest.create = function create(properties) {
        return new ModifyOTRStatusRequest(properties);
    };

    /**
     * Encodes the specified ModifyOTRStatusRequest message. Does not implicitly {@link ModifyOTRStatusRequest.verify|verify} messages.
     * @function encode
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {IModifyOTRStatusRequest} message ModifyOTRStatusRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyOTRStatusRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.otrStatus);
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ModifyOTRStatusRequest message, length delimited. Does not implicitly {@link ModifyOTRStatusRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {IModifyOTRStatusRequest} message ModifyOTRStatusRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyOTRStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ModifyOTRStatusRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ModifyOTRStatusRequest} ModifyOTRStatusRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyOTRStatusRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModifyOTRStatusRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 3:
                message.otrStatus = reader.int32();
                break;
            case 5:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ModifyOTRStatusRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ModifyOTRStatusRequest} ModifyOTRStatusRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyOTRStatusRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ModifyOTRStatusRequest message.
     * @function verify
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ModifyOTRStatusRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            switch (message.otrStatus) {
            default:
                return "otrStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        return null;
    };

    /**
     * Creates a ModifyOTRStatusRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ModifyOTRStatusRequest} ModifyOTRStatusRequest
     */
    ModifyOTRStatusRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ModifyOTRStatusRequest)
            return object;
        let message = new $root.ModifyOTRStatusRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".ModifyOTRStatusRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        switch (object.otrStatus) {
        case "OFF_THE_RECORD_STATUS_UNKNOWN":
        case 0:
            message.otrStatus = 0;
            break;
        case "OFF_THE_RECORD_STATUS_OFF_THE_RECORD":
        case 1:
            message.otrStatus = 1;
            break;
        case "OFF_THE_RECORD_STATUS_ON_THE_RECORD":
        case 2:
            message.otrStatus = 2;
            break;
        }
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".ModifyOTRStatusRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a ModifyOTRStatusRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ModifyOTRStatusRequest
     * @static
     * @param {ModifyOTRStatusRequest} message ModifyOTRStatusRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ModifyOTRStatusRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.otrStatus = options.enums === String ? "OFF_THE_RECORD_STATUS_UNKNOWN" : 0;
            object.eventRequestHeader = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.otrStatus != null && message.hasOwnProperty("otrStatus"))
            object.otrStatus = options.enums === String ? $root.OffTheRecordStatus[message.otrStatus] : message.otrStatus;
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        return object;
    };

    /**
     * Converts this ModifyOTRStatusRequest to JSON.
     * @function toJSON
     * @memberof ModifyOTRStatusRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ModifyOTRStatusRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ModifyOTRStatusRequest;
})();

export const ModifyOTRStatusResponse = $root.ModifyOTRStatusResponse = (() => {

    /**
     * Properties of a ModifyOTRStatusResponse.
     * @exports IModifyOTRStatusResponse
     * @interface IModifyOTRStatusResponse
     * @property {IResponseHeader|null} [responseHeader] ModifyOTRStatusResponse responseHeader
     * @property {IEvent|null} [createdEvent] ModifyOTRStatusResponse createdEvent
     */

    /**
     * Constructs a new ModifyOTRStatusResponse.
     * @exports ModifyOTRStatusResponse
     * @classdesc Represents a ModifyOTRStatusResponse.
     * @implements IModifyOTRStatusResponse
     * @constructor
     * @param {IModifyOTRStatusResponse=} [properties] Properties to set
     */
    function ModifyOTRStatusResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ModifyOTRStatusResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof ModifyOTRStatusResponse
     * @instance
     */
    ModifyOTRStatusResponse.prototype.responseHeader = null;

    /**
     * ModifyOTRStatusResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof ModifyOTRStatusResponse
     * @instance
     */
    ModifyOTRStatusResponse.prototype.createdEvent = null;

    /**
     * Creates a new ModifyOTRStatusResponse instance using the specified properties.
     * @function create
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {IModifyOTRStatusResponse=} [properties] Properties to set
     * @returns {ModifyOTRStatusResponse} ModifyOTRStatusResponse instance
     */
    ModifyOTRStatusResponse.create = function create(properties) {
        return new ModifyOTRStatusResponse(properties);
    };

    /**
     * Encodes the specified ModifyOTRStatusResponse message. Does not implicitly {@link ModifyOTRStatusResponse.verify|verify} messages.
     * @function encode
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {IModifyOTRStatusResponse} message ModifyOTRStatusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyOTRStatusResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ModifyOTRStatusResponse message, length delimited. Does not implicitly {@link ModifyOTRStatusResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {IModifyOTRStatusResponse} message ModifyOTRStatusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ModifyOTRStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ModifyOTRStatusResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ModifyOTRStatusResponse} ModifyOTRStatusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyOTRStatusResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModifyOTRStatusResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 4:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ModifyOTRStatusResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ModifyOTRStatusResponse} ModifyOTRStatusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ModifyOTRStatusResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ModifyOTRStatusResponse message.
     * @function verify
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ModifyOTRStatusResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        return null;
    };

    /**
     * Creates a ModifyOTRStatusResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ModifyOTRStatusResponse} ModifyOTRStatusResponse
     */
    ModifyOTRStatusResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ModifyOTRStatusResponse)
            return object;
        let message = new $root.ModifyOTRStatusResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".ModifyOTRStatusResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".ModifyOTRStatusResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        return message;
    };

    /**
     * Creates a plain object from a ModifyOTRStatusResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ModifyOTRStatusResponse
     * @static
     * @param {ModifyOTRStatusResponse} message ModifyOTRStatusResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ModifyOTRStatusResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        return object;
    };

    /**
     * Converts this ModifyOTRStatusResponse to JSON.
     * @function toJSON
     * @memberof ModifyOTRStatusResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ModifyOTRStatusResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return ModifyOTRStatusResponse;
})();

export const SendOffnetworkInvitationRequest = $root.SendOffnetworkInvitationRequest = (() => {

    /**
     * Properties of a SendOffnetworkInvitationRequest.
     * @exports ISendOffnetworkInvitationRequest
     * @interface ISendOffnetworkInvitationRequest
     * @property {IRequestHeader|null} [requestHeader] SendOffnetworkInvitationRequest requestHeader
     * @property {IOffnetworkAddress|null} [inviteeAddress] SendOffnetworkInvitationRequest inviteeAddress
     */

    /**
     * Constructs a new SendOffnetworkInvitationRequest.
     * @exports SendOffnetworkInvitationRequest
     * @classdesc Represents a SendOffnetworkInvitationRequest.
     * @implements ISendOffnetworkInvitationRequest
     * @constructor
     * @param {ISendOffnetworkInvitationRequest=} [properties] Properties to set
     */
    function SendOffnetworkInvitationRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SendOffnetworkInvitationRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SendOffnetworkInvitationRequest
     * @instance
     */
    SendOffnetworkInvitationRequest.prototype.requestHeader = null;

    /**
     * SendOffnetworkInvitationRequest inviteeAddress.
     * @member {IOffnetworkAddress|null|undefined} inviteeAddress
     * @memberof SendOffnetworkInvitationRequest
     * @instance
     */
    SendOffnetworkInvitationRequest.prototype.inviteeAddress = null;

    /**
     * Creates a new SendOffnetworkInvitationRequest instance using the specified properties.
     * @function create
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {ISendOffnetworkInvitationRequest=} [properties] Properties to set
     * @returns {SendOffnetworkInvitationRequest} SendOffnetworkInvitationRequest instance
     */
    SendOffnetworkInvitationRequest.create = function create(properties) {
        return new SendOffnetworkInvitationRequest(properties);
    };

    /**
     * Encodes the specified SendOffnetworkInvitationRequest message. Does not implicitly {@link SendOffnetworkInvitationRequest.verify|verify} messages.
     * @function encode
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {ISendOffnetworkInvitationRequest} message SendOffnetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendOffnetworkInvitationRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.inviteeAddress != null && message.hasOwnProperty("inviteeAddress"))
            $root.OffnetworkAddress.encode(message.inviteeAddress, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SendOffnetworkInvitationRequest message, length delimited. Does not implicitly {@link SendOffnetworkInvitationRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {ISendOffnetworkInvitationRequest} message SendOffnetworkInvitationRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendOffnetworkInvitationRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SendOffnetworkInvitationRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SendOffnetworkInvitationRequest} SendOffnetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendOffnetworkInvitationRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SendOffnetworkInvitationRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.inviteeAddress = $root.OffnetworkAddress.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SendOffnetworkInvitationRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SendOffnetworkInvitationRequest} SendOffnetworkInvitationRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendOffnetworkInvitationRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SendOffnetworkInvitationRequest message.
     * @function verify
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SendOffnetworkInvitationRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.inviteeAddress != null && message.hasOwnProperty("inviteeAddress")) {
            let error = $root.OffnetworkAddress.verify(message.inviteeAddress);
            if (error)
                return "inviteeAddress." + error;
        }
        return null;
    };

    /**
     * Creates a SendOffnetworkInvitationRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SendOffnetworkInvitationRequest} SendOffnetworkInvitationRequest
     */
    SendOffnetworkInvitationRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SendOffnetworkInvitationRequest)
            return object;
        let message = new $root.SendOffnetworkInvitationRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SendOffnetworkInvitationRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.inviteeAddress != null) {
            if (typeof object.inviteeAddress !== "object")
                throw TypeError(".SendOffnetworkInvitationRequest.inviteeAddress: object expected");
            message.inviteeAddress = $root.OffnetworkAddress.fromObject(object.inviteeAddress);
        }
        return message;
    };

    /**
     * Creates a plain object from a SendOffnetworkInvitationRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SendOffnetworkInvitationRequest
     * @static
     * @param {SendOffnetworkInvitationRequest} message SendOffnetworkInvitationRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SendOffnetworkInvitationRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.inviteeAddress = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.inviteeAddress != null && message.hasOwnProperty("inviteeAddress"))
            object.inviteeAddress = $root.OffnetworkAddress.toObject(message.inviteeAddress, options);
        return object;
    };

    /**
     * Converts this SendOffnetworkInvitationRequest to JSON.
     * @function toJSON
     * @memberof SendOffnetworkInvitationRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SendOffnetworkInvitationRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SendOffnetworkInvitationRequest;
})();

export const SendOffnetworkInvitationResponse = $root.SendOffnetworkInvitationResponse = (() => {

    /**
     * Properties of a SendOffnetworkInvitationResponse.
     * @exports ISendOffnetworkInvitationResponse
     * @interface ISendOffnetworkInvitationResponse
     * @property {IResponseHeader|null} [responseHeader] SendOffnetworkInvitationResponse responseHeader
     */

    /**
     * Constructs a new SendOffnetworkInvitationResponse.
     * @exports SendOffnetworkInvitationResponse
     * @classdesc Represents a SendOffnetworkInvitationResponse.
     * @implements ISendOffnetworkInvitationResponse
     * @constructor
     * @param {ISendOffnetworkInvitationResponse=} [properties] Properties to set
     */
    function SendOffnetworkInvitationResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SendOffnetworkInvitationResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SendOffnetworkInvitationResponse
     * @instance
     */
    SendOffnetworkInvitationResponse.prototype.responseHeader = null;

    /**
     * Creates a new SendOffnetworkInvitationResponse instance using the specified properties.
     * @function create
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {ISendOffnetworkInvitationResponse=} [properties] Properties to set
     * @returns {SendOffnetworkInvitationResponse} SendOffnetworkInvitationResponse instance
     */
    SendOffnetworkInvitationResponse.create = function create(properties) {
        return new SendOffnetworkInvitationResponse(properties);
    };

    /**
     * Encodes the specified SendOffnetworkInvitationResponse message. Does not implicitly {@link SendOffnetworkInvitationResponse.verify|verify} messages.
     * @function encode
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {ISendOffnetworkInvitationResponse} message SendOffnetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendOffnetworkInvitationResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SendOffnetworkInvitationResponse message, length delimited. Does not implicitly {@link SendOffnetworkInvitationResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {ISendOffnetworkInvitationResponse} message SendOffnetworkInvitationResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SendOffnetworkInvitationResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SendOffnetworkInvitationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SendOffnetworkInvitationResponse} SendOffnetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendOffnetworkInvitationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SendOffnetworkInvitationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SendOffnetworkInvitationResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SendOffnetworkInvitationResponse} SendOffnetworkInvitationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SendOffnetworkInvitationResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SendOffnetworkInvitationResponse message.
     * @function verify
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SendOffnetworkInvitationResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        return null;
    };

    /**
     * Creates a SendOffnetworkInvitationResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SendOffnetworkInvitationResponse} SendOffnetworkInvitationResponse
     */
    SendOffnetworkInvitationResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SendOffnetworkInvitationResponse)
            return object;
        let message = new $root.SendOffnetworkInvitationResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SendOffnetworkInvitationResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a SendOffnetworkInvitationResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SendOffnetworkInvitationResponse
     * @static
     * @param {SendOffnetworkInvitationResponse} message SendOffnetworkInvitationResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SendOffnetworkInvitationResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        return object;
    };

    /**
     * Converts this SendOffnetworkInvitationResponse to JSON.
     * @function toJSON
     * @memberof SendOffnetworkInvitationResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SendOffnetworkInvitationResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SendOffnetworkInvitationResponse;
})();

export const SetActiveClientRequest = $root.SetActiveClientRequest = (() => {

    /**
     * Properties of a SetActiveClientRequest.
     * @exports ISetActiveClientRequest
     * @interface ISetActiveClientRequest
     * @property {IRequestHeader|null} [requestHeader] SetActiveClientRequest requestHeader
     * @property {boolean|null} [isActive] SetActiveClientRequest isActive
     * @property {string|null} [fullJid] SetActiveClientRequest fullJid
     * @property {number|Long|null} [timeoutSecs] SetActiveClientRequest timeoutSecs
     */

    /**
     * Constructs a new SetActiveClientRequest.
     * @exports SetActiveClientRequest
     * @classdesc Represents a SetActiveClientRequest.
     * @implements ISetActiveClientRequest
     * @constructor
     * @param {ISetActiveClientRequest=} [properties] Properties to set
     */
    function SetActiveClientRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetActiveClientRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetActiveClientRequest
     * @instance
     */
    SetActiveClientRequest.prototype.requestHeader = null;

    /**
     * SetActiveClientRequest isActive.
     * @member {boolean} isActive
     * @memberof SetActiveClientRequest
     * @instance
     */
    SetActiveClientRequest.prototype.isActive = false;

    /**
     * SetActiveClientRequest fullJid.
     * @member {string} fullJid
     * @memberof SetActiveClientRequest
     * @instance
     */
    SetActiveClientRequest.prototype.fullJid = "";

    /**
     * SetActiveClientRequest timeoutSecs.
     * @member {number|Long} timeoutSecs
     * @memberof SetActiveClientRequest
     * @instance
     */
    SetActiveClientRequest.prototype.timeoutSecs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SetActiveClientRequest instance using the specified properties.
     * @function create
     * @memberof SetActiveClientRequest
     * @static
     * @param {ISetActiveClientRequest=} [properties] Properties to set
     * @returns {SetActiveClientRequest} SetActiveClientRequest instance
     */
    SetActiveClientRequest.create = function create(properties) {
        return new SetActiveClientRequest(properties);
    };

    /**
     * Encodes the specified SetActiveClientRequest message. Does not implicitly {@link SetActiveClientRequest.verify|verify} messages.
     * @function encode
     * @memberof SetActiveClientRequest
     * @static
     * @param {ISetActiveClientRequest} message SetActiveClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetActiveClientRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.isActive != null && message.hasOwnProperty("isActive"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isActive);
        if (message.fullJid != null && message.hasOwnProperty("fullJid"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.fullJid);
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.timeoutSecs);
        return writer;
    };

    /**
     * Encodes the specified SetActiveClientRequest message, length delimited. Does not implicitly {@link SetActiveClientRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetActiveClientRequest
     * @static
     * @param {ISetActiveClientRequest} message SetActiveClientRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetActiveClientRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetActiveClientRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetActiveClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetActiveClientRequest} SetActiveClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetActiveClientRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetActiveClientRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.isActive = reader.bool();
                break;
            case 3:
                message.fullJid = reader.string();
                break;
            case 4:
                message.timeoutSecs = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetActiveClientRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetActiveClientRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetActiveClientRequest} SetActiveClientRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetActiveClientRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetActiveClientRequest message.
     * @function verify
     * @memberof SetActiveClientRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetActiveClientRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.isActive != null && message.hasOwnProperty("isActive"))
            if (typeof message.isActive !== "boolean")
                return "isActive: boolean expected";
        if (message.fullJid != null && message.hasOwnProperty("fullJid"))
            if (!$util.isString(message.fullJid))
                return "fullJid: string expected";
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (!$util.isInteger(message.timeoutSecs) && !(message.timeoutSecs && $util.isInteger(message.timeoutSecs.low) && $util.isInteger(message.timeoutSecs.high)))
                return "timeoutSecs: integer|Long expected";
        return null;
    };

    /**
     * Creates a SetActiveClientRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetActiveClientRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetActiveClientRequest} SetActiveClientRequest
     */
    SetActiveClientRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetActiveClientRequest)
            return object;
        let message = new $root.SetActiveClientRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetActiveClientRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.isActive != null)
            message.isActive = Boolean(object.isActive);
        if (object.fullJid != null)
            message.fullJid = String(object.fullJid);
        if (object.timeoutSecs != null)
            if ($util.Long)
                (message.timeoutSecs = $util.Long.fromValue(object.timeoutSecs)).unsigned = true;
            else if (typeof object.timeoutSecs === "string")
                message.timeoutSecs = parseInt(object.timeoutSecs, 10);
            else if (typeof object.timeoutSecs === "number")
                message.timeoutSecs = object.timeoutSecs;
            else if (typeof object.timeoutSecs === "object")
                message.timeoutSecs = new $util.LongBits(object.timeoutSecs.low >>> 0, object.timeoutSecs.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SetActiveClientRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetActiveClientRequest
     * @static
     * @param {SetActiveClientRequest} message SetActiveClientRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetActiveClientRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.isActive = false;
            object.fullJid = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timeoutSecs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timeoutSecs = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.isActive != null && message.hasOwnProperty("isActive"))
            object.isActive = message.isActive;
        if (message.fullJid != null && message.hasOwnProperty("fullJid"))
            object.fullJid = message.fullJid;
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (typeof message.timeoutSecs === "number")
                object.timeoutSecs = options.longs === String ? String(message.timeoutSecs) : message.timeoutSecs;
            else
                object.timeoutSecs = options.longs === String ? $util.Long.prototype.toString.call(message.timeoutSecs) : options.longs === Number ? new $util.LongBits(message.timeoutSecs.low >>> 0, message.timeoutSecs.high >>> 0).toNumber(true) : message.timeoutSecs;
        return object;
    };

    /**
     * Converts this SetActiveClientRequest to JSON.
     * @function toJSON
     * @memberof SetActiveClientRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetActiveClientRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetActiveClientRequest;
})();

export const SetActiveClientResponse = $root.SetActiveClientResponse = (() => {

    /**
     * Properties of a SetActiveClientResponse.
     * @exports ISetActiveClientResponse
     * @interface ISetActiveClientResponse
     * @property {IResponseHeader|null} [responseHeader] SetActiveClientResponse responseHeader
     */

    /**
     * Constructs a new SetActiveClientResponse.
     * @exports SetActiveClientResponse
     * @classdesc Represents a SetActiveClientResponse.
     * @implements ISetActiveClientResponse
     * @constructor
     * @param {ISetActiveClientResponse=} [properties] Properties to set
     */
    function SetActiveClientResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetActiveClientResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetActiveClientResponse
     * @instance
     */
    SetActiveClientResponse.prototype.responseHeader = null;

    /**
     * Creates a new SetActiveClientResponse instance using the specified properties.
     * @function create
     * @memberof SetActiveClientResponse
     * @static
     * @param {ISetActiveClientResponse=} [properties] Properties to set
     * @returns {SetActiveClientResponse} SetActiveClientResponse instance
     */
    SetActiveClientResponse.create = function create(properties) {
        return new SetActiveClientResponse(properties);
    };

    /**
     * Encodes the specified SetActiveClientResponse message. Does not implicitly {@link SetActiveClientResponse.verify|verify} messages.
     * @function encode
     * @memberof SetActiveClientResponse
     * @static
     * @param {ISetActiveClientResponse} message SetActiveClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetActiveClientResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetActiveClientResponse message, length delimited. Does not implicitly {@link SetActiveClientResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetActiveClientResponse
     * @static
     * @param {ISetActiveClientResponse} message SetActiveClientResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetActiveClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetActiveClientResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetActiveClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetActiveClientResponse} SetActiveClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetActiveClientResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetActiveClientResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetActiveClientResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetActiveClientResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetActiveClientResponse} SetActiveClientResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetActiveClientResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetActiveClientResponse message.
     * @function verify
     * @memberof SetActiveClientResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetActiveClientResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        return null;
    };

    /**
     * Creates a SetActiveClientResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetActiveClientResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetActiveClientResponse} SetActiveClientResponse
     */
    SetActiveClientResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetActiveClientResponse)
            return object;
        let message = new $root.SetActiveClientResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetActiveClientResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetActiveClientResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetActiveClientResponse
     * @static
     * @param {SetActiveClientResponse} message SetActiveClientResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetActiveClientResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        return object;
    };

    /**
     * Converts this SetActiveClientResponse to JSON.
     * @function toJSON
     * @memberof SetActiveClientResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetActiveClientResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetActiveClientResponse;
})();

export const SetConversationLevelRequest = $root.SetConversationLevelRequest = (() => {

    /**
     * Properties of a SetConversationLevelRequest.
     * @exports ISetConversationLevelRequest
     * @interface ISetConversationLevelRequest
     * @property {IRequestHeader|null} [requestHeader] SetConversationLevelRequest requestHeader
     */

    /**
     * Constructs a new SetConversationLevelRequest.
     * @exports SetConversationLevelRequest
     * @classdesc Represents a SetConversationLevelRequest.
     * @implements ISetConversationLevelRequest
     * @constructor
     * @param {ISetConversationLevelRequest=} [properties] Properties to set
     */
    function SetConversationLevelRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetConversationLevelRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetConversationLevelRequest
     * @instance
     */
    SetConversationLevelRequest.prototype.requestHeader = null;

    /**
     * Creates a new SetConversationLevelRequest instance using the specified properties.
     * @function create
     * @memberof SetConversationLevelRequest
     * @static
     * @param {ISetConversationLevelRequest=} [properties] Properties to set
     * @returns {SetConversationLevelRequest} SetConversationLevelRequest instance
     */
    SetConversationLevelRequest.create = function create(properties) {
        return new SetConversationLevelRequest(properties);
    };

    /**
     * Encodes the specified SetConversationLevelRequest message. Does not implicitly {@link SetConversationLevelRequest.verify|verify} messages.
     * @function encode
     * @memberof SetConversationLevelRequest
     * @static
     * @param {ISetConversationLevelRequest} message SetConversationLevelRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationLevelRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetConversationLevelRequest message, length delimited. Does not implicitly {@link SetConversationLevelRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetConversationLevelRequest
     * @static
     * @param {ISetConversationLevelRequest} message SetConversationLevelRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationLevelRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetConversationLevelRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetConversationLevelRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetConversationLevelRequest} SetConversationLevelRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationLevelRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetConversationLevelRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetConversationLevelRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetConversationLevelRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetConversationLevelRequest} SetConversationLevelRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationLevelRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetConversationLevelRequest message.
     * @function verify
     * @memberof SetConversationLevelRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetConversationLevelRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        return null;
    };

    /**
     * Creates a SetConversationLevelRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetConversationLevelRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetConversationLevelRequest} SetConversationLevelRequest
     */
    SetConversationLevelRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetConversationLevelRequest)
            return object;
        let message = new $root.SetConversationLevelRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetConversationLevelRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetConversationLevelRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetConversationLevelRequest
     * @static
     * @param {SetConversationLevelRequest} message SetConversationLevelRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetConversationLevelRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.requestHeader = null;
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        return object;
    };

    /**
     * Converts this SetConversationLevelRequest to JSON.
     * @function toJSON
     * @memberof SetConversationLevelRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetConversationLevelRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetConversationLevelRequest;
})();

export const SetConversationLevelResponse = $root.SetConversationLevelResponse = (() => {

    /**
     * Properties of a SetConversationLevelResponse.
     * @exports ISetConversationLevelResponse
     * @interface ISetConversationLevelResponse
     * @property {IResponseHeader|null} [responseHeader] SetConversationLevelResponse responseHeader
     */

    /**
     * Constructs a new SetConversationLevelResponse.
     * @exports SetConversationLevelResponse
     * @classdesc Represents a SetConversationLevelResponse.
     * @implements ISetConversationLevelResponse
     * @constructor
     * @param {ISetConversationLevelResponse=} [properties] Properties to set
     */
    function SetConversationLevelResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetConversationLevelResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetConversationLevelResponse
     * @instance
     */
    SetConversationLevelResponse.prototype.responseHeader = null;

    /**
     * Creates a new SetConversationLevelResponse instance using the specified properties.
     * @function create
     * @memberof SetConversationLevelResponse
     * @static
     * @param {ISetConversationLevelResponse=} [properties] Properties to set
     * @returns {SetConversationLevelResponse} SetConversationLevelResponse instance
     */
    SetConversationLevelResponse.create = function create(properties) {
        return new SetConversationLevelResponse(properties);
    };

    /**
     * Encodes the specified SetConversationLevelResponse message. Does not implicitly {@link SetConversationLevelResponse.verify|verify} messages.
     * @function encode
     * @memberof SetConversationLevelResponse
     * @static
     * @param {ISetConversationLevelResponse} message SetConversationLevelResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationLevelResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetConversationLevelResponse message, length delimited. Does not implicitly {@link SetConversationLevelResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetConversationLevelResponse
     * @static
     * @param {ISetConversationLevelResponse} message SetConversationLevelResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationLevelResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetConversationLevelResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetConversationLevelResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetConversationLevelResponse} SetConversationLevelResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationLevelResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetConversationLevelResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetConversationLevelResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetConversationLevelResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetConversationLevelResponse} SetConversationLevelResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationLevelResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetConversationLevelResponse message.
     * @function verify
     * @memberof SetConversationLevelResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetConversationLevelResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        return null;
    };

    /**
     * Creates a SetConversationLevelResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetConversationLevelResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetConversationLevelResponse} SetConversationLevelResponse
     */
    SetConversationLevelResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetConversationLevelResponse)
            return object;
        let message = new $root.SetConversationLevelResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetConversationLevelResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetConversationLevelResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetConversationLevelResponse
     * @static
     * @param {SetConversationLevelResponse} message SetConversationLevelResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetConversationLevelResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        return object;
    };

    /**
     * Converts this SetConversationLevelResponse to JSON.
     * @function toJSON
     * @memberof SetConversationLevelResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetConversationLevelResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetConversationLevelResponse;
})();

export const SetConversationNotificationLevelRequest = $root.SetConversationNotificationLevelRequest = (() => {

    /**
     * Properties of a SetConversationNotificationLevelRequest.
     * @exports ISetConversationNotificationLevelRequest
     * @interface ISetConversationNotificationLevelRequest
     * @property {IRequestHeader|null} [requestHeader] SetConversationNotificationLevelRequest requestHeader
     * @property {IConversationId|null} [conversationId] SetConversationNotificationLevelRequest conversationId
     * @property {NotificationLevel|null} [level] SetConversationNotificationLevelRequest level
     */

    /**
     * Constructs a new SetConversationNotificationLevelRequest.
     * @exports SetConversationNotificationLevelRequest
     * @classdesc Represents a SetConversationNotificationLevelRequest.
     * @implements ISetConversationNotificationLevelRequest
     * @constructor
     * @param {ISetConversationNotificationLevelRequest=} [properties] Properties to set
     */
    function SetConversationNotificationLevelRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetConversationNotificationLevelRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetConversationNotificationLevelRequest
     * @instance
     */
    SetConversationNotificationLevelRequest.prototype.requestHeader = null;

    /**
     * SetConversationNotificationLevelRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetConversationNotificationLevelRequest
     * @instance
     */
    SetConversationNotificationLevelRequest.prototype.conversationId = null;

    /**
     * SetConversationNotificationLevelRequest level.
     * @member {NotificationLevel} level
     * @memberof SetConversationNotificationLevelRequest
     * @instance
     */
    SetConversationNotificationLevelRequest.prototype.level = 0;

    /**
     * Creates a new SetConversationNotificationLevelRequest instance using the specified properties.
     * @function create
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {ISetConversationNotificationLevelRequest=} [properties] Properties to set
     * @returns {SetConversationNotificationLevelRequest} SetConversationNotificationLevelRequest instance
     */
    SetConversationNotificationLevelRequest.create = function create(properties) {
        return new SetConversationNotificationLevelRequest(properties);
    };

    /**
     * Encodes the specified SetConversationNotificationLevelRequest message. Does not implicitly {@link SetConversationNotificationLevelRequest.verify|verify} messages.
     * @function encode
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {ISetConversationNotificationLevelRequest} message SetConversationNotificationLevelRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.level != null && message.hasOwnProperty("level"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
        return writer;
    };

    /**
     * Encodes the specified SetConversationNotificationLevelRequest message, length delimited. Does not implicitly {@link SetConversationNotificationLevelRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {ISetConversationNotificationLevelRequest} message SetConversationNotificationLevelRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetConversationNotificationLevelRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetConversationNotificationLevelRequest} SetConversationNotificationLevelRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetConversationNotificationLevelRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.level = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetConversationNotificationLevelRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetConversationNotificationLevelRequest} SetConversationNotificationLevelRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetConversationNotificationLevelRequest message.
     * @function verify
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetConversationNotificationLevelRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.level != null && message.hasOwnProperty("level"))
            switch (message.level) {
            default:
                return "level: enum value expected";
            case 0:
            case 10:
            case 30:
                break;
            }
        return null;
    };

    /**
     * Creates a SetConversationNotificationLevelRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetConversationNotificationLevelRequest} SetConversationNotificationLevelRequest
     */
    SetConversationNotificationLevelRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetConversationNotificationLevelRequest)
            return object;
        let message = new $root.SetConversationNotificationLevelRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetConversationNotificationLevelRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetConversationNotificationLevelRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.level) {
        case "NOTIFICATION_LEVEL_UNKNOWN":
        case 0:
            message.level = 0;
            break;
        case "NOTIFICATION_LEVEL_QUIET":
        case 10:
            message.level = 10;
            break;
        case "NOTIFICATION_LEVEL_RING":
        case 30:
            message.level = 30;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SetConversationNotificationLevelRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetConversationNotificationLevelRequest
     * @static
     * @param {SetConversationNotificationLevelRequest} message SetConversationNotificationLevelRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetConversationNotificationLevelRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            object.level = options.enums === String ? "NOTIFICATION_LEVEL_UNKNOWN" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.level != null && message.hasOwnProperty("level"))
            object.level = options.enums === String ? $root.NotificationLevel[message.level] : message.level;
        return object;
    };

    /**
     * Converts this SetConversationNotificationLevelRequest to JSON.
     * @function toJSON
     * @memberof SetConversationNotificationLevelRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetConversationNotificationLevelRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetConversationNotificationLevelRequest;
})();

export const SetConversationNotificationLevelResponse = $root.SetConversationNotificationLevelResponse = (() => {

    /**
     * Properties of a SetConversationNotificationLevelResponse.
     * @exports ISetConversationNotificationLevelResponse
     * @interface ISetConversationNotificationLevelResponse
     * @property {IResponseHeader|null} [responseHeader] SetConversationNotificationLevelResponse responseHeader
     * @property {number|Long|null} [timestamp] SetConversationNotificationLevelResponse timestamp
     */

    /**
     * Constructs a new SetConversationNotificationLevelResponse.
     * @exports SetConversationNotificationLevelResponse
     * @classdesc Represents a SetConversationNotificationLevelResponse.
     * @implements ISetConversationNotificationLevelResponse
     * @constructor
     * @param {ISetConversationNotificationLevelResponse=} [properties] Properties to set
     */
    function SetConversationNotificationLevelResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetConversationNotificationLevelResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetConversationNotificationLevelResponse
     * @instance
     */
    SetConversationNotificationLevelResponse.prototype.responseHeader = null;

    /**
     * SetConversationNotificationLevelResponse timestamp.
     * @member {number|Long} timestamp
     * @memberof SetConversationNotificationLevelResponse
     * @instance
     */
    SetConversationNotificationLevelResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SetConversationNotificationLevelResponse instance using the specified properties.
     * @function create
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {ISetConversationNotificationLevelResponse=} [properties] Properties to set
     * @returns {SetConversationNotificationLevelResponse} SetConversationNotificationLevelResponse instance
     */
    SetConversationNotificationLevelResponse.create = function create(properties) {
        return new SetConversationNotificationLevelResponse(properties);
    };

    /**
     * Encodes the specified SetConversationNotificationLevelResponse message. Does not implicitly {@link SetConversationNotificationLevelResponse.verify|verify} messages.
     * @function encode
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {ISetConversationNotificationLevelResponse} message SetConversationNotificationLevelResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
        return writer;
    };

    /**
     * Encodes the specified SetConversationNotificationLevelResponse message, length delimited. Does not implicitly {@link SetConversationNotificationLevelResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {ISetConversationNotificationLevelResponse} message SetConversationNotificationLevelResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetConversationNotificationLevelResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetConversationNotificationLevelResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetConversationNotificationLevelResponse} SetConversationNotificationLevelResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetConversationNotificationLevelResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.timestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetConversationNotificationLevelResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetConversationNotificationLevelResponse} SetConversationNotificationLevelResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetConversationNotificationLevelResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetConversationNotificationLevelResponse message.
     * @function verify
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetConversationNotificationLevelResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a SetConversationNotificationLevelResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetConversationNotificationLevelResponse} SetConversationNotificationLevelResponse
     */
    SetConversationNotificationLevelResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetConversationNotificationLevelResponse)
            return object;
        let message = new $root.SetConversationNotificationLevelResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetConversationNotificationLevelResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SetConversationNotificationLevelResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetConversationNotificationLevelResponse
     * @static
     * @param {SetConversationNotificationLevelResponse} message SetConversationNotificationLevelResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetConversationNotificationLevelResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        return object;
    };

    /**
     * Converts this SetConversationNotificationLevelResponse to JSON.
     * @function toJSON
     * @memberof SetConversationNotificationLevelResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetConversationNotificationLevelResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetConversationNotificationLevelResponse;
})();

export const SetFocusRequest = $root.SetFocusRequest = (() => {

    /**
     * Properties of a SetFocusRequest.
     * @exports ISetFocusRequest
     * @interface ISetFocusRequest
     * @property {IRequestHeader|null} [requestHeader] SetFocusRequest requestHeader
     * @property {IConversationId|null} [conversationId] SetFocusRequest conversationId
     * @property {FocusType|null} [type] SetFocusRequest type
     * @property {number|null} [timeoutSecs] SetFocusRequest timeoutSecs
     */

    /**
     * Constructs a new SetFocusRequest.
     * @exports SetFocusRequest
     * @classdesc Represents a SetFocusRequest.
     * @implements ISetFocusRequest
     * @constructor
     * @param {ISetFocusRequest=} [properties] Properties to set
     */
    function SetFocusRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetFocusRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetFocusRequest
     * @instance
     */
    SetFocusRequest.prototype.requestHeader = null;

    /**
     * SetFocusRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetFocusRequest
     * @instance
     */
    SetFocusRequest.prototype.conversationId = null;

    /**
     * SetFocusRequest type.
     * @member {FocusType} type
     * @memberof SetFocusRequest
     * @instance
     */
    SetFocusRequest.prototype.type = 0;

    /**
     * SetFocusRequest timeoutSecs.
     * @member {number} timeoutSecs
     * @memberof SetFocusRequest
     * @instance
     */
    SetFocusRequest.prototype.timeoutSecs = 0;

    /**
     * Creates a new SetFocusRequest instance using the specified properties.
     * @function create
     * @memberof SetFocusRequest
     * @static
     * @param {ISetFocusRequest=} [properties] Properties to set
     * @returns {SetFocusRequest} SetFocusRequest instance
     */
    SetFocusRequest.create = function create(properties) {
        return new SetFocusRequest(properties);
    };

    /**
     * Encodes the specified SetFocusRequest message. Does not implicitly {@link SetFocusRequest.verify|verify} messages.
     * @function encode
     * @memberof SetFocusRequest
     * @static
     * @param {ISetFocusRequest} message SetFocusRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timeoutSecs);
        return writer;
    };

    /**
     * Encodes the specified SetFocusRequest message, length delimited. Does not implicitly {@link SetFocusRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetFocusRequest
     * @static
     * @param {ISetFocusRequest} message SetFocusRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetFocusRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetFocusRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetFocusRequest} SetFocusRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetFocusRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.type = reader.int32();
                break;
            case 4:
                message.timeoutSecs = reader.uint32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetFocusRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetFocusRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetFocusRequest} SetFocusRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetFocusRequest message.
     * @function verify
     * @memberof SetFocusRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetFocusRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            if (!$util.isInteger(message.timeoutSecs))
                return "timeoutSecs: integer expected";
        return null;
    };

    /**
     * Creates a SetFocusRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetFocusRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetFocusRequest} SetFocusRequest
     */
    SetFocusRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetFocusRequest)
            return object;
        let message = new $root.SetFocusRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetFocusRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetFocusRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.type) {
        case "FOCUS_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "FOCUS_TYPE_FOCUSED":
        case 1:
            message.type = 1;
            break;
        case "FOCUS_TYPE_UNFOCUSED":
        case 2:
            message.type = 2;
            break;
        }
        if (object.timeoutSecs != null)
            message.timeoutSecs = object.timeoutSecs >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a SetFocusRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetFocusRequest
     * @static
     * @param {SetFocusRequest} message SetFocusRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetFocusRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            object.type = options.enums === String ? "FOCUS_TYPE_UNKNOWN" : 0;
            object.timeoutSecs = 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.FocusType[message.type] : message.type;
        if (message.timeoutSecs != null && message.hasOwnProperty("timeoutSecs"))
            object.timeoutSecs = message.timeoutSecs;
        return object;
    };

    /**
     * Converts this SetFocusRequest to JSON.
     * @function toJSON
     * @memberof SetFocusRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetFocusRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetFocusRequest;
})();

export const SetFocusResponse = $root.SetFocusResponse = (() => {

    /**
     * Properties of a SetFocusResponse.
     * @exports ISetFocusResponse
     * @interface ISetFocusResponse
     * @property {IResponseHeader|null} [responseHeader] SetFocusResponse responseHeader
     * @property {number|Long|null} [timestamp] SetFocusResponse timestamp
     */

    /**
     * Constructs a new SetFocusResponse.
     * @exports SetFocusResponse
     * @classdesc Represents a SetFocusResponse.
     * @implements ISetFocusResponse
     * @constructor
     * @param {ISetFocusResponse=} [properties] Properties to set
     */
    function SetFocusResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetFocusResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetFocusResponse
     * @instance
     */
    SetFocusResponse.prototype.responseHeader = null;

    /**
     * SetFocusResponse timestamp.
     * @member {number|Long} timestamp
     * @memberof SetFocusResponse
     * @instance
     */
    SetFocusResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SetFocusResponse instance using the specified properties.
     * @function create
     * @memberof SetFocusResponse
     * @static
     * @param {ISetFocusResponse=} [properties] Properties to set
     * @returns {SetFocusResponse} SetFocusResponse instance
     */
    SetFocusResponse.create = function create(properties) {
        return new SetFocusResponse(properties);
    };

    /**
     * Encodes the specified SetFocusResponse message. Does not implicitly {@link SetFocusResponse.verify|verify} messages.
     * @function encode
     * @memberof SetFocusResponse
     * @static
     * @param {ISetFocusResponse} message SetFocusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
        return writer;
    };

    /**
     * Encodes the specified SetFocusResponse message, length delimited. Does not implicitly {@link SetFocusResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetFocusResponse
     * @static
     * @param {ISetFocusResponse} message SetFocusResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetFocusResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetFocusResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetFocusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetFocusResponse} SetFocusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetFocusResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.timestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetFocusResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetFocusResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetFocusResponse} SetFocusResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetFocusResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetFocusResponse message.
     * @function verify
     * @memberof SetFocusResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetFocusResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a SetFocusResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetFocusResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetFocusResponse} SetFocusResponse
     */
    SetFocusResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetFocusResponse)
            return object;
        let message = new $root.SetFocusResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetFocusResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SetFocusResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetFocusResponse
     * @static
     * @param {SetFocusResponse} message SetFocusResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetFocusResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        return object;
    };

    /**
     * Converts this SetFocusResponse to JSON.
     * @function toJSON
     * @memberof SetFocusResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetFocusResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetFocusResponse;
})();

export const SetGroupLinkSharingEnabledRequest = $root.SetGroupLinkSharingEnabledRequest = (() => {

    /**
     * Properties of a SetGroupLinkSharingEnabledRequest.
     * @exports ISetGroupLinkSharingEnabledRequest
     * @interface ISetGroupLinkSharingEnabledRequest
     * @property {IRequestHeader|null} [requestHeader] SetGroupLinkSharingEnabledRequest requestHeader
     * @property {IEventRequestHeader|null} [eventRequestHeader] SetGroupLinkSharingEnabledRequest eventRequestHeader
     * @property {GroupLinkSharingStatus|null} [groupLinkSharingStatus] SetGroupLinkSharingEnabledRequest groupLinkSharingStatus
     */

    /**
     * Constructs a new SetGroupLinkSharingEnabledRequest.
     * @exports SetGroupLinkSharingEnabledRequest
     * @classdesc Represents a SetGroupLinkSharingEnabledRequest.
     * @implements ISetGroupLinkSharingEnabledRequest
     * @constructor
     * @param {ISetGroupLinkSharingEnabledRequest=} [properties] Properties to set
     */
    function SetGroupLinkSharingEnabledRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetGroupLinkSharingEnabledRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetGroupLinkSharingEnabledRequest
     * @instance
     */
    SetGroupLinkSharingEnabledRequest.prototype.requestHeader = null;

    /**
     * SetGroupLinkSharingEnabledRequest eventRequestHeader.
     * @member {IEventRequestHeader|null|undefined} eventRequestHeader
     * @memberof SetGroupLinkSharingEnabledRequest
     * @instance
     */
    SetGroupLinkSharingEnabledRequest.prototype.eventRequestHeader = null;

    /**
     * SetGroupLinkSharingEnabledRequest groupLinkSharingStatus.
     * @member {GroupLinkSharingStatus} groupLinkSharingStatus
     * @memberof SetGroupLinkSharingEnabledRequest
     * @instance
     */
    SetGroupLinkSharingEnabledRequest.prototype.groupLinkSharingStatus = 0;

    /**
     * Creates a new SetGroupLinkSharingEnabledRequest instance using the specified properties.
     * @function create
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {ISetGroupLinkSharingEnabledRequest=} [properties] Properties to set
     * @returns {SetGroupLinkSharingEnabledRequest} SetGroupLinkSharingEnabledRequest instance
     */
    SetGroupLinkSharingEnabledRequest.create = function create(properties) {
        return new SetGroupLinkSharingEnabledRequest(properties);
    };

    /**
     * Encodes the specified SetGroupLinkSharingEnabledRequest message. Does not implicitly {@link SetGroupLinkSharingEnabledRequest.verify|verify} messages.
     * @function encode
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {ISetGroupLinkSharingEnabledRequest} message SetGroupLinkSharingEnabledRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetGroupLinkSharingEnabledRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            $root.EventRequestHeader.encode(message.eventRequestHeader, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.groupLinkSharingStatus);
        return writer;
    };

    /**
     * Encodes the specified SetGroupLinkSharingEnabledRequest message, length delimited. Does not implicitly {@link SetGroupLinkSharingEnabledRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {ISetGroupLinkSharingEnabledRequest} message SetGroupLinkSharingEnabledRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetGroupLinkSharingEnabledRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetGroupLinkSharingEnabledRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetGroupLinkSharingEnabledRequest} SetGroupLinkSharingEnabledRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetGroupLinkSharingEnabledRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetGroupLinkSharingEnabledRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.eventRequestHeader = $root.EventRequestHeader.decode(reader, reader.uint32());
                break;
            case 4:
                message.groupLinkSharingStatus = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetGroupLinkSharingEnabledRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetGroupLinkSharingEnabledRequest} SetGroupLinkSharingEnabledRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetGroupLinkSharingEnabledRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetGroupLinkSharingEnabledRequest message.
     * @function verify
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetGroupLinkSharingEnabledRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader")) {
            let error = $root.EventRequestHeader.verify(message.eventRequestHeader);
            if (error)
                return "eventRequestHeader." + error;
        }
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            switch (message.groupLinkSharingStatus) {
            default:
                return "groupLinkSharingStatus: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a SetGroupLinkSharingEnabledRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetGroupLinkSharingEnabledRequest} SetGroupLinkSharingEnabledRequest
     */
    SetGroupLinkSharingEnabledRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetGroupLinkSharingEnabledRequest)
            return object;
        let message = new $root.SetGroupLinkSharingEnabledRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetGroupLinkSharingEnabledRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.eventRequestHeader != null) {
            if (typeof object.eventRequestHeader !== "object")
                throw TypeError(".SetGroupLinkSharingEnabledRequest.eventRequestHeader: object expected");
            message.eventRequestHeader = $root.EventRequestHeader.fromObject(object.eventRequestHeader);
        }
        switch (object.groupLinkSharingStatus) {
        case "GROUP_LINK_SHARING_STATUS_UNKNOWN":
        case 0:
            message.groupLinkSharingStatus = 0;
            break;
        case "GROUP_LINK_SHARING_STATUS_ON":
        case 1:
            message.groupLinkSharingStatus = 1;
            break;
        case "GROUP_LINK_SHARING_STATUS_OFF":
        case 2:
            message.groupLinkSharingStatus = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SetGroupLinkSharingEnabledRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetGroupLinkSharingEnabledRequest
     * @static
     * @param {SetGroupLinkSharingEnabledRequest} message SetGroupLinkSharingEnabledRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetGroupLinkSharingEnabledRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.eventRequestHeader = null;
            object.groupLinkSharingStatus = options.enums === String ? "GROUP_LINK_SHARING_STATUS_UNKNOWN" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.eventRequestHeader != null && message.hasOwnProperty("eventRequestHeader"))
            object.eventRequestHeader = $root.EventRequestHeader.toObject(message.eventRequestHeader, options);
        if (message.groupLinkSharingStatus != null && message.hasOwnProperty("groupLinkSharingStatus"))
            object.groupLinkSharingStatus = options.enums === String ? $root.GroupLinkSharingStatus[message.groupLinkSharingStatus] : message.groupLinkSharingStatus;
        return object;
    };

    /**
     * Converts this SetGroupLinkSharingEnabledRequest to JSON.
     * @function toJSON
     * @memberof SetGroupLinkSharingEnabledRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetGroupLinkSharingEnabledRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetGroupLinkSharingEnabledRequest;
})();

export const SetGroupLinkSharingEnabledResponse = $root.SetGroupLinkSharingEnabledResponse = (() => {

    /**
     * Properties of a SetGroupLinkSharingEnabledResponse.
     * @exports ISetGroupLinkSharingEnabledResponse
     * @interface ISetGroupLinkSharingEnabledResponse
     * @property {IResponseHeader|null} [responseHeader] SetGroupLinkSharingEnabledResponse responseHeader
     * @property {IEvent|null} [createdEvent] SetGroupLinkSharingEnabledResponse createdEvent
     * @property {IConversation|null} [updatedConversation] SetGroupLinkSharingEnabledResponse updatedConversation
     */

    /**
     * Constructs a new SetGroupLinkSharingEnabledResponse.
     * @exports SetGroupLinkSharingEnabledResponse
     * @classdesc Represents a SetGroupLinkSharingEnabledResponse.
     * @implements ISetGroupLinkSharingEnabledResponse
     * @constructor
     * @param {ISetGroupLinkSharingEnabledResponse=} [properties] Properties to set
     */
    function SetGroupLinkSharingEnabledResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetGroupLinkSharingEnabledResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetGroupLinkSharingEnabledResponse
     * @instance
     */
    SetGroupLinkSharingEnabledResponse.prototype.responseHeader = null;

    /**
     * SetGroupLinkSharingEnabledResponse createdEvent.
     * @member {IEvent|null|undefined} createdEvent
     * @memberof SetGroupLinkSharingEnabledResponse
     * @instance
     */
    SetGroupLinkSharingEnabledResponse.prototype.createdEvent = null;

    /**
     * SetGroupLinkSharingEnabledResponse updatedConversation.
     * @member {IConversation|null|undefined} updatedConversation
     * @memberof SetGroupLinkSharingEnabledResponse
     * @instance
     */
    SetGroupLinkSharingEnabledResponse.prototype.updatedConversation = null;

    /**
     * Creates a new SetGroupLinkSharingEnabledResponse instance using the specified properties.
     * @function create
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {ISetGroupLinkSharingEnabledResponse=} [properties] Properties to set
     * @returns {SetGroupLinkSharingEnabledResponse} SetGroupLinkSharingEnabledResponse instance
     */
    SetGroupLinkSharingEnabledResponse.create = function create(properties) {
        return new SetGroupLinkSharingEnabledResponse(properties);
    };

    /**
     * Encodes the specified SetGroupLinkSharingEnabledResponse message. Does not implicitly {@link SetGroupLinkSharingEnabledResponse.verify|verify} messages.
     * @function encode
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {ISetGroupLinkSharingEnabledResponse} message SetGroupLinkSharingEnabledResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetGroupLinkSharingEnabledResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            $root.Event.encode(message.createdEvent, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.updatedConversation != null && message.hasOwnProperty("updatedConversation"))
            $root.Conversation.encode(message.updatedConversation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetGroupLinkSharingEnabledResponse message, length delimited. Does not implicitly {@link SetGroupLinkSharingEnabledResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {ISetGroupLinkSharingEnabledResponse} message SetGroupLinkSharingEnabledResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetGroupLinkSharingEnabledResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetGroupLinkSharingEnabledResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetGroupLinkSharingEnabledResponse} SetGroupLinkSharingEnabledResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetGroupLinkSharingEnabledResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetGroupLinkSharingEnabledResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.createdEvent = $root.Event.decode(reader, reader.uint32());
                break;
            case 3:
                message.updatedConversation = $root.Conversation.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetGroupLinkSharingEnabledResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetGroupLinkSharingEnabledResponse} SetGroupLinkSharingEnabledResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetGroupLinkSharingEnabledResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetGroupLinkSharingEnabledResponse message.
     * @function verify
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetGroupLinkSharingEnabledResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent")) {
            let error = $root.Event.verify(message.createdEvent);
            if (error)
                return "createdEvent." + error;
        }
        if (message.updatedConversation != null && message.hasOwnProperty("updatedConversation")) {
            let error = $root.Conversation.verify(message.updatedConversation);
            if (error)
                return "updatedConversation." + error;
        }
        return null;
    };

    /**
     * Creates a SetGroupLinkSharingEnabledResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetGroupLinkSharingEnabledResponse} SetGroupLinkSharingEnabledResponse
     */
    SetGroupLinkSharingEnabledResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetGroupLinkSharingEnabledResponse)
            return object;
        let message = new $root.SetGroupLinkSharingEnabledResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetGroupLinkSharingEnabledResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.createdEvent != null) {
            if (typeof object.createdEvent !== "object")
                throw TypeError(".SetGroupLinkSharingEnabledResponse.createdEvent: object expected");
            message.createdEvent = $root.Event.fromObject(object.createdEvent);
        }
        if (object.updatedConversation != null) {
            if (typeof object.updatedConversation !== "object")
                throw TypeError(".SetGroupLinkSharingEnabledResponse.updatedConversation: object expected");
            message.updatedConversation = $root.Conversation.fromObject(object.updatedConversation);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetGroupLinkSharingEnabledResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetGroupLinkSharingEnabledResponse
     * @static
     * @param {SetGroupLinkSharingEnabledResponse} message SetGroupLinkSharingEnabledResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetGroupLinkSharingEnabledResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            object.createdEvent = null;
            object.updatedConversation = null;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.createdEvent != null && message.hasOwnProperty("createdEvent"))
            object.createdEvent = $root.Event.toObject(message.createdEvent, options);
        if (message.updatedConversation != null && message.hasOwnProperty("updatedConversation"))
            object.updatedConversation = $root.Conversation.toObject(message.updatedConversation, options);
        return object;
    };

    /**
     * Converts this SetGroupLinkSharingEnabledResponse to JSON.
     * @function toJSON
     * @memberof SetGroupLinkSharingEnabledResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetGroupLinkSharingEnabledResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetGroupLinkSharingEnabledResponse;
})();

export const SetPresenceRequest = $root.SetPresenceRequest = (() => {

    /**
     * Properties of a SetPresenceRequest.
     * @exports ISetPresenceRequest
     * @interface ISetPresenceRequest
     * @property {IRequestHeader|null} [requestHeader] SetPresenceRequest requestHeader
     * @property {IPresenceStateSetting|null} [presenceStateSetting] SetPresenceRequest presenceStateSetting
     * @property {IDndSetting|null} [dndSetting] SetPresenceRequest dndSetting
     * @property {IDesktopOffSetting|null} [desktopOffSetting] SetPresenceRequest desktopOffSetting
     * @property {IMoodSetting|null} [moodSetting] SetPresenceRequest moodSetting
     */

    /**
     * Constructs a new SetPresenceRequest.
     * @exports SetPresenceRequest
     * @classdesc Represents a SetPresenceRequest.
     * @implements ISetPresenceRequest
     * @constructor
     * @param {ISetPresenceRequest=} [properties] Properties to set
     */
    function SetPresenceRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetPresenceRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetPresenceRequest
     * @instance
     */
    SetPresenceRequest.prototype.requestHeader = null;

    /**
     * SetPresenceRequest presenceStateSetting.
     * @member {IPresenceStateSetting|null|undefined} presenceStateSetting
     * @memberof SetPresenceRequest
     * @instance
     */
    SetPresenceRequest.prototype.presenceStateSetting = null;

    /**
     * SetPresenceRequest dndSetting.
     * @member {IDndSetting|null|undefined} dndSetting
     * @memberof SetPresenceRequest
     * @instance
     */
    SetPresenceRequest.prototype.dndSetting = null;

    /**
     * SetPresenceRequest desktopOffSetting.
     * @member {IDesktopOffSetting|null|undefined} desktopOffSetting
     * @memberof SetPresenceRequest
     * @instance
     */
    SetPresenceRequest.prototype.desktopOffSetting = null;

    /**
     * SetPresenceRequest moodSetting.
     * @member {IMoodSetting|null|undefined} moodSetting
     * @memberof SetPresenceRequest
     * @instance
     */
    SetPresenceRequest.prototype.moodSetting = null;

    /**
     * Creates a new SetPresenceRequest instance using the specified properties.
     * @function create
     * @memberof SetPresenceRequest
     * @static
     * @param {ISetPresenceRequest=} [properties] Properties to set
     * @returns {SetPresenceRequest} SetPresenceRequest instance
     */
    SetPresenceRequest.create = function create(properties) {
        return new SetPresenceRequest(properties);
    };

    /**
     * Encodes the specified SetPresenceRequest message. Does not implicitly {@link SetPresenceRequest.verify|verify} messages.
     * @function encode
     * @memberof SetPresenceRequest
     * @static
     * @param {ISetPresenceRequest} message SetPresenceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetPresenceRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.presenceStateSetting != null && message.hasOwnProperty("presenceStateSetting"))
            $root.PresenceStateSetting.encode(message.presenceStateSetting, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.dndSetting != null && message.hasOwnProperty("dndSetting"))
            $root.DndSetting.encode(message.dndSetting, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            $root.DesktopOffSetting.encode(message.desktopOffSetting, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting"))
            $root.MoodSetting.encode(message.moodSetting, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetPresenceRequest message, length delimited. Does not implicitly {@link SetPresenceRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetPresenceRequest
     * @static
     * @param {ISetPresenceRequest} message SetPresenceRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetPresenceRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetPresenceRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetPresenceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetPresenceRequest} SetPresenceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetPresenceRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetPresenceRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.presenceStateSetting = $root.PresenceStateSetting.decode(reader, reader.uint32());
                break;
            case 3:
                message.dndSetting = $root.DndSetting.decode(reader, reader.uint32());
                break;
            case 5:
                message.desktopOffSetting = $root.DesktopOffSetting.decode(reader, reader.uint32());
                break;
            case 8:
                message.moodSetting = $root.MoodSetting.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetPresenceRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetPresenceRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetPresenceRequest} SetPresenceRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetPresenceRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetPresenceRequest message.
     * @function verify
     * @memberof SetPresenceRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetPresenceRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.presenceStateSetting != null && message.hasOwnProperty("presenceStateSetting")) {
            let error = $root.PresenceStateSetting.verify(message.presenceStateSetting);
            if (error)
                return "presenceStateSetting." + error;
        }
        if (message.dndSetting != null && message.hasOwnProperty("dndSetting")) {
            let error = $root.DndSetting.verify(message.dndSetting);
            if (error)
                return "dndSetting." + error;
        }
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting")) {
            let error = $root.DesktopOffSetting.verify(message.desktopOffSetting);
            if (error)
                return "desktopOffSetting." + error;
        }
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting")) {
            let error = $root.MoodSetting.verify(message.moodSetting);
            if (error)
                return "moodSetting." + error;
        }
        return null;
    };

    /**
     * Creates a SetPresenceRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetPresenceRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetPresenceRequest} SetPresenceRequest
     */
    SetPresenceRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetPresenceRequest)
            return object;
        let message = new $root.SetPresenceRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetPresenceRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.presenceStateSetting != null) {
            if (typeof object.presenceStateSetting !== "object")
                throw TypeError(".SetPresenceRequest.presenceStateSetting: object expected");
            message.presenceStateSetting = $root.PresenceStateSetting.fromObject(object.presenceStateSetting);
        }
        if (object.dndSetting != null) {
            if (typeof object.dndSetting !== "object")
                throw TypeError(".SetPresenceRequest.dndSetting: object expected");
            message.dndSetting = $root.DndSetting.fromObject(object.dndSetting);
        }
        if (object.desktopOffSetting != null) {
            if (typeof object.desktopOffSetting !== "object")
                throw TypeError(".SetPresenceRequest.desktopOffSetting: object expected");
            message.desktopOffSetting = $root.DesktopOffSetting.fromObject(object.desktopOffSetting);
        }
        if (object.moodSetting != null) {
            if (typeof object.moodSetting !== "object")
                throw TypeError(".SetPresenceRequest.moodSetting: object expected");
            message.moodSetting = $root.MoodSetting.fromObject(object.moodSetting);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetPresenceRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetPresenceRequest
     * @static
     * @param {SetPresenceRequest} message SetPresenceRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetPresenceRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.presenceStateSetting = null;
            object.dndSetting = null;
            object.desktopOffSetting = null;
            object.moodSetting = null;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.presenceStateSetting != null && message.hasOwnProperty("presenceStateSetting"))
            object.presenceStateSetting = $root.PresenceStateSetting.toObject(message.presenceStateSetting, options);
        if (message.dndSetting != null && message.hasOwnProperty("dndSetting"))
            object.dndSetting = $root.DndSetting.toObject(message.dndSetting, options);
        if (message.desktopOffSetting != null && message.hasOwnProperty("desktopOffSetting"))
            object.desktopOffSetting = $root.DesktopOffSetting.toObject(message.desktopOffSetting, options);
        if (message.moodSetting != null && message.hasOwnProperty("moodSetting"))
            object.moodSetting = $root.MoodSetting.toObject(message.moodSetting, options);
        return object;
    };

    /**
     * Converts this SetPresenceRequest to JSON.
     * @function toJSON
     * @memberof SetPresenceRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetPresenceRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetPresenceRequest;
})();

export const SetPresenceResponse = $root.SetPresenceResponse = (() => {

    /**
     * Properties of a SetPresenceResponse.
     * @exports ISetPresenceResponse
     * @interface ISetPresenceResponse
     * @property {IResponseHeader|null} [responseHeader] SetPresenceResponse responseHeader
     */

    /**
     * Constructs a new SetPresenceResponse.
     * @exports SetPresenceResponse
     * @classdesc Represents a SetPresenceResponse.
     * @implements ISetPresenceResponse
     * @constructor
     * @param {ISetPresenceResponse=} [properties] Properties to set
     */
    function SetPresenceResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetPresenceResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetPresenceResponse
     * @instance
     */
    SetPresenceResponse.prototype.responseHeader = null;

    /**
     * Creates a new SetPresenceResponse instance using the specified properties.
     * @function create
     * @memberof SetPresenceResponse
     * @static
     * @param {ISetPresenceResponse=} [properties] Properties to set
     * @returns {SetPresenceResponse} SetPresenceResponse instance
     */
    SetPresenceResponse.create = function create(properties) {
        return new SetPresenceResponse(properties);
    };

    /**
     * Encodes the specified SetPresenceResponse message. Does not implicitly {@link SetPresenceResponse.verify|verify} messages.
     * @function encode
     * @memberof SetPresenceResponse
     * @static
     * @param {ISetPresenceResponse} message SetPresenceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetPresenceResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SetPresenceResponse message, length delimited. Does not implicitly {@link SetPresenceResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetPresenceResponse
     * @static
     * @param {ISetPresenceResponse} message SetPresenceResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetPresenceResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetPresenceResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetPresenceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetPresenceResponse} SetPresenceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetPresenceResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetPresenceResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetPresenceResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetPresenceResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetPresenceResponse} SetPresenceResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetPresenceResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetPresenceResponse message.
     * @function verify
     * @memberof SetPresenceResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetPresenceResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        return null;
    };

    /**
     * Creates a SetPresenceResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetPresenceResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetPresenceResponse} SetPresenceResponse
     */
    SetPresenceResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetPresenceResponse)
            return object;
        let message = new $root.SetPresenceResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetPresenceResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from a SetPresenceResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetPresenceResponse
     * @static
     * @param {SetPresenceResponse} message SetPresenceResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetPresenceResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        return object;
    };

    /**
     * Converts this SetPresenceResponse to JSON.
     * @function toJSON
     * @memberof SetPresenceResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetPresenceResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetPresenceResponse;
})();

export const SetTypingRequest = $root.SetTypingRequest = (() => {

    /**
     * Properties of a SetTypingRequest.
     * @exports ISetTypingRequest
     * @interface ISetTypingRequest
     * @property {IRequestHeader|null} [requestHeader] SetTypingRequest requestHeader
     * @property {IConversationId|null} [conversationId] SetTypingRequest conversationId
     * @property {TypingType|null} [type] SetTypingRequest type
     */

    /**
     * Constructs a new SetTypingRequest.
     * @exports SetTypingRequest
     * @classdesc Represents a SetTypingRequest.
     * @implements ISetTypingRequest
     * @constructor
     * @param {ISetTypingRequest=} [properties] Properties to set
     */
    function SetTypingRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetTypingRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SetTypingRequest
     * @instance
     */
    SetTypingRequest.prototype.requestHeader = null;

    /**
     * SetTypingRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof SetTypingRequest
     * @instance
     */
    SetTypingRequest.prototype.conversationId = null;

    /**
     * SetTypingRequest type.
     * @member {TypingType} type
     * @memberof SetTypingRequest
     * @instance
     */
    SetTypingRequest.prototype.type = 0;

    /**
     * Creates a new SetTypingRequest instance using the specified properties.
     * @function create
     * @memberof SetTypingRequest
     * @static
     * @param {ISetTypingRequest=} [properties] Properties to set
     * @returns {SetTypingRequest} SetTypingRequest instance
     */
    SetTypingRequest.create = function create(properties) {
        return new SetTypingRequest(properties);
    };

    /**
     * Encodes the specified SetTypingRequest message. Does not implicitly {@link SetTypingRequest.verify|verify} messages.
     * @function encode
     * @memberof SetTypingRequest
     * @static
     * @param {ISetTypingRequest} message SetTypingRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.type != null && message.hasOwnProperty("type"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified SetTypingRequest message, length delimited. Does not implicitly {@link SetTypingRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetTypingRequest
     * @static
     * @param {ISetTypingRequest} message SetTypingRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetTypingRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SetTypingRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetTypingRequest} SetTypingRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetTypingRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.type = reader.int32();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetTypingRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetTypingRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetTypingRequest} SetTypingRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetTypingRequest message.
     * @function verify
     * @memberof SetTypingRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetTypingRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
        return null;
    };

    /**
     * Creates a SetTypingRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetTypingRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetTypingRequest} SetTypingRequest
     */
    SetTypingRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SetTypingRequest)
            return object;
        let message = new $root.SetTypingRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SetTypingRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".SetTypingRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        switch (object.type) {
        case "TYPING_TYPE_UNKNOWN":
        case 0:
            message.type = 0;
            break;
        case "TYPING_TYPE_STARTED":
        case 1:
            message.type = 1;
            break;
        case "TYPING_TYPE_PAUSED":
        case 2:
            message.type = 2;
            break;
        case "TYPING_TYPE_STOPPED":
        case 3:
            message.type = 3;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SetTypingRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetTypingRequest
     * @static
     * @param {SetTypingRequest} message SetTypingRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetTypingRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            object.type = options.enums === String ? "TYPING_TYPE_UNKNOWN" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.TypingType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this SetTypingRequest to JSON.
     * @function toJSON
     * @memberof SetTypingRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetTypingRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetTypingRequest;
})();

export const SetTypingResponse = $root.SetTypingResponse = (() => {

    /**
     * Properties of a SetTypingResponse.
     * @exports ISetTypingResponse
     * @interface ISetTypingResponse
     * @property {IResponseHeader|null} [responseHeader] SetTypingResponse responseHeader
     * @property {number|Long|null} [timestamp] SetTypingResponse timestamp
     */

    /**
     * Constructs a new SetTypingResponse.
     * @exports SetTypingResponse
     * @classdesc Represents a SetTypingResponse.
     * @implements ISetTypingResponse
     * @constructor
     * @param {ISetTypingResponse=} [properties] Properties to set
     */
    function SetTypingResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SetTypingResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SetTypingResponse
     * @instance
     */
    SetTypingResponse.prototype.responseHeader = null;

    /**
     * SetTypingResponse timestamp.
     * @member {number|Long} timestamp
     * @memberof SetTypingResponse
     * @instance
     */
    SetTypingResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SetTypingResponse instance using the specified properties.
     * @function create
     * @memberof SetTypingResponse
     * @static
     * @param {ISetTypingResponse=} [properties] Properties to set
     * @returns {SetTypingResponse} SetTypingResponse instance
     */
    SetTypingResponse.create = function create(properties) {
        return new SetTypingResponse(properties);
    };

    /**
     * Encodes the specified SetTypingResponse message. Does not implicitly {@link SetTypingResponse.verify|verify} messages.
     * @function encode
     * @memberof SetTypingResponse
     * @static
     * @param {ISetTypingResponse} message SetTypingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
        return writer;
    };

    /**
     * Encodes the specified SetTypingResponse message, length delimited. Does not implicitly {@link SetTypingResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SetTypingResponse
     * @static
     * @param {ISetTypingResponse} message SetTypingResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SetTypingResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SetTypingResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SetTypingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SetTypingResponse} SetTypingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetTypingResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.timestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SetTypingResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SetTypingResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SetTypingResponse} SetTypingResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SetTypingResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SetTypingResponse message.
     * @function verify
     * @memberof SetTypingResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SetTypingResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                return "timestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a SetTypingResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SetTypingResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SetTypingResponse} SetTypingResponse
     */
    SetTypingResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SetTypingResponse)
            return object;
        let message = new $root.SetTypingResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SetTypingResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.timestamp != null)
            if ($util.Long)
                (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
                message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
                message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
                message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SetTypingResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SetTypingResponse
     * @static
     * @param {SetTypingResponse} message SetTypingResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SetTypingResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.timestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
                object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
                object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
        return object;
    };

    /**
     * Converts this SetTypingResponse to JSON.
     * @function toJSON
     * @memberof SetTypingResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SetTypingResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SetTypingResponse;
})();

export const SyncAllNewEventsRequest = $root.SyncAllNewEventsRequest = (() => {

    /**
     * Properties of a SyncAllNewEventsRequest.
     * @exports ISyncAllNewEventsRequest
     * @interface ISyncAllNewEventsRequest
     * @property {IRequestHeader|null} [requestHeader] SyncAllNewEventsRequest requestHeader
     * @property {number|Long|null} [lastSyncTimestamp] SyncAllNewEventsRequest lastSyncTimestamp
     * @property {number|Long|null} [maxResponseSizeBytes] SyncAllNewEventsRequest maxResponseSizeBytes
     */

    /**
     * Constructs a new SyncAllNewEventsRequest.
     * @exports SyncAllNewEventsRequest
     * @classdesc Represents a SyncAllNewEventsRequest.
     * @implements ISyncAllNewEventsRequest
     * @constructor
     * @param {ISyncAllNewEventsRequest=} [properties] Properties to set
     */
    function SyncAllNewEventsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncAllNewEventsRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SyncAllNewEventsRequest
     * @instance
     */
    SyncAllNewEventsRequest.prototype.requestHeader = null;

    /**
     * SyncAllNewEventsRequest lastSyncTimestamp.
     * @member {number|Long} lastSyncTimestamp
     * @memberof SyncAllNewEventsRequest
     * @instance
     */
    SyncAllNewEventsRequest.prototype.lastSyncTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncAllNewEventsRequest maxResponseSizeBytes.
     * @member {number|Long} maxResponseSizeBytes
     * @memberof SyncAllNewEventsRequest
     * @instance
     */
    SyncAllNewEventsRequest.prototype.maxResponseSizeBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SyncAllNewEventsRequest instance using the specified properties.
     * @function create
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {ISyncAllNewEventsRequest=} [properties] Properties to set
     * @returns {SyncAllNewEventsRequest} SyncAllNewEventsRequest instance
     */
    SyncAllNewEventsRequest.create = function create(properties) {
        return new SyncAllNewEventsRequest(properties);
    };

    /**
     * Encodes the specified SyncAllNewEventsRequest message. Does not implicitly {@link SyncAllNewEventsRequest.verify|verify} messages.
     * @function encode
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {ISyncAllNewEventsRequest} message SyncAllNewEventsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncAllNewEventsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.lastSyncTimestamp != null && message.hasOwnProperty("lastSyncTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastSyncTimestamp);
        if (message.maxResponseSizeBytes != null && message.hasOwnProperty("maxResponseSizeBytes"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.maxResponseSizeBytes);
        return writer;
    };

    /**
     * Encodes the specified SyncAllNewEventsRequest message, length delimited. Does not implicitly {@link SyncAllNewEventsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {ISyncAllNewEventsRequest} message SyncAllNewEventsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncAllNewEventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncAllNewEventsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncAllNewEventsRequest} SyncAllNewEventsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncAllNewEventsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncAllNewEventsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.lastSyncTimestamp = reader.uint64();
                break;
            case 8:
                message.maxResponseSizeBytes = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncAllNewEventsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncAllNewEventsRequest} SyncAllNewEventsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncAllNewEventsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncAllNewEventsRequest message.
     * @function verify
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncAllNewEventsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.lastSyncTimestamp != null && message.hasOwnProperty("lastSyncTimestamp"))
            if (!$util.isInteger(message.lastSyncTimestamp) && !(message.lastSyncTimestamp && $util.isInteger(message.lastSyncTimestamp.low) && $util.isInteger(message.lastSyncTimestamp.high)))
                return "lastSyncTimestamp: integer|Long expected";
        if (message.maxResponseSizeBytes != null && message.hasOwnProperty("maxResponseSizeBytes"))
            if (!$util.isInteger(message.maxResponseSizeBytes) && !(message.maxResponseSizeBytes && $util.isInteger(message.maxResponseSizeBytes.low) && $util.isInteger(message.maxResponseSizeBytes.high)))
                return "maxResponseSizeBytes: integer|Long expected";
        return null;
    };

    /**
     * Creates a SyncAllNewEventsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncAllNewEventsRequest} SyncAllNewEventsRequest
     */
    SyncAllNewEventsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncAllNewEventsRequest)
            return object;
        let message = new $root.SyncAllNewEventsRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SyncAllNewEventsRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.lastSyncTimestamp != null)
            if ($util.Long)
                (message.lastSyncTimestamp = $util.Long.fromValue(object.lastSyncTimestamp)).unsigned = true;
            else if (typeof object.lastSyncTimestamp === "string")
                message.lastSyncTimestamp = parseInt(object.lastSyncTimestamp, 10);
            else if (typeof object.lastSyncTimestamp === "number")
                message.lastSyncTimestamp = object.lastSyncTimestamp;
            else if (typeof object.lastSyncTimestamp === "object")
                message.lastSyncTimestamp = new $util.LongBits(object.lastSyncTimestamp.low >>> 0, object.lastSyncTimestamp.high >>> 0).toNumber(true);
        if (object.maxResponseSizeBytes != null)
            if ($util.Long)
                (message.maxResponseSizeBytes = $util.Long.fromValue(object.maxResponseSizeBytes)).unsigned = true;
            else if (typeof object.maxResponseSizeBytes === "string")
                message.maxResponseSizeBytes = parseInt(object.maxResponseSizeBytes, 10);
            else if (typeof object.maxResponseSizeBytes === "number")
                message.maxResponseSizeBytes = object.maxResponseSizeBytes;
            else if (typeof object.maxResponseSizeBytes === "object")
                message.maxResponseSizeBytes = new $util.LongBits(object.maxResponseSizeBytes.low >>> 0, object.maxResponseSizeBytes.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SyncAllNewEventsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncAllNewEventsRequest
     * @static
     * @param {SyncAllNewEventsRequest} message SyncAllNewEventsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncAllNewEventsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastSyncTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastSyncTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxResponseSizeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxResponseSizeBytes = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.lastSyncTimestamp != null && message.hasOwnProperty("lastSyncTimestamp"))
            if (typeof message.lastSyncTimestamp === "number")
                object.lastSyncTimestamp = options.longs === String ? String(message.lastSyncTimestamp) : message.lastSyncTimestamp;
            else
                object.lastSyncTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastSyncTimestamp) : options.longs === Number ? new $util.LongBits(message.lastSyncTimestamp.low >>> 0, message.lastSyncTimestamp.high >>> 0).toNumber(true) : message.lastSyncTimestamp;
        if (message.maxResponseSizeBytes != null && message.hasOwnProperty("maxResponseSizeBytes"))
            if (typeof message.maxResponseSizeBytes === "number")
                object.maxResponseSizeBytes = options.longs === String ? String(message.maxResponseSizeBytes) : message.maxResponseSizeBytes;
            else
                object.maxResponseSizeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxResponseSizeBytes) : options.longs === Number ? new $util.LongBits(message.maxResponseSizeBytes.low >>> 0, message.maxResponseSizeBytes.high >>> 0).toNumber(true) : message.maxResponseSizeBytes;
        return object;
    };

    /**
     * Converts this SyncAllNewEventsRequest to JSON.
     * @function toJSON
     * @memberof SyncAllNewEventsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncAllNewEventsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SyncAllNewEventsRequest;
})();

export const SyncAllNewEventsResponse = $root.SyncAllNewEventsResponse = (() => {

    /**
     * Properties of a SyncAllNewEventsResponse.
     * @exports ISyncAllNewEventsResponse
     * @interface ISyncAllNewEventsResponse
     * @property {IResponseHeader|null} [responseHeader] SyncAllNewEventsResponse responseHeader
     * @property {number|Long|null} [syncTimestamp] SyncAllNewEventsResponse syncTimestamp
     * @property {Array.<IConversationState>|null} [conversationState] SyncAllNewEventsResponse conversationState
     */

    /**
     * Constructs a new SyncAllNewEventsResponse.
     * @exports SyncAllNewEventsResponse
     * @classdesc Represents a SyncAllNewEventsResponse.
     * @implements ISyncAllNewEventsResponse
     * @constructor
     * @param {ISyncAllNewEventsResponse=} [properties] Properties to set
     */
    function SyncAllNewEventsResponse(properties) {
        this.conversationState = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncAllNewEventsResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SyncAllNewEventsResponse
     * @instance
     */
    SyncAllNewEventsResponse.prototype.responseHeader = null;

    /**
     * SyncAllNewEventsResponse syncTimestamp.
     * @member {number|Long} syncTimestamp
     * @memberof SyncAllNewEventsResponse
     * @instance
     */
    SyncAllNewEventsResponse.prototype.syncTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncAllNewEventsResponse conversationState.
     * @member {Array.<IConversationState>} conversationState
     * @memberof SyncAllNewEventsResponse
     * @instance
     */
    SyncAllNewEventsResponse.prototype.conversationState = $util.emptyArray;

    /**
     * Creates a new SyncAllNewEventsResponse instance using the specified properties.
     * @function create
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {ISyncAllNewEventsResponse=} [properties] Properties to set
     * @returns {SyncAllNewEventsResponse} SyncAllNewEventsResponse instance
     */
    SyncAllNewEventsResponse.create = function create(properties) {
        return new SyncAllNewEventsResponse(properties);
    };

    /**
     * Encodes the specified SyncAllNewEventsResponse message. Does not implicitly {@link SyncAllNewEventsResponse.verify|verify} messages.
     * @function encode
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {ISyncAllNewEventsResponse} message SyncAllNewEventsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncAllNewEventsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.syncTimestamp);
        if (message.conversationState != null && message.conversationState.length)
            for (let i = 0; i < message.conversationState.length; ++i)
                $root.ConversationState.encode(message.conversationState[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SyncAllNewEventsResponse message, length delimited. Does not implicitly {@link SyncAllNewEventsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {ISyncAllNewEventsResponse} message SyncAllNewEventsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncAllNewEventsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncAllNewEventsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncAllNewEventsResponse} SyncAllNewEventsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncAllNewEventsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncAllNewEventsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.syncTimestamp = reader.uint64();
                break;
            case 3:
                if (!(message.conversationState && message.conversationState.length))
                    message.conversationState = [];
                message.conversationState.push($root.ConversationState.decode(reader, reader.uint32()));
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncAllNewEventsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncAllNewEventsResponse} SyncAllNewEventsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncAllNewEventsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncAllNewEventsResponse message.
     * @function verify
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncAllNewEventsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            if (!$util.isInteger(message.syncTimestamp) && !(message.syncTimestamp && $util.isInteger(message.syncTimestamp.low) && $util.isInteger(message.syncTimestamp.high)))
                return "syncTimestamp: integer|Long expected";
        if (message.conversationState != null && message.hasOwnProperty("conversationState")) {
            if (!Array.isArray(message.conversationState))
                return "conversationState: array expected";
            for (let i = 0; i < message.conversationState.length; ++i) {
                let error = $root.ConversationState.verify(message.conversationState[i]);
                if (error)
                    return "conversationState." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SyncAllNewEventsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncAllNewEventsResponse} SyncAllNewEventsResponse
     */
    SyncAllNewEventsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncAllNewEventsResponse)
            return object;
        let message = new $root.SyncAllNewEventsResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SyncAllNewEventsResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.syncTimestamp != null)
            if ($util.Long)
                (message.syncTimestamp = $util.Long.fromValue(object.syncTimestamp)).unsigned = true;
            else if (typeof object.syncTimestamp === "string")
                message.syncTimestamp = parseInt(object.syncTimestamp, 10);
            else if (typeof object.syncTimestamp === "number")
                message.syncTimestamp = object.syncTimestamp;
            else if (typeof object.syncTimestamp === "object")
                message.syncTimestamp = new $util.LongBits(object.syncTimestamp.low >>> 0, object.syncTimestamp.high >>> 0).toNumber(true);
        if (object.conversationState) {
            if (!Array.isArray(object.conversationState))
                throw TypeError(".SyncAllNewEventsResponse.conversationState: array expected");
            message.conversationState = [];
            for (let i = 0; i < object.conversationState.length; ++i) {
                if (typeof object.conversationState[i] !== "object")
                    throw TypeError(".SyncAllNewEventsResponse.conversationState: object expected");
                message.conversationState[i] = $root.ConversationState.fromObject(object.conversationState[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SyncAllNewEventsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncAllNewEventsResponse
     * @static
     * @param {SyncAllNewEventsResponse} message SyncAllNewEventsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncAllNewEventsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.conversationState = [];
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.syncTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.syncTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            if (typeof message.syncTimestamp === "number")
                object.syncTimestamp = options.longs === String ? String(message.syncTimestamp) : message.syncTimestamp;
            else
                object.syncTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.syncTimestamp) : options.longs === Number ? new $util.LongBits(message.syncTimestamp.low >>> 0, message.syncTimestamp.high >>> 0).toNumber(true) : message.syncTimestamp;
        if (message.conversationState && message.conversationState.length) {
            object.conversationState = [];
            for (let j = 0; j < message.conversationState.length; ++j)
                object.conversationState[j] = $root.ConversationState.toObject(message.conversationState[j], options);
        }
        return object;
    };

    /**
     * Converts this SyncAllNewEventsResponse to JSON.
     * @function toJSON
     * @memberof SyncAllNewEventsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncAllNewEventsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SyncAllNewEventsResponse;
})();

export const SyncRecentConversationsRequest = $root.SyncRecentConversationsRequest = (() => {

    /**
     * Properties of a SyncRecentConversationsRequest.
     * @exports ISyncRecentConversationsRequest
     * @interface ISyncRecentConversationsRequest
     * @property {IRequestHeader|null} [requestHeader] SyncRecentConversationsRequest requestHeader
     * @property {number|Long|null} [lastEventTimestamp] SyncRecentConversationsRequest lastEventTimestamp
     * @property {number|Long|null} [maxConversations] SyncRecentConversationsRequest maxConversations
     * @property {number|Long|null} [maxEventsPerConversation] SyncRecentConversationsRequest maxEventsPerConversation
     * @property {Array.<SyncFilter>|null} [syncFilter] SyncRecentConversationsRequest syncFilter
     */

    /**
     * Constructs a new SyncRecentConversationsRequest.
     * @exports SyncRecentConversationsRequest
     * @classdesc Represents a SyncRecentConversationsRequest.
     * @implements ISyncRecentConversationsRequest
     * @constructor
     * @param {ISyncRecentConversationsRequest=} [properties] Properties to set
     */
    function SyncRecentConversationsRequest(properties) {
        this.syncFilter = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncRecentConversationsRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof SyncRecentConversationsRequest
     * @instance
     */
    SyncRecentConversationsRequest.prototype.requestHeader = null;

    /**
     * SyncRecentConversationsRequest lastEventTimestamp.
     * @member {number|Long} lastEventTimestamp
     * @memberof SyncRecentConversationsRequest
     * @instance
     */
    SyncRecentConversationsRequest.prototype.lastEventTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncRecentConversationsRequest maxConversations.
     * @member {number|Long} maxConversations
     * @memberof SyncRecentConversationsRequest
     * @instance
     */
    SyncRecentConversationsRequest.prototype.maxConversations = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncRecentConversationsRequest maxEventsPerConversation.
     * @member {number|Long} maxEventsPerConversation
     * @memberof SyncRecentConversationsRequest
     * @instance
     */
    SyncRecentConversationsRequest.prototype.maxEventsPerConversation = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncRecentConversationsRequest syncFilter.
     * @member {Array.<SyncFilter>} syncFilter
     * @memberof SyncRecentConversationsRequest
     * @instance
     */
    SyncRecentConversationsRequest.prototype.syncFilter = $util.emptyArray;

    /**
     * Creates a new SyncRecentConversationsRequest instance using the specified properties.
     * @function create
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {ISyncRecentConversationsRequest=} [properties] Properties to set
     * @returns {SyncRecentConversationsRequest} SyncRecentConversationsRequest instance
     */
    SyncRecentConversationsRequest.create = function create(properties) {
        return new SyncRecentConversationsRequest(properties);
    };

    /**
     * Encodes the specified SyncRecentConversationsRequest message. Does not implicitly {@link SyncRecentConversationsRequest.verify|verify} messages.
     * @function encode
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {ISyncRecentConversationsRequest} message SyncRecentConversationsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncRecentConversationsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.lastEventTimestamp != null && message.hasOwnProperty("lastEventTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastEventTimestamp);
        if (message.maxConversations != null && message.hasOwnProperty("maxConversations"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.maxConversations);
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxEventsPerConversation);
        if (message.syncFilter != null && message.syncFilter.length)
            for (let i = 0; i < message.syncFilter.length; ++i)
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.syncFilter[i]);
        return writer;
    };

    /**
     * Encodes the specified SyncRecentConversationsRequest message, length delimited. Does not implicitly {@link SyncRecentConversationsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {ISyncRecentConversationsRequest} message SyncRecentConversationsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncRecentConversationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncRecentConversationsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncRecentConversationsRequest} SyncRecentConversationsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncRecentConversationsRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncRecentConversationsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.lastEventTimestamp = reader.uint64();
                break;
            case 3:
                message.maxConversations = reader.uint64();
                break;
            case 4:
                message.maxEventsPerConversation = reader.uint64();
                break;
            case 5:
                if (!(message.syncFilter && message.syncFilter.length))
                    message.syncFilter = [];
                if ((tag & 7) === 2) {
                    let end2 = reader.uint32() + reader.pos;
                    while (reader.pos < end2)
                        message.syncFilter.push(reader.int32());
                } else
                    message.syncFilter.push(reader.int32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncRecentConversationsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncRecentConversationsRequest} SyncRecentConversationsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncRecentConversationsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncRecentConversationsRequest message.
     * @function verify
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncRecentConversationsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.lastEventTimestamp != null && message.hasOwnProperty("lastEventTimestamp"))
            if (!$util.isInteger(message.lastEventTimestamp) && !(message.lastEventTimestamp && $util.isInteger(message.lastEventTimestamp.low) && $util.isInteger(message.lastEventTimestamp.high)))
                return "lastEventTimestamp: integer|Long expected";
        if (message.maxConversations != null && message.hasOwnProperty("maxConversations"))
            if (!$util.isInteger(message.maxConversations) && !(message.maxConversations && $util.isInteger(message.maxConversations.low) && $util.isInteger(message.maxConversations.high)))
                return "maxConversations: integer|Long expected";
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            if (!$util.isInteger(message.maxEventsPerConversation) && !(message.maxEventsPerConversation && $util.isInteger(message.maxEventsPerConversation.low) && $util.isInteger(message.maxEventsPerConversation.high)))
                return "maxEventsPerConversation: integer|Long expected";
        if (message.syncFilter != null && message.hasOwnProperty("syncFilter")) {
            if (!Array.isArray(message.syncFilter))
                return "syncFilter: array expected";
            for (let i = 0; i < message.syncFilter.length; ++i)
                switch (message.syncFilter[i]) {
                default:
                    return "syncFilter: enum value[] expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
        }
        return null;
    };

    /**
     * Creates a SyncRecentConversationsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncRecentConversationsRequest} SyncRecentConversationsRequest
     */
    SyncRecentConversationsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncRecentConversationsRequest)
            return object;
        let message = new $root.SyncRecentConversationsRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".SyncRecentConversationsRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.lastEventTimestamp != null)
            if ($util.Long)
                (message.lastEventTimestamp = $util.Long.fromValue(object.lastEventTimestamp)).unsigned = true;
            else if (typeof object.lastEventTimestamp === "string")
                message.lastEventTimestamp = parseInt(object.lastEventTimestamp, 10);
            else if (typeof object.lastEventTimestamp === "number")
                message.lastEventTimestamp = object.lastEventTimestamp;
            else if (typeof object.lastEventTimestamp === "object")
                message.lastEventTimestamp = new $util.LongBits(object.lastEventTimestamp.low >>> 0, object.lastEventTimestamp.high >>> 0).toNumber(true);
        if (object.maxConversations != null)
            if ($util.Long)
                (message.maxConversations = $util.Long.fromValue(object.maxConversations)).unsigned = true;
            else if (typeof object.maxConversations === "string")
                message.maxConversations = parseInt(object.maxConversations, 10);
            else if (typeof object.maxConversations === "number")
                message.maxConversations = object.maxConversations;
            else if (typeof object.maxConversations === "object")
                message.maxConversations = new $util.LongBits(object.maxConversations.low >>> 0, object.maxConversations.high >>> 0).toNumber(true);
        if (object.maxEventsPerConversation != null)
            if ($util.Long)
                (message.maxEventsPerConversation = $util.Long.fromValue(object.maxEventsPerConversation)).unsigned = true;
            else if (typeof object.maxEventsPerConversation === "string")
                message.maxEventsPerConversation = parseInt(object.maxEventsPerConversation, 10);
            else if (typeof object.maxEventsPerConversation === "number")
                message.maxEventsPerConversation = object.maxEventsPerConversation;
            else if (typeof object.maxEventsPerConversation === "object")
                message.maxEventsPerConversation = new $util.LongBits(object.maxEventsPerConversation.low >>> 0, object.maxEventsPerConversation.high >>> 0).toNumber(true);
        if (object.syncFilter) {
            if (!Array.isArray(object.syncFilter))
                throw TypeError(".SyncRecentConversationsRequest.syncFilter: array expected");
            message.syncFilter = [];
            for (let i = 0; i < object.syncFilter.length; ++i)
                switch (object.syncFilter[i]) {
                default:
                case "SYNC_FILTER_UNKNOWN":
                case 0:
                    message.syncFilter[i] = 0;
                    break;
                case "SYNC_FILTER_INBOX":
                case 1:
                    message.syncFilter[i] = 1;
                    break;
                case "SYNC_FILTER_ARCHIVED":
                case 2:
                    message.syncFilter[i] = 2;
                    break;
                }
        }
        return message;
    };

    /**
     * Creates a plain object from a SyncRecentConversationsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncRecentConversationsRequest
     * @static
     * @param {SyncRecentConversationsRequest} message SyncRecentConversationsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncRecentConversationsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.syncFilter = [];
        if (options.defaults) {
            object.requestHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastEventTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastEventTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxConversations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxConversations = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxEventsPerConversation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxEventsPerConversation = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.lastEventTimestamp != null && message.hasOwnProperty("lastEventTimestamp"))
            if (typeof message.lastEventTimestamp === "number")
                object.lastEventTimestamp = options.longs === String ? String(message.lastEventTimestamp) : message.lastEventTimestamp;
            else
                object.lastEventTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastEventTimestamp) : options.longs === Number ? new $util.LongBits(message.lastEventTimestamp.low >>> 0, message.lastEventTimestamp.high >>> 0).toNumber(true) : message.lastEventTimestamp;
        if (message.maxConversations != null && message.hasOwnProperty("maxConversations"))
            if (typeof message.maxConversations === "number")
                object.maxConversations = options.longs === String ? String(message.maxConversations) : message.maxConversations;
            else
                object.maxConversations = options.longs === String ? $util.Long.prototype.toString.call(message.maxConversations) : options.longs === Number ? new $util.LongBits(message.maxConversations.low >>> 0, message.maxConversations.high >>> 0).toNumber(true) : message.maxConversations;
        if (message.maxEventsPerConversation != null && message.hasOwnProperty("maxEventsPerConversation"))
            if (typeof message.maxEventsPerConversation === "number")
                object.maxEventsPerConversation = options.longs === String ? String(message.maxEventsPerConversation) : message.maxEventsPerConversation;
            else
                object.maxEventsPerConversation = options.longs === String ? $util.Long.prototype.toString.call(message.maxEventsPerConversation) : options.longs === Number ? new $util.LongBits(message.maxEventsPerConversation.low >>> 0, message.maxEventsPerConversation.high >>> 0).toNumber(true) : message.maxEventsPerConversation;
        if (message.syncFilter && message.syncFilter.length) {
            object.syncFilter = [];
            for (let j = 0; j < message.syncFilter.length; ++j)
                object.syncFilter[j] = options.enums === String ? $root.SyncFilter[message.syncFilter[j]] : message.syncFilter[j];
        }
        return object;
    };

    /**
     * Converts this SyncRecentConversationsRequest to JSON.
     * @function toJSON
     * @memberof SyncRecentConversationsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncRecentConversationsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SyncRecentConversationsRequest;
})();

export const SyncRecentConversationsResponse = $root.SyncRecentConversationsResponse = (() => {

    /**
     * Properties of a SyncRecentConversationsResponse.
     * @exports ISyncRecentConversationsResponse
     * @interface ISyncRecentConversationsResponse
     * @property {IResponseHeader|null} [responseHeader] SyncRecentConversationsResponse responseHeader
     * @property {number|Long|null} [syncTimestamp] SyncRecentConversationsResponse syncTimestamp
     * @property {Array.<IConversationState>|null} [conversationState] SyncRecentConversationsResponse conversationState
     * @property {number|Long|null} [continuationEndTimestamp] SyncRecentConversationsResponse continuationEndTimestamp
     */

    /**
     * Constructs a new SyncRecentConversationsResponse.
     * @exports SyncRecentConversationsResponse
     * @classdesc Represents a SyncRecentConversationsResponse.
     * @implements ISyncRecentConversationsResponse
     * @constructor
     * @param {ISyncRecentConversationsResponse=} [properties] Properties to set
     */
    function SyncRecentConversationsResponse(properties) {
        this.conversationState = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncRecentConversationsResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof SyncRecentConversationsResponse
     * @instance
     */
    SyncRecentConversationsResponse.prototype.responseHeader = null;

    /**
     * SyncRecentConversationsResponse syncTimestamp.
     * @member {number|Long} syncTimestamp
     * @memberof SyncRecentConversationsResponse
     * @instance
     */
    SyncRecentConversationsResponse.prototype.syncTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * SyncRecentConversationsResponse conversationState.
     * @member {Array.<IConversationState>} conversationState
     * @memberof SyncRecentConversationsResponse
     * @instance
     */
    SyncRecentConversationsResponse.prototype.conversationState = $util.emptyArray;

    /**
     * SyncRecentConversationsResponse continuationEndTimestamp.
     * @member {number|Long} continuationEndTimestamp
     * @memberof SyncRecentConversationsResponse
     * @instance
     */
    SyncRecentConversationsResponse.prototype.continuationEndTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SyncRecentConversationsResponse instance using the specified properties.
     * @function create
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {ISyncRecentConversationsResponse=} [properties] Properties to set
     * @returns {SyncRecentConversationsResponse} SyncRecentConversationsResponse instance
     */
    SyncRecentConversationsResponse.create = function create(properties) {
        return new SyncRecentConversationsResponse(properties);
    };

    /**
     * Encodes the specified SyncRecentConversationsResponse message. Does not implicitly {@link SyncRecentConversationsResponse.verify|verify} messages.
     * @function encode
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {ISyncRecentConversationsResponse} message SyncRecentConversationsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncRecentConversationsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.syncTimestamp);
        if (message.conversationState != null && message.conversationState.length)
            for (let i = 0; i < message.conversationState.length; ++i)
                $root.ConversationState.encode(message.conversationState[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.continuationEndTimestamp != null && message.hasOwnProperty("continuationEndTimestamp"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.continuationEndTimestamp);
        return writer;
    };

    /**
     * Encodes the specified SyncRecentConversationsResponse message, length delimited. Does not implicitly {@link SyncRecentConversationsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {ISyncRecentConversationsResponse} message SyncRecentConversationsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncRecentConversationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncRecentConversationsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncRecentConversationsResponse} SyncRecentConversationsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncRecentConversationsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncRecentConversationsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.syncTimestamp = reader.uint64();
                break;
            case 3:
                if (!(message.conversationState && message.conversationState.length))
                    message.conversationState = [];
                message.conversationState.push($root.ConversationState.decode(reader, reader.uint32()));
                break;
            case 4:
                message.continuationEndTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncRecentConversationsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncRecentConversationsResponse} SyncRecentConversationsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncRecentConversationsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncRecentConversationsResponse message.
     * @function verify
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncRecentConversationsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            if (!$util.isInteger(message.syncTimestamp) && !(message.syncTimestamp && $util.isInteger(message.syncTimestamp.low) && $util.isInteger(message.syncTimestamp.high)))
                return "syncTimestamp: integer|Long expected";
        if (message.conversationState != null && message.hasOwnProperty("conversationState")) {
            if (!Array.isArray(message.conversationState))
                return "conversationState: array expected";
            for (let i = 0; i < message.conversationState.length; ++i) {
                let error = $root.ConversationState.verify(message.conversationState[i]);
                if (error)
                    return "conversationState." + error;
            }
        }
        if (message.continuationEndTimestamp != null && message.hasOwnProperty("continuationEndTimestamp"))
            if (!$util.isInteger(message.continuationEndTimestamp) && !(message.continuationEndTimestamp && $util.isInteger(message.continuationEndTimestamp.low) && $util.isInteger(message.continuationEndTimestamp.high)))
                return "continuationEndTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates a SyncRecentConversationsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncRecentConversationsResponse} SyncRecentConversationsResponse
     */
    SyncRecentConversationsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncRecentConversationsResponse)
            return object;
        let message = new $root.SyncRecentConversationsResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".SyncRecentConversationsResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        if (object.syncTimestamp != null)
            if ($util.Long)
                (message.syncTimestamp = $util.Long.fromValue(object.syncTimestamp)).unsigned = true;
            else if (typeof object.syncTimestamp === "string")
                message.syncTimestamp = parseInt(object.syncTimestamp, 10);
            else if (typeof object.syncTimestamp === "number")
                message.syncTimestamp = object.syncTimestamp;
            else if (typeof object.syncTimestamp === "object")
                message.syncTimestamp = new $util.LongBits(object.syncTimestamp.low >>> 0, object.syncTimestamp.high >>> 0).toNumber(true);
        if (object.conversationState) {
            if (!Array.isArray(object.conversationState))
                throw TypeError(".SyncRecentConversationsResponse.conversationState: array expected");
            message.conversationState = [];
            for (let i = 0; i < object.conversationState.length; ++i) {
                if (typeof object.conversationState[i] !== "object")
                    throw TypeError(".SyncRecentConversationsResponse.conversationState: object expected");
                message.conversationState[i] = $root.ConversationState.fromObject(object.conversationState[i]);
            }
        }
        if (object.continuationEndTimestamp != null)
            if ($util.Long)
                (message.continuationEndTimestamp = $util.Long.fromValue(object.continuationEndTimestamp)).unsigned = true;
            else if (typeof object.continuationEndTimestamp === "string")
                message.continuationEndTimestamp = parseInt(object.continuationEndTimestamp, 10);
            else if (typeof object.continuationEndTimestamp === "number")
                message.continuationEndTimestamp = object.continuationEndTimestamp;
            else if (typeof object.continuationEndTimestamp === "object")
                message.continuationEndTimestamp = new $util.LongBits(object.continuationEndTimestamp.low >>> 0, object.continuationEndTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SyncRecentConversationsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncRecentConversationsResponse
     * @static
     * @param {SyncRecentConversationsResponse} message SyncRecentConversationsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncRecentConversationsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.conversationState = [];
        if (options.defaults) {
            object.responseHeader = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.syncTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.syncTimestamp = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.continuationEndTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.continuationEndTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        if (message.syncTimestamp != null && message.hasOwnProperty("syncTimestamp"))
            if (typeof message.syncTimestamp === "number")
                object.syncTimestamp = options.longs === String ? String(message.syncTimestamp) : message.syncTimestamp;
            else
                object.syncTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.syncTimestamp) : options.longs === Number ? new $util.LongBits(message.syncTimestamp.low >>> 0, message.syncTimestamp.high >>> 0).toNumber(true) : message.syncTimestamp;
        if (message.conversationState && message.conversationState.length) {
            object.conversationState = [];
            for (let j = 0; j < message.conversationState.length; ++j)
                object.conversationState[j] = $root.ConversationState.toObject(message.conversationState[j], options);
        }
        if (message.continuationEndTimestamp != null && message.hasOwnProperty("continuationEndTimestamp"))
            if (typeof message.continuationEndTimestamp === "number")
                object.continuationEndTimestamp = options.longs === String ? String(message.continuationEndTimestamp) : message.continuationEndTimestamp;
            else
                object.continuationEndTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.continuationEndTimestamp) : options.longs === Number ? new $util.LongBits(message.continuationEndTimestamp.low >>> 0, message.continuationEndTimestamp.high >>> 0).toNumber(true) : message.continuationEndTimestamp;
        return object;
    };

    /**
     * Converts this SyncRecentConversationsResponse to JSON.
     * @function toJSON
     * @memberof SyncRecentConversationsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncRecentConversationsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return SyncRecentConversationsResponse;
})();

export const UpdateWatermarkRequest = $root.UpdateWatermarkRequest = (() => {

    /**
     * Properties of an UpdateWatermarkRequest.
     * @exports IUpdateWatermarkRequest
     * @interface IUpdateWatermarkRequest
     * @property {IRequestHeader|null} [requestHeader] UpdateWatermarkRequest requestHeader
     * @property {IConversationId|null} [conversationId] UpdateWatermarkRequest conversationId
     * @property {number|Long|null} [lastReadTimestamp] UpdateWatermarkRequest lastReadTimestamp
     */

    /**
     * Constructs a new UpdateWatermarkRequest.
     * @exports UpdateWatermarkRequest
     * @classdesc Represents an UpdateWatermarkRequest.
     * @implements IUpdateWatermarkRequest
     * @constructor
     * @param {IUpdateWatermarkRequest=} [properties] Properties to set
     */
    function UpdateWatermarkRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateWatermarkRequest requestHeader.
     * @member {IRequestHeader|null|undefined} requestHeader
     * @memberof UpdateWatermarkRequest
     * @instance
     */
    UpdateWatermarkRequest.prototype.requestHeader = null;

    /**
     * UpdateWatermarkRequest conversationId.
     * @member {IConversationId|null|undefined} conversationId
     * @memberof UpdateWatermarkRequest
     * @instance
     */
    UpdateWatermarkRequest.prototype.conversationId = null;

    /**
     * UpdateWatermarkRequest lastReadTimestamp.
     * @member {number|Long} lastReadTimestamp
     * @memberof UpdateWatermarkRequest
     * @instance
     */
    UpdateWatermarkRequest.prototype.lastReadTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new UpdateWatermarkRequest instance using the specified properties.
     * @function create
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {IUpdateWatermarkRequest=} [properties] Properties to set
     * @returns {UpdateWatermarkRequest} UpdateWatermarkRequest instance
     */
    UpdateWatermarkRequest.create = function create(properties) {
        return new UpdateWatermarkRequest(properties);
    };

    /**
     * Encodes the specified UpdateWatermarkRequest message. Does not implicitly {@link UpdateWatermarkRequest.verify|verify} messages.
     * @function encode
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {IUpdateWatermarkRequest} message UpdateWatermarkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateWatermarkRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            $root.RequestHeader.encode(message.requestHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            $root.ConversationId.encode(message.conversationId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.lastReadTimestamp != null && message.hasOwnProperty("lastReadTimestamp"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lastReadTimestamp);
        return writer;
    };

    /**
     * Encodes the specified UpdateWatermarkRequest message, length delimited. Does not implicitly {@link UpdateWatermarkRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {IUpdateWatermarkRequest} message UpdateWatermarkRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateWatermarkRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateWatermarkRequest message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateWatermarkRequest} UpdateWatermarkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateWatermarkRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateWatermarkRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.requestHeader = $root.RequestHeader.decode(reader, reader.uint32());
                break;
            case 2:
                message.conversationId = $root.ConversationId.decode(reader, reader.uint32());
                break;
            case 3:
                message.lastReadTimestamp = reader.uint64();
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateWatermarkRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateWatermarkRequest} UpdateWatermarkRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateWatermarkRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateWatermarkRequest message.
     * @function verify
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateWatermarkRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader")) {
            let error = $root.RequestHeader.verify(message.requestHeader);
            if (error)
                return "requestHeader." + error;
        }
        if (message.conversationId != null && message.hasOwnProperty("conversationId")) {
            let error = $root.ConversationId.verify(message.conversationId);
            if (error)
                return "conversationId." + error;
        }
        if (message.lastReadTimestamp != null && message.hasOwnProperty("lastReadTimestamp"))
            if (!$util.isInteger(message.lastReadTimestamp) && !(message.lastReadTimestamp && $util.isInteger(message.lastReadTimestamp.low) && $util.isInteger(message.lastReadTimestamp.high)))
                return "lastReadTimestamp: integer|Long expected";
        return null;
    };

    /**
     * Creates an UpdateWatermarkRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateWatermarkRequest} UpdateWatermarkRequest
     */
    UpdateWatermarkRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateWatermarkRequest)
            return object;
        let message = new $root.UpdateWatermarkRequest();
        if (object.requestHeader != null) {
            if (typeof object.requestHeader !== "object")
                throw TypeError(".UpdateWatermarkRequest.requestHeader: object expected");
            message.requestHeader = $root.RequestHeader.fromObject(object.requestHeader);
        }
        if (object.conversationId != null) {
            if (typeof object.conversationId !== "object")
                throw TypeError(".UpdateWatermarkRequest.conversationId: object expected");
            message.conversationId = $root.ConversationId.fromObject(object.conversationId);
        }
        if (object.lastReadTimestamp != null)
            if ($util.Long)
                (message.lastReadTimestamp = $util.Long.fromValue(object.lastReadTimestamp)).unsigned = true;
            else if (typeof object.lastReadTimestamp === "string")
                message.lastReadTimestamp = parseInt(object.lastReadTimestamp, 10);
            else if (typeof object.lastReadTimestamp === "number")
                message.lastReadTimestamp = object.lastReadTimestamp;
            else if (typeof object.lastReadTimestamp === "object")
                message.lastReadTimestamp = new $util.LongBits(object.lastReadTimestamp.low >>> 0, object.lastReadTimestamp.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from an UpdateWatermarkRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateWatermarkRequest
     * @static
     * @param {UpdateWatermarkRequest} message UpdateWatermarkRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateWatermarkRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.requestHeader = null;
            object.conversationId = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.lastReadTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.lastReadTimestamp = options.longs === String ? "0" : 0;
        }
        if (message.requestHeader != null && message.hasOwnProperty("requestHeader"))
            object.requestHeader = $root.RequestHeader.toObject(message.requestHeader, options);
        if (message.conversationId != null && message.hasOwnProperty("conversationId"))
            object.conversationId = $root.ConversationId.toObject(message.conversationId, options);
        if (message.lastReadTimestamp != null && message.hasOwnProperty("lastReadTimestamp"))
            if (typeof message.lastReadTimestamp === "number")
                object.lastReadTimestamp = options.longs === String ? String(message.lastReadTimestamp) : message.lastReadTimestamp;
            else
                object.lastReadTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.lastReadTimestamp) : options.longs === Number ? new $util.LongBits(message.lastReadTimestamp.low >>> 0, message.lastReadTimestamp.high >>> 0).toNumber(true) : message.lastReadTimestamp;
        return object;
    };

    /**
     * Converts this UpdateWatermarkRequest to JSON.
     * @function toJSON
     * @memberof UpdateWatermarkRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateWatermarkRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateWatermarkRequest;
})();

export const UpdateWatermarkResponse = $root.UpdateWatermarkResponse = (() => {

    /**
     * Properties of an UpdateWatermarkResponse.
     * @exports IUpdateWatermarkResponse
     * @interface IUpdateWatermarkResponse
     * @property {IResponseHeader|null} [responseHeader] UpdateWatermarkResponse responseHeader
     */

    /**
     * Constructs a new UpdateWatermarkResponse.
     * @exports UpdateWatermarkResponse
     * @classdesc Represents an UpdateWatermarkResponse.
     * @implements IUpdateWatermarkResponse
     * @constructor
     * @param {IUpdateWatermarkResponse=} [properties] Properties to set
     */
    function UpdateWatermarkResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateWatermarkResponse responseHeader.
     * @member {IResponseHeader|null|undefined} responseHeader
     * @memberof UpdateWatermarkResponse
     * @instance
     */
    UpdateWatermarkResponse.prototype.responseHeader = null;

    /**
     * Creates a new UpdateWatermarkResponse instance using the specified properties.
     * @function create
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {IUpdateWatermarkResponse=} [properties] Properties to set
     * @returns {UpdateWatermarkResponse} UpdateWatermarkResponse instance
     */
    UpdateWatermarkResponse.create = function create(properties) {
        return new UpdateWatermarkResponse(properties);
    };

    /**
     * Encodes the specified UpdateWatermarkResponse message. Does not implicitly {@link UpdateWatermarkResponse.verify|verify} messages.
     * @function encode
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {IUpdateWatermarkResponse} message UpdateWatermarkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateWatermarkResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            $root.ResponseHeader.encode(message.responseHeader, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateWatermarkResponse message, length delimited. Does not implicitly {@link UpdateWatermarkResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {IUpdateWatermarkResponse} message UpdateWatermarkResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateWatermarkResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateWatermarkResponse message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateWatermarkResponse} UpdateWatermarkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateWatermarkResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateWatermarkResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1:
                message.responseHeader = $root.ResponseHeader.decode(reader, reader.uint32());
                break;
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateWatermarkResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateWatermarkResponse} UpdateWatermarkResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateWatermarkResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateWatermarkResponse message.
     * @function verify
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateWatermarkResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader")) {
            let error = $root.ResponseHeader.verify(message.responseHeader);
            if (error)
                return "responseHeader." + error;
        }
        return null;
    };

    /**
     * Creates an UpdateWatermarkResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateWatermarkResponse} UpdateWatermarkResponse
     */
    UpdateWatermarkResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateWatermarkResponse)
            return object;
        let message = new $root.UpdateWatermarkResponse();
        if (object.responseHeader != null) {
            if (typeof object.responseHeader !== "object")
                throw TypeError(".UpdateWatermarkResponse.responseHeader: object expected");
            message.responseHeader = $root.ResponseHeader.fromObject(object.responseHeader);
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateWatermarkResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateWatermarkResponse
     * @static
     * @param {UpdateWatermarkResponse} message UpdateWatermarkResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateWatermarkResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.responseHeader = null;
        if (message.responseHeader != null && message.hasOwnProperty("responseHeader"))
            object.responseHeader = $root.ResponseHeader.toObject(message.responseHeader, options);
        return object;
    };

    /**
     * Converts this UpdateWatermarkResponse to JSON.
     * @function toJSON
     * @memberof UpdateWatermarkResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateWatermarkResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    return UpdateWatermarkResponse;
})();

export { $root as default };
